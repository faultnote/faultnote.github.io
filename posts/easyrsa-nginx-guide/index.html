<!doctype html><html lang=ko>
<head>
<title>로컬 웹 서비스에 Easy-RSA 인증서 적용하기 :: FaultNote</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="openssl 과 easyrsa 를 통해 가장 쉽게 로컬 인증서 관리하기">
<meta name=keywords content="nginx,easyrsa,certificate">
<meta name=robots content="noodp">
<link rel=canonical href=https://faultnote.github.io/posts/easyrsa-nginx-guide/>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6J40Z181KC"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-6J40Z181KC',{anonymize_ip:!1})}</script>
<link rel=stylesheet href=https://faultnote.github.io/assets/style.css>
<link rel=apple-touch-icon href=https://faultnote.github.io/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://faultnote.github.io/img/favicon/orange.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="ko">
<meta property="og:type" content="article">
<meta property="og:title" content="로컬 웹 서비스에 Easy-RSA 인증서 적용하기">
<meta property="og:description" content="openssl 과 easyrsa 를 통해 가장 쉽게 로컬 인증서 관리하기">
<meta property="og:url" content="https://faultnote.github.io/posts/easyrsa-nginx-guide/">
<meta property="og:site_name" content="FaultNote">
<meta property="og:image" content="https://faultnote.github.io/posts/images/cover-local-cert-easy-rsa.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:published_time" content="2022-02-12 14:05:53 +0900 +0900">
</head>
<body class=orange>
<div class="container headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
FaultNote
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>소개</a></li>
<li><a href=/series>연재</a></li>
<div class=spacer></div>
<ul class=language-selector>
<ul class=language-selector-current>
<li>한국어 ▾</li>
</ul>
<ul class="language-selector__more hidden">
<li><a href=https://faultnote.github.io/>한국어</a></li>
<li><a href=https://faultnote.github.io/en/>English</a></li>
</ul>
</ul>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>소개</a></li>
<li><a href=/series>연재</a></li>
<hr>
<li>
<a href=https://faultnote.github.io/>한국어</a>
</li>
<li>
<a href=https://faultnote.github.io/en/>English</a>
</li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://faultnote.github.io/posts/easyrsa-nginx-guide/>로컬 웹 서비스에 Easy-RSA 인증서 적용하기</a></h1>
<div class=post-meta>
<span class=post-date>
2022-02-12
</span>
<span class=post-author>:: soomtong</span>
<span class=post-reading-time>:: 6 min read (2639 words)</span>
</div>
<span class=post-tags>
#<a href=https://faultnote.github.io/tags/certificate/>certificate</a>&nbsp;
</span>
<img src=https://faultnote.github.io/posts/images/cover-local-cert-easy-rsa.png class=post-cover alt="로컬 웹 서비스에 Easy-RSA 인증서 적용하기" title="Cover Image">
<div class=post-content><div>
<blockquote>
<p>nginx 서버에 로컬 호스트의 도메인을 위한 인증서를 적용하는 가장 쉽고 빠른 방법</p>
</blockquote>
<h2 id=개인-키공개-키-기반-인증-시스템>개인 키/공개 키 기반 인증 시스템<a href=#개인-키공개-키-기반-인증-시스템 class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<h3 id=pki---public-key-infrastructure-이해하기>PKI - Public Key Infrastructure 이해하기<a href=#pki---public-key-infrastructure-이해하기 class=hanchor arialabel=Anchor>&#8983;</a> </h3>
<p>우리말로 <code>공개 키 기반 인증 시스템</code> 으로 이해할 수 있는데, 사실 한 쌍의 키가 중심이 되지만 &lsquo;공개 키&rsquo; 라고 불리는 이유는 이 공개 키를 기반으로 암호화 하는 과정이 핵심이라 그런 듯 하다.</p>
<p>공개 키 기반 인증은 한 쌍의 키를 전제로 한다. 만들어 진 한 쌍의 키는 하나는 공개용, 다른 하나는 비공개용 개인 키이다.</p>
<h4 id=공개키-기반-암호화복호화>공개키 기반 암호화/복호화<a href=#공개키-기반-암호화복호화 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p>PKI 를 통한 통신 과정에 암호화/복호화 작업은 기존에 보내는 사람이 주체가 되어 암호화 하는 과정에 일부 변형이 추가되었다. 암호화된 파일을 받을 대상의 공개 키로 암호화 하는 것이 핵심이다.</p>
<p>인터넷에 있는 많은 참고 이미지 중 이 도식이 가장 좋은 것 같다.</p>
<p><img src=/posts/images/pki-brief.jpeg alt=https://bobbyarvian.blogspot.com/2010/05/pki-public-key-infrastructure-dan-ca.html title="PKI-public key infrastructure dan CA-certificate authority"></p>
<p>나를 A 라 하고 받을 대상을 B 라 하면, 받을 대상의 공개 키로 암호화 하여 파일을 보내면 된다.</p>
<p>내가 누군가에게 암호화된 파일을 받기 위해서 내 공개 키를 제공하면 된다. 인증 관련된 서비스에서 요구하는 공개키가 이런 개념이다.</p>
<blockquote>
<p>예를 들면, 깃헙의 애플리케이션 연동이나 ssh 서버 연결에 사용되는 public key 가 이런 종류다.</p>
</blockquote>
<p>ssh 접속의 경우 내 공개키는 각 클라이언트와 서버가 암호화된 통신을 할 때 사용된다.</p>
<p>이 방식을 응용하여 메일을 교환하거나 송신, 수신되는 네트워크의 데이터들을 암호화 한다.</p>
<h4 id=x509>X.509<a href=#x509 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p>X.509 는 이 공개 키 기반의 인증 시스템으로 1988년 시작되어 현재는 버전3 를 사용하고 있다. 공개 키 기반의 다른 인증 시스템과 다르게 인증 기관이라는 개념을 도입하여 상위 기관을 통해 인증을 허용하는 시스템을 구성하고 있다.</p>
<p>인증서 작업에 사용되는 파일의 종류를 좀 알아두면 좋다. 대부분 모두 일반 텍스트 파일이다.</p>
<ul>
<li><code>.key</code>: 개인 키 파일이다. 이 파일은 공개용이 아니다.</li>
<li><code>.csr</code>: 인증 기관에 인증서를 받기 위해 요청하는 스펙을 담은 문서</li>
<li><code>.crt</code>: 인증서 자체, 암호화된 인증서 파일</li>
<li><code>.pem</code>: Base64 로 인코딩된 인증서로 웹 서버에 사용된다.</li>
</ul>
<h4 id=브라우저-통신과-ssltls>브라우저 통신과 SSL/TLS<a href=#브라우저-통신과-ssltls class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p>웹 서버 데이터에 대한 암호화를 위해 무한에 가까운 수의 서비스가 공개 키를 제공하고 이를 관리하기에는 효율이 좋지 않기에 제3자가 개입하여 인증을 대행하는 방식이다.</p>
<p>CA (Certificate authority) 또는 Root Certificate (루트 인증 기관) 라고 불리는 기관들이 이 역할을 한다.</p>
<p><img src=/posts/images/ca-tls-brief.jpeg alt=https://bobbyarvian.blogspot.com/2010/05/pki-public-key-infrastructure-dan-ca.html title="PKI-public key infrastructure dan CA-certificate authority"></p>
<p>https 통신에 사용되는 보안 프로토콜로 1999년 SSL(Secure Sockets Layer) 3.0 이 TLS(Transport Sockets Layer) 1.0 으로 공개 되었다.</p>
<p>현재 SSL 버전 사용은 권고 되지 않는다.</p>
<h2 id=openssl-과-easy-rsa>OpenSSL 과 Easy-RSA<a href=#openssl-과-easy-rsa class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>OpenSSL 은 이런 암호화/복호화에 관여하는 프로토콜인 TLS 의 오픈소스 구현으로 다양한 시스템에 사용되고 있으며 무료 인증서로 자주 거론되는 Let&rsquo;s encrypt 에서도 사용하고 있다.</p>
<p>얼마 전 (2021년) 3.0 을 공개하였다.</p>
<blockquote>
<p>openssl 툴을 활용해 다양한 인증서 생성 및 인증 요청서를 만들수 있는데, 조금 복잡하다. 그래서 이 과정을 단순화하고 체계적으로 유지하기 위한 &lsquo;easy-rsa&rsquo; 가 개발되어 있고, 이를 사용하여 로컬 서비스에 인증서를 적용하는 방법을 알아보려 한다.</p>
</blockquote>
<p>아마 대부분의 개발자 시스템에 openssl 은 설치되어 있을 것이다. 추가로 easy-rsa 를 설치해 보자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ brew info easy-rsa
</code></pre></div><p>실행 파일은 <code>easyrsa</code> 이니 헷갈리지 말자.</p>
<p>Public Key Infrastructure(PKI) 환경을 구성하기 위해 초기화 작업이 필요하다.
개인키가 없지 않겠지만 easyrsa 를 통해 서비스용을 하나 만들자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ easyrsa init-pki
</code></pre></div><h3 id=macos-키체인-유틸리티>macOS 키체인 유틸리티<a href=#macos-키체인-유틸리티 class=hanchor arialabel=Anchor>&#8983;</a> </h3>
<p>인증서를 생성하기 전에 인증서를 운영체제에서 사용하고 유지/관리하는 방법을 이해해야 한다.</p>
<p>맥OS 에서 인증서는 <code>Keychain Access</code> 유틸리티를 통해 관리할 수 있다. 이 안에 각종 루트 인증서들이 있고 우리가 만들 사설 루트 인증서를 추가하여 관리할 것이다.</p>
<p><img src=/posts/images/macos-keychain-access.png alt="macOS Keychain Access"></p>
<h3 id=시나리오>시나리오<a href=#시나리오 class=hanchor arialabel=Anchor>&#8983;</a> </h3>
<p>주요 작업 시나리오는 다음과 같다.</p>
<ol>
<li>가상의 최상위 인증 기관 인증서 생성</li>
<li>최상위 인증 기관의 인증서를 운영체제에 추가, 사용 허용</li>
<li>인증 기관에서 상속된 서비스용 인증서 생성</li>
<li>nginx 에 인증서 적용</li>
</ol>
<h3 id=루트-인증서-발급>루트 인증서 발급<a href=#루트-인증서-발급 class=hanchor arialabel=Anchor>&#8983;</a> </h3>
<p>웹 브라우저는 루트 인증기관(CA)을 신뢰하고 대부분의 브라우저는 이 루트 인증서와 암호화된 통신 프로토콜을 내장하고 있다.</p>
<p>실제 서비스에는 이 루트 인증기관에서 비용을 제공하고 운영할 서비스 사이트의 인증서를 발급 받아 적용해야 한다.</p>
<blockquote>
<p>우리가 사용할 로컬 개발 환경의 웹 서버를 위해 인증서를 구입하거나 실제 도메인이 부여되지 않은 사이트의 인증서를 발급 받기는 애매하다. 그래서 가상의 루트 인증기관을 만들어 루트 인증서를 생성하고 이 기관을 통해 로컬 서비스의 인증서를 생성해 웹 서버에 적용할 것이다.</p>
</blockquote>
<h4 id=ca-만들기>CA 만들기<a href=#ca-만들기 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p>easyrsa 를 통해 루트 인증기관의 인증서를 쉽게 생성할 수 있다. 이 과정은 CA 에 대한 조직 정보를 포함한다. easyrsa 는 <code>Easy-RSA CA</code> 을 사용한다. 그대로 쓰자.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ easyrsa build-ca
</code></pre></div><p>생성된 인증서는 <code>/usr/local/etc/pki/ca.crt</code> 에서 확인할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ cat /usr/local/etc/pki/ca.crt
</code></pre></div><p>이 과정은 다음 내용을 포함하고 있다.</p>
<ol>
<li>루트 인증기관을 위한 개인 키를 만들고 → <code>.key</code> 파일</li>
<li>인증 서명 요청서을 만들고 → <code>.csr</code> 파일</li>
<li>x509 서명까지 완성한다 → <code>.crt</code> 파일</li>
</ol>
<p>만들어진 루트 인증서 내용은 easyrsa 를 통해 확인할 수 있다. 기본적으로 10년 짜리 서명을 제공해 준다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ easyrsa show-ca
Using SSL: /usr/local/opt/openssl@1.1/bin/openssl OpenSSL 1.1.1m  <span style=color:#ae81ff>14</span> Dec <span style=color:#ae81ff>2021</span>

Showing  details <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#39;ca&#39;</span>.
This file is stored at:
/usr/local/etc/pki/ca.crt
...
</code></pre></div><h4 id=keychain-access-에-추가-및-허용>KeyChain Access 에 추가 및 허용<a href=#keychain-access-에-추가-및-허용 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p><code>File > Import Item</code> 메뉴를 통해 위에서 생성한 루트 인증서를 추가하고 안전한 사용을 허용하자.</p>
<p><img src=/posts/images/macos-keychain-access-permit-root-cert.png alt="macOS Keychain Access"></p>
<p>이 작업 후에는 로그아웃 하고 다시 로그인 하여 시스템에 인증서가 적재되도록 한다.</p>
<h3 id=로컬-서비스용-인증서-발급>로컬 서비스용 인증서 발급<a href=#로컬-서비스용-인증서-발급 class=hanchor arialabel=Anchor>&#8983;</a> </h3>
<p>이제 우리가 사용할 로컬 서비스의 서버 인증서 만들자.</p>
<p>마찬가지로 서버 용 비공개 키를 만들고 루트 인증 기관의 인증을 받아 서버 인증서를 만든다. 복잡한 절차가 있지만 easyrsa 로 단순하게 처리할 수 있다.</p>
<p>이 과정에서 <code>localhost</code> 라는 파일 이름 기반의 식별자를 사용하였다. 이 부분을 xxx-server 등으로 자유롭게 변경하여 사용할 수 있다.</p>
<h4 id=멀티-호스트-인증>멀티 호스트 인증<a href=#멀티-호스트-인증 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p>내 경우 관리하는 호스트가 여러 개이다 보니 멀티 호스트 인증을 하면 하나의 인증서로 다중 도메인을 처리할 수 있다. <code>EASYRSA_EXTRA_EXTS</code> 환경 변수에 추가할 도메인 정보를 담아 생성할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ export EASYRSA_EXTRA_EXTS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;subjectAltName=DNS.1:local.site-a,DNS.2:local.site-b&#34;</span>
</code></pre></div><h4 id=서버-인증서-생성>서버 인증서 생성<a href=#서버-인증서-생성 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ easyrsa build-server-full localhost nopass
</code></pre></div><p><code>nopass</code> 옵션은 인증서의 사용 과정에 패스워드를 적용하지 않는 옵션이다.</p>
<blockquote>
<p>서버 인증서는 nginx 등의 서버를 구동할 때마다 패스워드를 요구해서 보통 패스워드 없이 생성한다.</p>
</blockquote>
<p>이렇게 생성된 인증서는 <code>/usr/local/etc/pki/issued</code> 에 저장되어 있다.</p>
<p>앞 부분에는 인증 대상의 정보가 있고 아래에 인증서 정보가 있다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ cat /usr/local/etc/pki/issued/localhost.crt
$ easyrsa show-cert localhost
...
  X509v3 Extended Key Usage:
      TLS Web Server Authentication
  X509v3 Key Usage:
      Digital Signature, Key Encipherment
  X509v3 Subject Alternative Name:
      DNS:local.site-a, DNS:local.site-b, DNS:local.site-c, DNS:local.site-d
...
</code></pre></div><p><code>Subject Alternative Name:</code> 항목에 다중 도메인이 기록된 것을 확인할 수 있다.</p>
<h4 id=nginx-용-인증서-조립>nginx 용 인증서 조립<a href=#nginx-용-인증서-조립 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p>이렇게 생성된 인증서를 웹 서버에 사용하기 위해 조립 과정을 거쳐야 한다.</p>
<p>핵심은 서버 인증서와 루트 인증서를 결합하여 웹 서버에 맞는 인증서 파일을 생성하는 것이다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ cat -p /usr/local/etc/pki/issued/localhost.crt <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>         /usr/local/etc/pki/ca.crt &gt; ./server.pem
</code></pre></div><blockquote>
<p>오리지널 cat 대신 bat 을 사용하고 있어 <code>-p</code> 옵션이 추가되었다.</p>
</blockquote>
<p>이렇게 생성된 파일과 서버의 키 정보를 nginx conf 에 추가하자.</p>
<pre tabindex=0><code class=language-conf data-lang=conf>ssl_certificate [server.pem 이 있는 경로]/server.pem;
ssl_certificate_key /usr/local/etc/pki/private/localhost.key;
</code></pre><p>easyrsa 가 없었으면 아래와 여러 단계의 과정을 거쳐야 했을 것이다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ openssl ecparam -out server.key -name prime256v1 -genkey
$ openssl req -new -sha256 -key server.key -out server.csr -config ./openssl-host.conf
$ openssl x509 -req -sha256 -days <span style=color:#ae81ff>365</span> -in server.csr -CA /usr/local/etc/pki/ca.crt -CAkey /usr/local/etc/pki/private/ca.key -CAcreateserial -out server.crt
$ openssl x509 -in server.crt -text -noout
</code></pre></div><p>물론 openssl 을 통해 생성된 인증서를 점검할 수 있다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ openssl x509 -in /usr/local/etc/pki/issued/localhost.crt -text -noout
</code></pre></div><p><img src=/posts/images/ngixn-certi-localhost.png alt="certified localhost in nginx"></p>
<h4 id=인증서-관리>인증서 관리<a href=#인증서-관리 class=hanchor arialabel=Anchor>&#8983;</a> </h4>
<p><code>easyrsa</code> 는 <code>renew</code> 나 <code>revoke</code> 등의 명령이 제공된다.</p>
<p>revoke 하더라도 기존 .key 파일이나 .csr 등의 파일을 지워주는 것이 아니니 따로 삭제해줘야 한다.</p>
<p>도메인 추가 정도라면 EASYRSA_EXTRA_EXTS export 를 수정하고 renew 하면 된다.</p>
</div></div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class=copyright>
<span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
</div>
</div>
</footer>
<script src=https://faultnote.github.io/assets/main.js></script>
<script src=https://faultnote.github.io/assets/prism.js></script>
<script src=https://faultnote.github.io/assets/languageSelector.js></script>
</div>
</body>
</html>