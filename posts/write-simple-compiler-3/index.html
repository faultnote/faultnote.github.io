<!doctype html><html lang=ko><head><title>Write Deadly Simple Compiler Part 3 :: FaultNote</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="내가 처음으로 구독한 개인 메일인 Phil 의 웹 페이지에 있는 2018년 말 포스트인 'Writing a lisp compiler from scratch in JavaScript' 를 학습하며 기록한 글이다."><meta name=keywords content="compiler,parser,asm,llvm"><meta name=robots content="noodp"><link rel=canonical href=https://faultnote.github.io/posts/write-simple-compiler-3/><script async src="https://www.googletagmanager.com/gtag/js?id=G-6J40Z181KC"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6J40Z181KC",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://faultnote.github.io/assets/style.css><link rel=apple-touch-icon href=https://faultnote.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://faultnote.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="og:title" content="Write Deadly Simple Compiler Part 3"><meta property="og:description" content="내가 처음으로 구독한 개인 메일인 Phil 의 웹 페이지에 있는 2018년 말 포스트인 'Writing a lisp compiler from scratch in JavaScript' 를 학습하며 기록한 글이다."><meta property="og:url" content="https://faultnote.github.io/posts/write-simple-compiler-3/"><meta property="og:site_name" content="FaultNote"><meta property="og:image" content="https://faultnote.github.io/img/favicon/orange.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2023-01-07 20:00:00 +0900 +0900"></head><body class=orange><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>FaultNote</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>한국어 ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://faultnote.github.io/en/>English</a></li><li><a href=https://faultnote.github.io/>한국어</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><hr><li><a href=https://faultnote.github.io/en/>English</a></li><li><a href=https://faultnote.github.io/>한국어</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://faultnote.github.io/posts/write-simple-compiler-3/>Write Deadly Simple Compiler Part 3</a></h1><div class=post-meta><span class=post-date>2023-01-07</span>
<span class=post-author>:: soomtong</span>
<span class=post-reading-time>:: 5 min read (2032 words)</span></div><span class=post-tags>#<a href=https://faultnote.github.io/tags/compiler/>compiler</a>&nbsp;
#<a href=https://faultnote.github.io/tags/assembliy/>assembliy</a>&nbsp;
#<a href=https://faultnote.github.io/tags/javascript/>javascript</a>&nbsp;</span><div class=post-content><div><blockquote><p><a href=https://notes.eatonphil.com>Phil</a> 의 &lsquo;Writing a lisp compiler from scratch in JavaScript&rsquo; 첫 포스트의 세 번째 파트인데 분량이 많아 새 포스트를 열었다.</p></blockquote><p>지난 포스트에 이어서&mldr;</p><p>Phil 의 가이드에 마지막 부분은 파싱된 배열을 어셈블리로 변환하는 컴파일 과정을 담고 있다.
그리고 어셈블리를 어셈블! 하는 것으로 첫 포스트를 마치고 있다.</p><h2 id=테스트-코드-러너>테스트 코드 러너<a href=#테스트-코드-러너 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>주어진 구문을 파싱하고 컴파일 하는 간단한 스크립트를 하나 만들어 보자. 보통 script runner 같은 이름이 사용된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>compile</span>, <span style=color:#a6e22e>parse</span> } <span style=color:#f92672>=</span> <span style=color:#66d9ef>require</span>(<span style=color:#e6db74>&#39;./lib&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>program</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;(+ 3 (+ 1 2)&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>parsed</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>program</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>assmbled</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>compile</span>(<span style=color:#a6e22e>parsed</span>[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;---------------------------------------------------&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>dir</span>(<span style=color:#a6e22e>parsed</span>, { <span style=color:#a6e22e>colors</span>: <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>depth</span>: <span style=color:#66d9ef>5</span>, <span style=color:#a6e22e>showHidden</span>: <span style=color:#66d9ef>false</span> });
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;---------------------------------------------------&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>assmbled</span>);
</span></span></code></pre></div><p>이 스크립트를 실행하면 아래와 같은 결과를 얻을 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>---------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#39;+&#39;</span>, 3, <span style=color:#f92672>[</span> <span style=color:#e6db74>&#39;+&#39;</span>, 1, <span style=color:#ae81ff>2</span> <span style=color:#f92672>]</span> <span style=color:#f92672>]</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>---------------------------------------------------
</span></span><span style=display:flex><span>	.global _main_
</span></span><span style=display:flex><span>	.text
</span></span><span style=display:flex><span>plus:
</span></span><span style=display:flex><span>	ADD RDI, RSI
</span></span><span style=display:flex><span>	MOV RAX, RDI
</span></span><span style=display:flex><span>	RET
</span></span><span style=display:flex><span>_main_:
</span></span><span style=display:flex><span>	PUSH RDI
</span></span><span style=display:flex><span>	PUSH RSI
</span></span><span style=display:flex><span>	MOV RDI, <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>	PUSH RDI
</span></span><span style=display:flex><span>	PUSH RSI
</span></span><span style=display:flex><span>	MOV RDI, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	MOV RSI, <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	CALL plus
</span></span><span style=display:flex><span>	POP RSI
</span></span><span style=display:flex><span>	POP RDI
</span></span><span style=display:flex><span>	MOV RSI, RAX
</span></span><span style=display:flex><span>	CALL plus
</span></span><span style=display:flex><span>	POP RSI
</span></span><span style=display:flex><span>	POP RDI
</span></span><span style=display:flex><span>	MOV RDI, RAX
</span></span><span style=display:flex><span>	MOV RAX, 0x2000001
</span></span><span style=display:flex><span>	SYSCALL
</span></span></code></pre></div><p>파싱된 AST 의 첫 원소가 우리가 사용할 결과이다. macOS 에서 컴파일하기 위해 추가한 코드는 저장소를 살펴 보도록 한다.</p><p>대략 개요는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ExitCode</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>string</span>&gt; <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>darwin</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;0x2000001&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;60&#39;</span>,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>이제 진짜 어셈블 해 실행 파일(바이너리)를 만들어 보자.</p><h2 id=실행-코드-생성>실행 코드 생성<a href=#실행-코드-생성 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>테스트 코드 러너를 Phil 의 문서와 같이 <code>ulisp</code> 이란 파일로 만들어 실행 가능하게 하고 <code>gcc</code> 명령도 함께 실행되도록 하면 이 전체 동작을 포장할 수 있을 것이다.</p><p><code>ulisp</code> 파일은 실행 권한을 부여하여 <code>node</code> 가 있으면 스스로 실행 가능하도록 하고 <code>./tmp</code> 폴더에서 컴파일하고 어셈블하고 실행 파일을 만드는, 소위 툴체인 형식을 가지도록 해보자.</p><p>소스를 지정하고 실행 파일을 만들어 내는 절차를 좀 그럴 듯 하게 가져가 보려 했지만 어짜피 한 줄의 S-Expression 구문을 컴파일하는 것이 전부인 관계로 그냥 아래와 같은 형식으로 명령을 실행하도록 하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ulisp.js <span style=color:#e6db74>&#39;(+ 3 (+ 2 1))&#39;</span>
</span></span></code></pre></div><blockquote><p>이 과정을 겪으며 알게된 사실인데 우리 프로그램의 엔트리 포인트로 사용하는 <code>_main_</code> 은 잘못된 식별자였다. 정상 동작을 위해 <code>_main</code> 으로 변경하였다.</p></blockquote><p>어셈블리를 컴파일하기 위해 <code>gcc</code> 를 사용하고 있다. gcc 는 gnu compiler collection 의 약자로 다양한 코드를 컴파일 할 수 있다. 어셈블리 컴파일(어셈블)하기 위해 아래와 같은 명령을 사용한다.</p><p><code>gcc 옵션 -o 출력파일이름 소스파일이름</code></p><p>ulisp.js 의 전체 코드는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>writeFileSync</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;fs&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>execSync</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;child_process&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>parse</span>, <span style=color:#a6e22e>compile</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;./lib&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>CC</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;gcc&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>SOURCE</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;program.S&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>args</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>script</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>script</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;no source&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>program</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>compile</span>(<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>script</span>)[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>writeFileSync</span>(<span style=color:#a6e22e>SOURCE</span>, <span style=color:#a6e22e>program</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>execSync</span>(<span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>CC</span><span style=color:#e6db74>}</span><span style=color:#e6db74> -mstackrealign -masm=intel -o program </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>SOURCE</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;done; \nrun ./program and echo $? for output&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>argv</span>);
</span></span></code></pre></div><p>실행 플래그를 주는 방법은 <code>chmod +x ulisp.js</code> 이다. 마지막 로그를 보면 알겠지만 우리 프로그램은 그냥 종료할 뿐이고 화면에 출력하는 시스템 콜은 없다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./ulisp.js <span style=color:#e6db74>&#39;(+ 3 (+ 2 1))&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>;
</span></span><span style=display:flex><span>run ./program and echo $? <span style=color:#66d9ef>for</span> output
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ file program <span style=color:#75715e># or use hexyl to see hex binary</span>
</span></span><span style=display:flex><span>program: Mach-O 64-bit executable x86_64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./program
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ echo $?
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p>이렇게 첫 포스트가 마무리 되었다. 이어지는 내용은 좀 더 그럴듯한 프로그램을 위해 함수를 선언하고 이를 사용하는 프로그램 코드를 컴파일하는 과정을 담고 있다.</p><h2 id=서브-루틴>서브 루틴<a href=#서브-루틴 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>보통 함수나 프로시져를 서브루틴의 일부로 본다. 서브루틴은 반복되는 코드를 재사용하기 위한 방법으로 반환하는 값이 있으면 보통 함수, 반환하는 값이 없는 경우는 프로시져로 불렸는데 지금은 크게 구분하여 사용하지 않는 편이다. 코드 반복이나 재사용을 위한 가장 중요한 역할을 한다. 이하 일반적으로 널리 사용되는 함수라는 표현을 사용하겠다.</p><blockquote><p>서브루틴은 코루틴과 함께 코드 흐름을 나타낸다.</p></blockquote><p>함수를 구성함에 있어 미리 알아두어야 할 것이 있다.</p><ol><li>값을 전달하는 방법은 이전에 살펴본 것과 같이 스택을 사용한다.</li><li>함수 수신자와 함수 호출자 사이의 규칙과 함수가 사용하는 변수(식별자)에 대한 생존 범위(Life-time)를 관리하고 정의해야 한다.</li></ol><p>함수 정의 구문은 아래와 같은 표현을 사용하기로 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>def</span> main ()
</span></span><span style=display:flex><span>     (+ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>))
</span></span></code></pre></div><p>이제 우리가 만드는 프로그래밍 언어는 <code>main</code> 함수를 사용하기로 약속하여 프로그램의 엔트리포인트entrypoint 라고 불리는 개념을 구현하기로 한다.</p><p>우리가 만든 S-expression 파서는 이 새로운 구문을 잘 파싱한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>program</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;(def main () (+ 1 2))&#39;</span>;
</span></span></code></pre></div><p><code>runner.js</code> 파일에 있는 프로그램 코드를 수정하여 파싱해 보자.</p><p>Phil 의 본문에 있는 node repl 에서 실행하는 방법도 유용하니 경험해 보도록 하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Welcome to Node.js v19.3.0.
</span></span><span style=display:flex><span>Type <span style=color:#e6db74>&#34;.help&#34;</span> <span style=color:#66d9ef>for</span> more information.
</span></span><span style=display:flex><span>&gt; const <span style=color:#f92672>{</span> parse <span style=color:#f92672>}</span> <span style=color:#f92672>=</span> require<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;./lib/parser&#39;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>undefined
</span></span><span style=display:flex><span>&gt; JSON.stringify<span style=color:#f92672>(</span>parse<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;(def main () (+ 1 2))&#39;</span><span style=color:#f92672>))</span>;
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;[[[&#34;def&#34;,&#34;main&#34;,[0],[&#34;+&#34;,1,2]]],&#34;&#34;]&#39;</span>
</span></span><span style=display:flex><span>&gt;
</span></span></code></pre></div><p>타입 정보가 다른게 있는지 &ldquo;main&rdquo; 뒤에 <code>[0]</code> 있는데 나중에 다시 점검해 보기로 한다.</p><p>파싱은 일단 되니 이 결과를 컴파일하는 코드를 보강해 보도록 한다.</p><p>우선 <code>def</code> 는 사용자가 정의하는 키워드가 아니고 이 언어 시스템의 고유한 키워드이다. 여기에서는 &ldquo;primitive&rdquo; 라고 부르고 있다.</p><p>이렇게 원시 함수를 모아두는 객체를 하나 만들어 둔다. 그리고 compile fn call 함수에서 원시primitive 함수를 따로 처리하는 기능을 추가할 것이다.</p><p>그 전에 인자가 없는 깡통 함수를 선언하고 있는 def main () 코드가 정상적으로 파싱 되도록 parser 를 수정해 보자.</p><p>문제는 여는 괄호가 블록을 시작하는 것도 있지만 인자를 선언하는 영역의 시작으로도 사용된다는 점이다. 우리의 기본 코드는 인자가 없는 상태로 제공되고 있고 이는 빈 expression 으로 반환되어야 한다.</p><p>Phil 의 저장소에 있는 코드를 참고하여 파서를 수정하자.</p><p>괄호를 닫는 과정에 저장된 토큰이 없는 경우에 대한 예외 처리를 추가해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;)&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// check for parameter section in function declaration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>currentToken</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>getToken</span>(<span style=color:#a6e22e>currentToken</span>));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>아직 어셈블리로 컴파일은 되지 않지만 파서의 테스트 케이스는 통과하게 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>  <span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#39;should parse def main function expression&#39;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;(def main () (+ 1 2))&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>expected</span> <span style=color:#f92672>=</span> [[[<span style=color:#e6db74>&#39;def&#39;</span>, <span style=color:#e6db74>&#39;main&#39;</span>, [], [<span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>]]], <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>source</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>expect</span>(<span style=color:#a6e22e>result</span>).<span style=color:#a6e22e>toEqual</span>(<span style=color:#a6e22e>expected</span>);
</span></span><span style=display:flex><span>  });
</span></span></code></pre></div><p>다음 포스트에 코드를 생성하며 함수 정의definition와 호출/피호출을 나타낼 때 자주 사용되는 caller/callee 를 통해 함수 호출 규칙을 살펴 보고, 식별자의 유효 범위를 제한하는 scope 에 대해 알아보기로 하자.</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://faultnote.github.io/assets/main.js></script>
<script src=https://faultnote.github.io/assets/prism.js></script>
<script src=https://faultnote.github.io/assets/languageSelector.js></script></div></body></html>