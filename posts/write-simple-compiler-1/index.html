<!doctype html><html lang=ko><head><title>Write Deadly Simple Compiler Part 1 :: FaultNote</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="내가 처음으로 구독한 개인 메일인 Phil 의 웹 페이지에 있는 2018년 말 포스트인 'Writing a lisp compiler from scratch in JavaScript' 를 학습하며 기록한 글이다."><meta name=keywords content="compiler,parser"><meta name=robots content="noodp"><link rel=canonical href=https://faultnote.github.io/posts/write-simple-compiler-1/><script async src="https://www.googletagmanager.com/gtag/js?id=G-6J40Z181KC"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6J40Z181KC",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://faultnote.github.io/assets/style.css><link rel=apple-touch-icon href=https://faultnote.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://faultnote.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="og:title" content="Write Deadly Simple Compiler Part 1"><meta property="og:description" content="내가 처음으로 구독한 개인 메일인 Phil 의 웹 페이지에 있는 2018년 말 포스트인 'Writing a lisp compiler from scratch in JavaScript' 를 학습하며 기록한 글이다."><meta property="og:url" content="https://faultnote.github.io/posts/write-simple-compiler-1/"><meta property="og:site_name" content="FaultNote"><meta property="og:image" content="https://faultnote.github.io/img/favicon/orange.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-11-19 22:00:00 +0900 +0900"></head><body class=orange><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>FaultNote</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>한국어 ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://faultnote.github.io/>한국어</a></li><li><a href=https://faultnote.github.io/en/>English</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><hr><li><a href=https://faultnote.github.io/>한국어</a></li><li><a href=https://faultnote.github.io/en/>English</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://faultnote.github.io/posts/write-simple-compiler-1/>Write Deadly Simple Compiler Part 1</a></h1><div class=post-meta><span class=post-date>2022-11-19
</span><span class=post-author>:: soomtong</span>
<span class=post-reading-time>:: 5 min read (2251 words)</span></div><span class=post-tags>#<a href=https://faultnote.github.io/tags/compiler/>compiler</a>&nbsp;
#<a href=https://faultnote.github.io/tags/s-expression/>s-expression</a>&nbsp;
#<a href=https://faultnote.github.io/tags/javascript/>javascript</a>&nbsp;</span><div class=post-content><div><blockquote><p>내가 처음으로 구독한 개인 메일인 <a href=https://notes.eatonphil.com>Phil</a> 의 웹 페이지에 있는 2018년 말 포스트인 &lsquo;Writing a lisp compiler from scratch in JavaScript&rsquo; 를 학습하며 기록한 글이다.</p></blockquote><p>우선 Node 환경에서 구동되는 Lisp 컴파일러를 구현하는 투토리얼을 따라가 보도록 한다. 본문은 여기에 있다.</p><ul><li><a href=https://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html>https://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html</a></li></ul><p>시리즈의 목표는 아래와 같은 코드를 계산하는 프로그램을 만드는 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(+ <span style=color:#ae81ff>1</span> (+ (<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>)))
</span></span></code></pre></div><p>이 과정에서 &lsquo;파싱&rsquo;, &lsquo;코드 생성&rsquo;, &lsquo;어셈블리 기본&rsquo;, &lsquo;시스템 콜&rsquo; 에 대한 내용을 다루지만 &lsquo;함수 정의&rsquo;, &lsquo;비 심볼/비 산술 데이터 타입&rsquo;, &lsquo;3개 이상의 인자 전달&rsquo;, &lsquo;예외 처리&rsquo;, &lsquo;에러 핸들링&rsquo; 등은 다루지 않는다.</p><h2 id=파싱>파싱<a href=#파싱 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>이 강의는 보통 lisp 계열의 프로그래밍 언어에서 사용되는 S-expression 문법을 처리하는 컴파일러를 만드는 것이다. S-expression(Symbolic expression)은 구조적인 데이터를 표현하는 방법 중 하나로 이 문법은 비교적 파싱하기 쉽기 때문에 각종 구문 트리를 표현하는 언어로 선택되곤 한다. 그래서 많은 파서들의 추상화 단계로 S-expression 을 사용한다. 이 내용에 대해서는 다른 포스트로 정리할 예정이다.</p><p>그리고, 우리의 프로그램은 기능이 제한적이기 때문에 렉싱lexing과 파싱parsing 단계를 나누지 않고 진행한다.</p><p>렉서와 파서를 통해 컴파일러를 만드는 것은 다음 기회에 살펴보자. 또는 파서와 렉서를 만들어 보는 시간을 가지는 것도 좋겠다.</p><blockquote><p>언어 문법을 디자인하고 파싱하고 렉싱하는 유명한 소프트웨어들이 있다. 해당 언어를 위한 파서를 만들어주는 프로그램도 있다. lex, yacc, bison, menhir, peg, antlr, lalrpop 등 본격적으로 언어를 만든다면 이런 툴을 사용하지 않을까?
<a href=https://en.wikipedia.org/wiki/Comparison_of_parser_generators>https://en.wikipedia.org/wiki/Comparison_of_parser_generators</a></p></blockquote><p>파서는 <code>구문 추상 트리abstract syntax tree</code> 를 만들어 낸다. 트리 구조는 중첩된 배열로 표현된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>(<span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> (<span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>)) <span style=color:#960050;background-color:#1e0010>→</span> [<span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#ae81ff>1</span>, [<span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]]
</span></span></code></pre></div><p>처음 이 과제를 자바스크립트가 아닌 다른/새로운 언어를 공부하면서 연습해 보면서 구현하려 했다. 하지만, 디자인도 안나왔는데 테스트 코드를 작성하는 것처럼 어색한게 진도가 나가지 않았다. 익숙한 언어로 먼저 진행해 보자.</p><ol><li>TypeScript</li><li>Grain</li><li>Zig</li></ol><p>정도 경험해 보면 어떨까 싶다.</p><p>먼저 parse 함수를 만들자. parse 함수는 아래의 형태를 가질 것이다. 타입 정보는 과정이 진행되면서 개선해 간다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parse</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>program</span>: <span style=color:#66d9ef>unknown</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>unknown</span>[] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tokens</span>: <span style=color:#66d9ef>unknown</span>[] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// todo: 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>소스 코드를 program 으로 받아 어떤 처리를 하여 AST(abstract syntax tree)를 얻어낸다. parse 함수는 처리가 성공하면 반환되는 결과의 두 번째 요소에 빈 문자열을 전달하는 것으로 규칙을 삼았다.</p><blockquote><p>그래도 왜 반환이 [tokens, &lsquo;&rsquo;] 인지 아직 모르겠다. 그냥 타입을 이렇게 작성한 거라면 나중에 바꾸도록 하자.</p></blockquote><p>공백이나 괄호를 만날 때까지 문자열을 더해 토큰을 만들어 추가하는 코드로 개선해 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parse</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>program</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>unknown</span>[] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tokens</span><span style=color:#f92672>:</span> (<span style=color:#66d9ef>string</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>number</span>)[] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>currentToken</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>char</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>program</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>char</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// todo:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;)&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// todo:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(Number.isFinite(<span style=color:#a6e22e>currentToken</span>) <span style=color:#f92672>?</span> Number(<span style=color:#a6e22e>currentToken</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>currentToken</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>char</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>계산을 위해 숫자인 경우는 연산 가능한 타입으로 변경해 주고 있다.</p><p>그 다음은 괄호를 만나게 되는 경우를 처리하자.</p><p>괄호를 열면 또 다시 파싱할 문자열이 들어있다. 즉, 재귀 가능한 구조라는 것이다. 여는 괄호 코드를 구현하기 전에 닫는 괄호를 먼저 구성하자.</p><p>단어를 읽다가 닫는 괄호를 만나면 여기까지 토큰을 저장하고 재귀 호출한 parse 함수에게 현재까지 모아둔 토큰과 이어서 처리해야할 남은 문자열을 반환한다.</p><p>남은 문자열 반환을 위해 substring 이 필요해 for of 대신 forEach 를 사용하기로 했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parse</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>program</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>unknown</span>[] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tokens</span><span style=color:#f92672>:</span> (<span style=color:#66d9ef>string</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>number</span>)[] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>currentToken</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>forEach</span>((<span style=color:#a6e22e>char</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>index</span>: <span style=color:#66d9ef>number</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>char</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// todo:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;)&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)];
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(Number.isFinite(<span style=color:#a6e22e>currentToken</span>) <span style=color:#f92672>?</span> Number(<span style=color:#a6e22e>currentToken</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>currentToken</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>char</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>이제 여는 괄호의 코드를 구성하자. 재귀 호출이 시작되는 구간이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parse</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>program</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span>[] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tokens</span><span style=color:#f92672>:</span> (<span style=color:#66d9ef>string</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>number</span>)[] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>currentToken</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Array.<span style=color:#66d9ef>from</span>(<span style=color:#a6e22e>program</span>).<span style=color:#a6e22e>forEach</span>((<span style=color:#a6e22e>char</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>index</span>: <span style=color:#66d9ef>number</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>char</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>parsedToken</span>, <span style=color:#a6e22e>rest</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>parsedToken</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;)&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)];
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(Number.isFinite(<span style=color:#a6e22e>currentToken</span>) <span style=color:#f92672>?</span> Number(<span style=color:#a6e22e>currentToken</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>currentToken</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>char</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>정상적으로 종료되는 경우 반환은 파싱된 토큰 뭉치와 빈 문자열인게 납득이 된다. 더 이상 파싱할 문자열이 없을 때에 해당되는 것이다.</p><p>대강 이 쯤 되니 spec 파일을 만들 수 있을 것 같다. 테스트 케이스를 만들고 타입 정보를 제대로 구성해 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>parse</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;./parser&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#39;Parse s-expression&#39;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#39;should parse basic expression&#39;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;(+ 3 (+ 1 2)&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>expected</span> <span style=color:#f92672>=</span> [[[<span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#ae81ff>3</span>, [<span style=color:#e6db74>&#39;+&#39;</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>]]], <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>source</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>expect</span>(<span style=color:#a6e22e>result</span>).<span style=color:#a6e22e>toEqual</span>(<span style=color:#a6e22e>expected</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>따로 분리한 타입 정보는 우선 이 정도로 구성되었다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Program</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Token</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Token</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ParsedTokens</span> <span style=color:#f92672>=</span> [<span style=color:#a6e22e>Token</span>, <span style=color:#a6e22e>Program</span>];
</span></span></code></pre></div><p>제대로 동작하지 않는 첫 파서는 아래와 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#66d9ef>type</span> { <span style=color:#a6e22e>Program</span>, <span style=color:#a6e22e>Token</span>, <span style=color:#a6e22e>ParsedTokens</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;./parser.type&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parse</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>program</span>: <span style=color:#66d9ef>Program</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>ParsedTokens</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tokens</span>: <span style=color:#66d9ef>Token</span>[] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>currentToken</span>: <span style=color:#66d9ef>Token</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// eslint-disable-next-line @typescript-eslint/ban-ts-comment
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// @ts-ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Array.<span style=color:#66d9ef>from</span>(<span style=color:#a6e22e>program</span>).<span style=color:#a6e22e>forEach</span>((<span style=color:#a6e22e>char</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>index</span>: <span style=color:#66d9ef>number</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>char</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>parsedToken</span>, <span style=color:#a6e22e>rest</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>parsedToken</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// reset rest and index?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;)&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(Number.isNaN(Number(<span style=color:#a6e22e>currentToken</span>)) <span style=color:#f92672>?</span> <span style=color:#a6e22e>currentToken</span> : <span style=color:#66d9ef>Number</span>(<span style=color:#a6e22e>currentToken</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)];
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(Number.isNaN(Number(<span style=color:#a6e22e>currentToken</span>)) <span style=color:#f92672>?</span> <span style=color:#a6e22e>currentToken</span> : <span style=color:#66d9ef>Number</span>(<span style=color:#a6e22e>currentToken</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>char</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>재귀 함수를 통해 처리된 다음 프로그램이 또 다시 파싱되어 배열이 필요 이상 중첩되는 결과를 만나게 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>console.dir
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span> <span style=color:#e6db74>&#39;+&#39;</span>, 3, <span style=color:#f92672>[</span> <span style=color:#e6db74>&#39;+&#39;</span>, 1, <span style=color:#ae81ff>2</span> <span style=color:#f92672>]</span>, <span style=color:#e6db74>&#39;+&#39;</span>, 1, <span style=color:#ae81ff>2</span> <span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;+&#39;</span>,
</span></span><span style=display:flex><span>    3,
</span></span><span style=display:flex><span>    <span style=color:#f92672>[</span> <span style=color:#e6db74>&#39;+&#39;</span>, 1, <span style=color:#ae81ff>2</span> <span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;+&#39;</span>,
</span></span><span style=display:flex><span>    1,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>재귀 함수를 통해 반환 된 나머지 프로그램 코드에 대해 다시 tokenize 를 할 필요가 없기 때문에 재귀 함수를 통해 처리된 토크을 제외한 나머지 프로그램만 이전 parse 단계를 가지도록 프로그램 문자열을 추려 낼 필요가 있게 되어 forEach 를 전통적인 인덱스를 가지는 for 문으로 변경해야 한다.</p><blockquote><p>파서는 문자열 커서를 앞으로 뒤로 이동하며 토큰을 생성해 내는데 재귀 함수를 통해 처리한 내용은 건너 뛰어야 하는 기능이 필요한 것이다.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>getToken</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>source</span>: <span style=color:#66d9ef>Program</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Token</span> <span style=color:#f92672>=&gt;</span> (Number.isNaN(Number(<span style=color:#a6e22e>source</span>)) <span style=color:#f92672>?</span> <span style=color:#a6e22e>source</span> : <span style=color:#66d9ef>Number</span>(<span style=color:#a6e22e>source</span>));
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>char</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>charAt</span>(<span style=color:#a6e22e>index</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>char</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>parsedToken</span>, <span style=color:#a6e22e>restProgram</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>parsedToken</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// reset program with skipped by recursive and index to 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>program</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>restProgram</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>index</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;)&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>getToken</span>(<span style=color:#a6e22e>currentToken</span>));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>tokens</span>, <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>index</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>tokens</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>getToken</span>(<span style=color:#a6e22e>currentToken</span>));
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>currentToken</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>char</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>파싱 함수 반복문을 Phil 의 코드에 맞게 수정하고 <code>npm t</code> 를 통해 테스트를 성공시켰다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; simple-compiler@0.1.0 test
</span></span><span style=display:flex><span>&gt; jest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> PASS  src/parser.spec.ts
</span></span><span style=display:flex><span>  Parse s-expression
</span></span><span style=display:flex><span>    ✓ should parse basic expression <span style=color:#f92672>(</span><span style=color:#ae81ff>2</span> ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Test Suites: <span style=color:#ae81ff>1</span> passed, <span style=color:#ae81ff>1</span> total
</span></span><span style=display:flex><span>Tests:       <span style=color:#ae81ff>1</span> passed, <span style=color:#ae81ff>1</span> total
</span></span><span style=display:flex><span>Snapshots:   <span style=color:#ae81ff>0</span> total
</span></span><span style=display:flex><span>Time:        1.161 s, estimated <span style=color:#ae81ff>2</span> s
</span></span><span style=display:flex><span>Ran all test suites.
</span></span></code></pre></div><p>이어 파싱된 데이터를 어셈블리로 변환하는 단계로 넘어가자.</p><p>어셈블리를 바이너리로 변환하는 것은 gcc 나 llvm 의 도움을 받는다.</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://faultnote.github.io/assets/main.js></script><script src=https://faultnote.github.io/assets/prism.js></script><script src=https://faultnote.github.io/assets/languageSelector.js></script></div></body></html>