<!doctype html><html lang=ko><head><title>TypeScript 50 Lessons Part 7 :: FaultNote</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="스매싱매거진의 타입스크립트 50 레슨 정리 7편"><meta name=keywords content="typescript,Stefan Baumgartner"><meta name=robots content="noodp"><link rel=canonical href=https://faultnote.github.io/posts/typescript-50-lessons-7/><script async src="https://www.googletagmanager.com/gtag/js?id=G-6J40Z181KC"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6J40Z181KC",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://faultnote.github.io/assets/style.css><link rel=apple-touch-icon href=https://faultnote.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://faultnote.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 50 Lessons Part 7"><meta property="og:description" content="스매싱매거진의 타입스크립트 50 레슨 정리 7편"><meta property="og:url" content="https://faultnote.github.io/posts/typescript-50-lessons-7/"><meta property="og:site_name" content="FaultNote"><meta property="og:image" content="https://faultnote.github.io/posts/images/cover-typescript-50-lessons.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-08-27 22:00:00 +0900 +0900"></head><body class=orange><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>FaultNote</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>한국어 ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://faultnote.github.io/>한국어</a></li><li><a href=https://faultnote.github.io/en/>English</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><hr><li><a href=https://faultnote.github.io/>한국어</a></li><li><a href=https://faultnote.github.io/en/>English</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://faultnote.github.io/posts/typescript-50-lessons-7/>TypeScript 50 Lessons Part 7</a></h1><div class=post-meta><span class=post-date>2022-08-27
</span><span class=post-author>:: soomtong</span>
<span class=post-reading-time>:: 9 min read (4389 words)</span></div><span class=post-tags>#<a href=https://faultnote.github.io/tags/typescript/>typescript</a>&nbsp;
#<a href=https://faultnote.github.io/tags/javascript/>javascript</a>&nbsp;
</span><img src=https://faultnote.github.io/posts/images/cover-typescript-50-lessons.png class=post-cover alt="TypeScript 50 Lessons Part 7" title="Cover Image"><div class=post-content><div><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>타입스크립트 in 50 레슨</h2><div id=outline-text-headline-1 class=outline-text-2><p><a href=https://fettblog.eu/>스테판 바움가트너</a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.</p><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Lesson 43</h3><div id=outline-text-headline-2 class=outline-text-3><pre class=example>
Promise 와 가변variadic 튜플 타입
</pre><p>새로운 기법을 활용해 callback 스타일의 코드를 promisify 하게 만들어 아래와 같은 동작을 기대하는 유틸리티 함수를 만들어보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>loadFile</span>(<span style=color:#a6e22e>fileName</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>cb</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>loadFilePromise</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>promisify</span>(<span style=color:#a6e22e>loadFile</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>loadFilePromise</span>(<span style=color:#e6db74>&#39;./chapter7.md&#39;</span>).<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>result</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>toUpperCase</span>())</span></span></code></pre></div></div><p>우리가 만들 함수는 여러 인자가 있지만 마지막 인자로 콜백 함수를 가지고 있어야 하고 promisified 된 함수를 반환한다. 함수 원형은 아래와 같다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>promisify</span>&lt;<span style=color:#f92672>Fun</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>FunctionWithCallback</span> &gt;(<span style=color:#a6e22e>fun</span>: <span style=color:#66d9ef>Fun</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>PromisifiedFunction</span>&lt;<span style=color:#f92672>Fun</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FunctionWithCallback</span> <span style=color:#f92672>=</span> ((<span style=color:#a6e22e>arg1</span>: <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>cb</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>)
</span></span><span style=display:flex><span>                          <span style=color:#f92672>|</span> ((<span style=color:#a6e22e>arg1</span>: <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>arg2</span>: <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>cb</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>)
</span></span><span style=display:flex><span>                          <span style=color:#f92672>|</span> ((<span style=color:#a6e22e>arg1</span>: <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>arg2</span>: <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>arg3</span>: <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>cb</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>)</span></span></code></pre></div></div><p>이렇게 Fun 을 extends 하여 사용하는 패턴에 익숙해져야 한다. 여기에 사용된 FunctionWithCallback 의 타입도 확인해보자. 콜백을 포함한 인자의 개수에 따라 union 연산을 하고 있다.
가변 튜플 타입을 사용하여 대응할 수 있다. 튜플은 다음과 같이 표현된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PersonProps</span> <span style=color:#f92672>=</span> [<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>number</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>age</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>PersonProps</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;Stefan&#39;</span>, <span style=color:#ae81ff>37</span>]</span></span></code></pre></div></div><p>이 방식을 적용하면 함수 선언은 이렇게 표현할 수 있게 된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hello</span>(...<span style=color:#a6e22e>args</span><span style=color:#f92672>:</span> [<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>string</span>])<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span></span></span></code></pre></div></div><p>가변 튜플 타입의 튜플은 가변이란 말처럼 아직 정의되지 않은 타입을 가지고 있다. 이런 특성을 활용하면 콜백 스타일의 함수 원형을 완벽하게 표현할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FunctionWithCallback</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>any</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt; <span style=color:#f92672>=</span> (...<span style=color:#a6e22e>t</span><span style=color:#f92672>:</span> [...<span style=color:#a6e22e>T</span>, (...<span style=color:#a6e22e>args</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span></span></span></code></pre></div></div><p>`t` 는 튜플이고 그 안에 가변 인자로 T[] 와 마지막 콜백 함수를 가지고 있다. 이 콜백 함수도 가변 인자 타입이 선언된 와일드카드 함수 타입이다. 여기에서 명확히 `any` 를 사용하고 있다. 의도된 any 타입이다. 이 함수는 헬퍼 함수이기 때문에 any 선언이 괜찮다.
이제 Promise 를 반환하는 타입을 선언하면 가변 튜플 타입 선언과 함께 아래와 같이 정리할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PromisifiedFunction</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> (...<span style=color:#a6e22e>args</span>: <span style=color:#66d9ef>InferArguments</span>&lt;<span style=color:#f92672>T</span>&gt;) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>InferResults</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>T</span>&gt;<span style=color:#f92672>&gt;</span></span></span></code></pre></div></div><p>Promisify 를 위해 마지막 콜백 함수를 제외한 인자를 따로 할 필요가 있다. 콜백을 제외한 가변 인자 타입을 InferArguments&lt;T> 로 선언하면 아래와 같다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InferArguments</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> (...<span style=color:#a6e22e>t</span><span style=color:#f92672>:</span> [...<span style=color:#66d9ef>infer</span> <span style=color:#a6e22e>A</span>, (...<span style=color:#a6e22e>args</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>A</span> : <span style=color:#66d9ef>never</span></span></span></code></pre></div></div><p>반환 타입은 Promise 안에서 사용되는 콜백 함수이기 때문에 같은 방식으로 InferResults&lt;T> 를 선언할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InferResults</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> (...<span style=color:#a6e22e>t</span><span style=color:#f92672>:</span> [...<span style=color:#66d9ef>infer</span> <span style=color:#a6e22e>A</span>, (<span style=color:#a6e22e>res</span>: <span style=color:#66d9ef>infer</span> <span style=color:#a6e22e>R</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>R</span> : <span style=color:#66d9ef>never</span></span></span></code></pre></div></div><p>promisify 에 대한 실제 구현을 살펴 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>promisify</span>&lt;<span style=color:#f92672>Fun</span> <span style=color:#a6e22e>extends</span> <span style=color:#960050;background-color:#1e0010>(</span><span style=color:#a6e22e>...args</span><span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#a6e22e>any</span><span style=color:#960050;background-color:#1e0010>[])</span> <span style=color:#960050;background-color:#1e0010>=</span>&gt; <span style=color:#66d9ef>any</span><span style=color:#f92672>&gt;</span>(<span style=color:#a6e22e>f</span>: <span style=color:#66d9ef>Fun</span>)<span style=color:#f92672>:</span> (...<span style=color:#a6e22e>args</span>: <span style=color:#66d9ef>InferArguments</span>&lt;<span style=color:#f92672>Fun</span>&gt;) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>InferResults</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>Fun</span>&gt;<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span> (...<span style=color:#a6e22e>args</span>: <span style=color:#66d9ef>InferArguments</span>&lt;<span style=color:#f92672>Fun</span>&gt;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Promise</span>((<span style=color:#a6e22e>resolve</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>InferResults</span>&lt;<span style=color:#f92672>Fun</span>&gt;) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>callback</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>null</span>, ...<span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>콜백을 포함한 promisify 할 함수 f 를 인자로 promisify 함수를 호출하면 infer arguement 를 통해 args 를 인자로 삼고 infer result 를 반환하는 함수를 반환한다. promisify 된 함수는 콜백 함수 이전의 args 를 인자로 받고 Promise 로 감싸진 callback 을 기존 콜백 함수 대신 마지막 인자로 전달하여 resolve 한다.</p></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Lesson 44</h3><div id=outline-text-headline-3 class=outline-text-3><pre class=example>
JSONify 클래스 디자인
</pre><p>infer 는 extends 와 함께 삼항 연산의 결과를 나중에 참조하기 위해 사용한다. T 는 일반 함수이고 함수의 반환 타입을 R 로 추론 가능하면 R 로 정의하고 그렇지 않으면 any 를 반환한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ReturnType</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#960050;background-color:#1e0010>(</span><span style=color:#a6e22e>...args</span><span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#a6e22e>any</span><span style=color:#960050;background-color:#1e0010>)</span> <span style=color:#960050;background-color:#1e0010>=</span>&gt; <span style=color:#66d9ef>any</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> (...<span style=color:#a6e22e>args</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>infer</span> <span style=color:#a6e22e>R</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>R</span> : <span style=color:#66d9ef>any</span></span></span></code></pre></div></div><p>T extends (…args: any) => infer R ? R : any
JSON 은 parse, stringify 로 이루어진 함수가 없고, undefined 가 없는 자바스크립트 객체 표현이다.
타입스크립트를 만든 Anders Hejlsberg 의 쇼케이스로 사용된 JSON 타입 제너릭 코드로 Serializer 를 구현하고 있다.
JSONify 타입은 기본 타입과 중첩된 배열이나 객체도 대응한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Serializer</span>&lt;<span style=color:#f92672>T</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>serialize</span>(<span style=color:#a6e22e>inp</span>: <span style=color:#66d9ef>T</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>inp</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>deserialize</span>(<span style=color:#a6e22e>inp</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>JSONified</span>&lt;<span style=color:#f92672>T</span>&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>inp</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>이에 추가로 toJSON 함수 타입을 가지고 있는데 전달되는 객체가 toJSON 함수를 가지고 있는 경우 JSON.stringify 의 결과를 사용하도록 대응할 것이다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Widget</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>toJSON</span>()<span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kind</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Widget&#34;</span>, <span style=color:#a6e22e>date</span>: <span style=color:#66d9ef>Date</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>JSONified 타입을 구성해 보자. toJSON 함수가 있는 경우를 구분하여 infer 를 통해 반환 타입을 구해 사용한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>JSONified</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSONifiedValue</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> { <span style=color:#a6e22e>toJSON</span><span style=color:#960050;background-color:#1e0010>():</span> <span style=color:#a6e22e>infer</span> <span style=color:#a6e22e>U</span> } <span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#a6e22e>U</span> <span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#a6e22e>T</span>&gt;;</span></span></code></pre></div></div><p>이제 각 값에 대한 타입 정의를 하고 있는 JSONifiedValue 타입을 살펴 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>JSONifiedValue</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>T</span> :
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>T</span> <span style=color:#66d9ef>extends</span> Function <span style=color:#f92672>?</span> <span style=color:#66d9ef>never</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> Array&lt;<span style=color:#f92672>infer</span> <span style=color:#a6e22e>U</span>&gt; <span style=color:#f92672>?</span> <span style=color:#a6e22e>JSONifiedArray</span>&lt;<span style=color:#f92672>U</span>&gt; <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>object</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>JSONifiedObject</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>:</span> <span style=color:#66d9ef>never</span>;</span></span></code></pre></div></div><p>원시 타입인 경우 해당 타입을 반환 한다. 함수인 경우 버린다. 배열 인 경우 배열 안에 있는 타입을 참조하는 JSONifiedArray 타입을 반환한다. 객체인 경우는 JSONifiedObject 타입을 반환한다. 객체 타입인 재귀 타입이 된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>JSONifiedObject</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> {[<span style=color:#a6e22e>P</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>T</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>JSONified</span>&lt;<span style=color:#f92672>T</span><span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>P</span><span style=color:#960050;background-color:#1e0010>]</span>&gt;}</span></span></code></pre></div></div><p>배열 타입인 경우, 배열의 요소가 undefined 값이 있는 경우 null 타입을 반환하도록 한다. 배열의 요소로 객체가 있을 수 있으니 여기에도 재귀 구문이 추가된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UndefinedAsNull</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>undefined</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>T</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>JSONifiedArray</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> Array&lt;<span style=color:#f92672>UndefinedAsNull</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>JSONified</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>T</span>&gt;<span style=color:#f92672>&gt;&gt;</span></span></span></code></pre></div></div><p>Serializer 클래스에 대한 타입 제약이 완성되었다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SomeItem</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>text</span>: <span style=color:#66d9ef>string</span>; <span style=color:#a6e22e>count</span>: <span style=color:#66d9ef>number</span>; <span style=color:#a6e22e>choice</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;yes&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;no&#34;</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>func</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>nested</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>isSaved</span>: <span style=color:#66d9ef>boolean</span>; <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> [<span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#ae81ff>2</span>]; <span style=color:#a6e22e>what</span><span style=color:#f92672>:</span> [<span style=color:#66d9ef>undefined</span>, <span style=color:#66d9ef>undefined</span>] }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>widget</span>: <span style=color:#66d9ef>Widget</span>; <span style=color:#a6e22e>children?</span>: <span style=color:#66d9ef>SomeItem</span>[];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>serializer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Serializer</span>&lt;<span style=color:#f92672>SomeItem</span>&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>serializer</span>.<span style=color:#a6e22e>serialize</span>(<span style=color:#a6e22e>it</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>o</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>serializer</span>.<span style=color:#a6e22e>deserialize</span>(<span style=color:#e6db74>&#39;&#39;</span>)</span></span></code></pre></div></div></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Lesson 45</h3><div id=outline-text-headline-4 class=outline-text-3><pre class=example>
복합 서비스 정의 타입 패턴
</pre><p>앤더스 헤일스버그의 다른 예제로 동적 타입 정의에 대한 내용을 살펴 보자. 아래와 같이 사용되는 객체가 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>serviceDefinition</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>open</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>filename</span>: <span style=color:#66d9ef>String</span> },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>insert</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>pos</span>: <span style=color:#66d9ef>Number</span>, <span style=color:#a6e22e>text</span>: <span style=color:#66d9ef>String</span> },
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>delete</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>pos</span>: <span style=color:#66d9ef>Number</span>, <span style=color:#a6e22e>len</span>: <span style=color:#66d9ef>Number</span> },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>close</span><span style=color:#f92672>:</span> {},
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>이 정의를 사용하는 createService 함수를 구현하기 위해 서비스를 정의한 내용과 이 요청을 처리하는 핸들러를 전달할 것이다.
반환되는 서비스는 open, insert 등 정의된 스펙에 따라 사용할 수 있다. createService 함수 원형을 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createService</span>&lt;<span style=color:#f92672>S</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ServiceDefinition</span>&gt;(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>serviceDefinition</span>: <span style=color:#66d9ef>S</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>handler</span>: <span style=color:#66d9ef>RequestHandler</span>&lt;<span style=color:#f92672>S</span>&gt;,
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>ServiceObject</span>&lt;<span style=color:#f92672>S</span>&gt;</span></span></code></pre></div></div><p>서비스 정의 타입은 간단히 아래와 같이 정의할 수 있다. 문자열을 키로 사용하는 객체 타입을 구성하고 키가 정의되는 과정에 타입이 narrow 된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ServiceDefinition</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  [<span style=color:#a6e22e>x</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>MethodDefinition</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MethodDefinition</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  [<span style=color:#a6e22e>x</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>StringConstructor</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>NumberConstructor</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>핸들러 타입을 정의해 보자. request 를 받은 핸들러의 실행을 완료하고 boolean 을 반환한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RequestHandler</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ServiceDefinition</span>&gt; <span style=color:#f92672>=</span> (<span style=color:#a6e22e>req</span>: <span style=color:#66d9ef>RequestObject</span>&lt;<span style=color:#f92672>T</span>&gt;) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>boolean</span>;</span></span></code></pre></div></div><p>RequestObject 타입은 서비스 정의에 따른다. RequestObject 는 아래처럼 정의된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RequestObject</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ServiceDefinition</span>&gt; <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  [<span style=color:#a6e22e>P</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>T</span>]<span style=color:#f92672>:</span> { <span style=color:#a6e22e>message</span>: <span style=color:#66d9ef>P</span>; <span style=color:#a6e22e>payload</span>: <span style=color:#66d9ef>RequestPayload</span>&lt;<span style=color:#f92672>T</span><span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>P</span><span style=color:#960050;background-color:#1e0010>]</span>&gt;; }
</span></span><span style=display:flex><span>}[<span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>T</span>];</span></span></code></pre></div></div><p>이렇게 정의된 request 객체는 다음과 같은 타입에 대한 상황을 만족한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>req</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;open&#34;</span>; <span style=color:#a6e22e>payload</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>filename</span>: <span style=color:#66d9ef>string</span>; } }
</span></span><span style=display:flex><span>     <span style=color:#f92672>|</span> { <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;insert&#34;</span>; <span style=color:#a6e22e>payload</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>pos</span>: <span style=color:#66d9ef>number</span>; <span style=color:#a6e22e>text</span>: <span style=color:#66d9ef>string</span>; } }
</span></span><span style=display:flex><span>     <span style=color:#f92672>|</span> { <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;delete&#34;</span>; <span style=color:#a6e22e>payload</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>pos</span>: <span style=color:#66d9ef>number</span>; <span style=color:#a6e22e>len</span>: <span style=color:#66d9ef>number</span>; } }
</span></span><span style=display:flex><span>     <span style=color:#f92672>|</span> { <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;close&#34;</span>; <span style=color:#a6e22e>payload</span>: <span style=color:#66d9ef>undefined</span>; }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>createService 함수가 반환하는 객체의 반환 타입도 정리해 보자. 문자열 키에 대한 ServiceMethod 제너릭 타입이다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ServiceObject</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ServiceDefinition</span>&gt; <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  [<span style=color:#a6e22e>P</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>T</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>ServiceMethod</span>&lt;<span style=color:#f92672>T</span><span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>P</span><span style=color:#960050;background-color:#1e0010>]</span>&gt;
</span></span><span style=display:flex><span>};</span></span></code></pre></div></div><p>각 서비스 메소드는 페이로드를 받아 실행 결과를 반환한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ServiceMethod</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MethodDefinition</span>&gt; <span style=color:#f92672>=</span> {} <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>T</span> <span style=color:#f92672>?</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>:</span> (<span style=color:#a6e22e>payload</span>: <span style=color:#66d9ef>RequestPayload</span>&lt;<span style=color:#f92672>T</span>&gt;) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>boolean</span>;</span></span></code></pre></div></div><p>페이로드는 RequestPayload 로 정의된 제너릭 타입이다. 서비스 정의에 사용된 자바스크립트 타입을 통해 생성자 타입을 구성할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RequestPayload</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MethodDefinition</span>&gt; <span style=color:#f92672>=</span> {} <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>T</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>undefined</span> <span style=color:#f92672>:</span> { [<span style=color:#a6e22e>P</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>T</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>TypeFromConstructor</span>&lt;<span style=color:#f92672>T</span><span style=color:#960050;background-color:#1e0010>[</span><span style=color:#a6e22e>P</span><span style=color:#960050;background-color:#1e0010>]</span>&gt; };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TypeFromConstructor</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>StringConstructor</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>NumberConstructor</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span>;</span></span></code></pre></div></div><p>실제 서비스 생성 함수를 구현하면 아래와 같다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createService</span>&lt;<span style=color:#f92672>S</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ServiceDefinition</span>&gt;(<span style=color:#a6e22e>serviceDefinitions</span>: <span style=color:#66d9ef>S</span>, <span style=color:#a6e22e>handler</span>: <span style=color:#66d9ef>RequestHandler</span>&lt;<span style=color:#f92672>S</span>&gt;,)<span style=color:#f92672>:</span> <span style=color:#a6e22e>ServiceObject</span>&lt;<span style=color:#f92672>S</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>service</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Function</span>&gt; <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>serviceDefinitions</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>service</span>[<span style=color:#a6e22e>name</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>payload</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>handler</span>({ <span style=color:#a6e22e>message</span>: <span style=color:#66d9ef>name</span>, <span style=color:#a6e22e>payload</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>service</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>ServiceObject</span>&lt;<span style=color:#f92672>S</span>&gt;;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>service</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createService</span>(<span style=color:#a6e22e>serviceDefinition</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>message</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;open&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;insert&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// do something or reach never
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>service</span>.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>service</span>.<span style=color:#a6e22e>open</span>({ <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;text.txt&#39;</span> });</span></span></code></pre></div></div><p>이렇게 타입 정보를 추가하여 흔히 사용하는 서비스 정의 패턴의 타입 안정성을 확보할 수 있다.</p></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>Lesson 46</h3><div id=outline-text-headline-5 class=outline-text-3><pre class=example>
DOM JSX 타입 엔진 만들기 1
</pre><p>JSX 는 템플릿 언어도 아니고 HTML 도 아니고 XML 도 아니다. JSX 의 실체는 함수 호출이다. `(element, properties, …children)` 로 보면 된다.</p><div class="src src-xml"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Button</span> <span style=color:#a6e22e>onClick=</span><span style=color:#e6db74>{()</span> <span style=color:#960050;background-color:#1e0010>=</span><span style=color:#f92672>&gt;</span> alert(&#39;YES&#39;)}&gt;Click me<span style=color:#f92672>&lt;/Button&gt;</span></span></span></code></pre></div></div><p>위 구문은 사실 아래로 변환 된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>createElement</span>(<span style=color:#a6e22e>Button</span>, { <span style=color:#a6e22e>onClick</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>alert</span>(<span style=color:#e6db74>&#39;YES&#39;</span>) }, <span style=color:#e6db74>&#39;Click me&#39;</span>);</span></span></code></pre></div></div><p>태그 문법이라 중첩 사용이 가능하다. 이는 재귀로 표현할 수 있다.</p><div class="src src-xml"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Button</span> <span style=color:#a6e22e>onClick=</span><span style=color:#e6db74>{()</span> <span style=color:#960050;background-color:#1e0010>=</span><span style=color:#f92672>&gt;</span> alert(&#39;YES&#39;)}&gt;<span style=color:#f92672>&lt;span&gt;</span>Click me<span style=color:#f92672>&lt;/span&gt;&lt;/Button&gt;</span></span></span></code></pre></div></div><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>createElement</span>(<span style=color:#a6e22e>Button</span>, { <span style=color:#a6e22e>onClick</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>alert</span>(<span style=color:#e6db74>&#39;YES&#39;</span>) }, <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;span&#39;</span>, {}, <span style=color:#e6db74>&#39;Click me&#39;</span>));</span></span></code></pre></div></div><p>대문자로 시작되는 요소는 컴포넌트로, 소문자로 시작되는 항목은 문자열로 변환되고 있다.
타입스크립트를 사용해 JSX 컴파일러를 만들어보자. 함수 원형은 아래와 같다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>factory</span>(<span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>properties</span>, ...<span style=color:#a6e22e>children</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><p>컴파일러 옵션을 추가한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;compilerOptions&#34;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;jsx&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;react&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;jsxFactory&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;DOMcreateElement&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;noImplicitAny&#34;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>팩토리 함수의 스펙을 살펴보자. element 가 함수이면 함수형 컴포넌트로 사용하고 properties 와 children 을 인자로 호출하여 결과를 얻어 낸다. element 가 문자열이면 일반 노드로 사용한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMcreateElement</span>(<span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>properties</span>, ...<span style=color:#a6e22e>children</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>element</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;function&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>element</span>({ ...<span style=color:#a6e22e>nonNull</span>(<span style=color:#a6e22e>properties</span>, {}), <span style=color:#a6e22e>children</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>DOMparseNode</span>(<span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>properties</span>, <span style=color:#a6e22e>children</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>nonNull</span>(<span style=color:#a6e22e>val</span>, <span style=color:#a6e22e>fallback</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Boolean(<span style=color:#a6e22e>val</span>) <span style=color:#f92672>?</span> <span style=color:#a6e22e>val</span> : <span style=color:#66d9ef>fallback</span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>일반 노드를 파싱하는 구문을 보자. children 을 처리하는 함수는 재귀 패턴을 사용하자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMparseNode</span>(<span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>properties</span>, <span style=color:#a6e22e>children</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>el</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>assign</span>(document.<span style=color:#a6e22e>createElement</span>(<span style=color:#a6e22e>element</span>), <span style=color:#a6e22e>properties</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>DOMparseChildren</span>(<span style=color:#a6e22e>children</span>).<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>child</span> <span style=color:#f92672>=&gt;</span> { <span style=color:#a6e22e>el</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>child</span>); });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>el</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMparseChildren</span>(<span style=color:#a6e22e>children</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>children</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>child</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;string&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> document.<span style=color:#a6e22e>createTextNode</span>(<span style=color:#a6e22e>child</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>child</span>;
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>앞으로 이어서 사용할 JSX 템플릿은 아래와 같다.</p><div class="src src-xml"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span>const Button = ({ msg }: { msg: string }) =&gt; {
</span></span><span style=display:flex><span>  return (
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;button</span> <span style=color:#a6e22e>onclick=</span><span style=color:#e6db74>{()</span> <span style=color:#960050;background-color:#1e0010>=</span><span style=color:#f92672>&gt;</span> alert(msg)}&gt;
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;strong&gt;</span>Click me<span style=color:#f92672>&lt;/strong&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/button&gt;</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const el = (
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;div&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;h1</span> <span style=color:#a6e22e>className=</span><span style=color:#e6db74>&#34;what&#34;</span><span style=color:#f92672>&gt;</span>Hello world<span style=color:#f92672>&lt;/h1&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;p&gt;</span>...<span style=color:#f92672>&lt;/p&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;Button</span> <span style=color:#a6e22e>msg=</span><span style=color:#e6db74>&#34;Yay&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;Button</span> <span style=color:#a6e22e>msg=</span><span style=color:#e6db74>&#34;Nay&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/div&gt;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>document.body.appendChild(el);</span></span></code></pre></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Lesson 47</h3><div id=outline-text-headline-6 class=outline-text-3><pre class=example>
DOM JSX 엔진 만들기 2
</pre><p>이제 타입 정보를 추가해보자. 이전의 nonNull 함수에 타입 정보를 추가하면 이렇게 된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>nonNull</span>&lt;<span style=color:#f92672>T</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>K</span>&gt;(<span style=color:#a6e22e>val</span>: <span style=color:#66d9ef>T</span>, <span style=color:#a6e22e>fallback</span>: <span style=color:#66d9ef>K</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Boolean(<span style=color:#a6e22e>val</span>) <span style=color:#f92672>?</span> <span style=color:#a6e22e>val</span> : <span style=color:#66d9ef>fallback</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>다음으로 DOMParseChildren 함수를 위해 타입을 추가하자. HTMLElement 는 가장 기본 클래스이다. 이 경우 string 과 Text 타입을 추가로 받을 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PossibleElements</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>HTMLElement</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Text</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMparseChildren</span>(<span style=color:#a6e22e>children</span>: <span style=color:#66d9ef>PossibleElements</span>[]) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Fun</span> <span style=color:#f92672>=</span> (...<span style=color:#a6e22e>args</span>: <span style=color:#66d9ef>any</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>any</span>;</span></span></code></pre></div></div><p>함수 타입 원형을 위해 Fun 타입도 정의해 두었다. HTML 의 모든 엘리먼트에 대한 태그 맵이 있다. HTMLElementTagNameMap 인터페이스가 브라우저 안에 정의되어 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AllElementsKeys</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>HTMLElementTagNameMap</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CreatedElement</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>AllElementsKeys</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>HTMLElementTagNameMap</span>[<span style=color:#a6e22e>T</span>] <span style=color:#f92672>:</span> <span style=color:#a6e22e>HTMLElement</span>;</span></span></code></pre></div></div><p>프로퍼티를 위한 타입 정의는 이렇게 가능하다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Props</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Fun</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>Parameters</span>&lt;<span style=color:#f92672>T</span>&gt;[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>:</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>Partial</span>&lt;<span style=color:#f92672>CreatedElement</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>T</span>&gt;<span style=color:#f92672>&gt;</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>never</span>;</span></span></code></pre></div></div><p>이제 DOMParseNode 함수 원형은 아래와 같이 구성할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMparseNode</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>string</span>&gt;(<span style=color:#a6e22e>element</span>: <span style=color:#66d9ef>T</span>, <span style=color:#a6e22e>properties</span>: <span style=color:#66d9ef>Props</span>&lt;<span style=color:#f92672>T</span>&gt;, <span style=color:#a6e22e>children</span>: <span style=color:#66d9ef>PossibleElements</span>[]) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><p>DOMCreateElement 함수 원형도 다음과 같다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMcreateElement</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>string</span>&gt;(<span style=color:#a6e22e>element</span>: <span style=color:#66d9ef>T</span>, <span style=color:#a6e22e>properties</span>: <span style=color:#66d9ef>Props</span>&lt;<span style=color:#f92672>T</span>&gt;, ...<span style=color:#a6e22e>children</span>: <span style=color:#66d9ef>PossibleElements</span>[])<span style=color:#f92672>:</span> <span style=color:#a6e22e>HTMLElement</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMcreateElement</span>&lt;<span style=color:#f92672>F</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>Fun</span>&gt;(<span style=color:#a6e22e>element</span>: <span style=color:#66d9ef>F</span>, <span style=color:#a6e22e>properties</span>: <span style=color:#66d9ef>Props</span>&lt;<span style=color:#f92672>F</span>&gt;, ...<span style=color:#a6e22e>children</span>: <span style=color:#66d9ef>PossibleElements</span>[])<span style=color:#f92672>:</span> <span style=color:#a6e22e>HTMLElement</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>DOMcreateElement</span>(<span style=color:#a6e22e>element</span>: <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>properties</span>: <span style=color:#66d9ef>any</span>, ...<span style=color:#a6e22e>children</span>: <span style=color:#66d9ef>PossibleElements</span>[])<span style=color:#f92672>:</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><p>이렇게 타입 정보가 제공되면 HTML 엘리먼트 코드 작업 때 자동 완성 등의 기능과 함께 타입 안전한 코드를 작성할 수 있다.</p></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Lesson 48</h3><div id=outline-text-headline-7 class=outline-text-3><pre class=example>
객체 타입 확장하기 1
</pre><p>타입스크립트의 컨트롤 플로우 분석은 타입 좁히기에 도움을 준다. 자주 사용되는 구문은 아래와 같을 것이다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>print</span>(<span style=color:#a6e22e>msg</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>msg</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;string&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>toUpperCase</span>()) <span style=color:#75715e>// We know msg is a string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>msg</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;number&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>toFixed</span>(<span style=color:#ae81ff>2</span>)) <span style=color:#75715e>// I know msg is a number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>객체에 대해서는 조금 더 복잡하게 타입을 확인하게 되는데 타입스크립트는 타입을 좁히지 못하는 상황이 온다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;object&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#39;prop&#39;</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>obj</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// It&#39;s safe to access obj.prop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>assert</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>prop</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;undefined&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// But TS doesn&#39;t know :-(
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;object&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#e6db74>&#39;prop&#39;</span>)) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// It&#39;s safe to access obj.prop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>assert</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>prop</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;undefined&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// But TS doesn&#39;t know :-(
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><p>hasOwnProperty 에 대해 타입 정보를 제공하여 이 문제를 해결해 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hasOwnProperty</span>&lt;<span style=color:#f92672>X</span> <span style=color:#a6e22e>extends</span> {}<span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Y</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyKey</span>&gt;(<span style=color:#a6e22e>obj</span>: <span style=color:#66d9ef>X</span>, <span style=color:#a6e22e>prop</span>: <span style=color:#66d9ef>Y</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>obj</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>X</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>Record</span>&lt;<span style=color:#f92672>Y</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>unknown</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#a6e22e>prop</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>X 는 객체에 대한 확장을 보장한다. 객체의 키로 위해 string, number, symbol 을 사용할 수 있는데 이를 위해 `PropertyKey` 타입이 제공된다.
obj: X 와 prop: Y 에 대한 타입을 확보하게 된다. 이 헬퍼 함수를 아래와 같이 사용하자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// person is an object
</span></span></span><span style=display:flex><span><span style=color:#75715e>// person = { } &amp; Record&lt;&#39;name&#39;, unknown&gt; = { } &amp; { name: &#39;unknown&#39;}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>person</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;object&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#a6e22e>person</span>, <span style=color:#e6db74>&#39;name&#39;</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;string&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Yes! name now exists in person
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Do something with person.name, which is a string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><p>또 다른 흔한 예제를 보자. 자바스크립트에서 자주 볼 수 있는 코드이다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Stefan&#39;</span>, <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>38</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>keys</span>(<span style=color:#a6e22e>obj</span>).<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>key</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>obj</span>[<span style=color:#a6e22e>key</span>])
</span></span><span style=display:flex><span>})</span></span></code></pre></div></div><p>타입스크립트는 key 에 대한 타입 정보를 얻을 수 없어 경고를 안내한다. Object.keys 는 여러 타입을 받을 수 있다. number 늘 받는 경우는 빈 배열을 반환한다. 문자열이나 배열을 담으면 숫자 인덱스를 가지는 배열을 반환한다. 객체를 전달 받는다면 이 객체에 사용된 키를 반환한다. 스펙을 알았으니 타입을 강제해 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ReturnKeys</span>&lt;<span style=color:#f92672>O</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>O</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>?</span> [] <span style=color:#f92672>:</span> <span style=color:#a6e22e>O</span> <span style=color:#66d9ef>extends</span> Array&lt;<span style=color:#f92672>any</span>&gt; <span style=color:#f92672>|</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>string</span>[] <span style=color:#f92672>:</span> <span style=color:#a6e22e>O</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>object</span> <span style=color:#f92672>?</span> Array&lt;<span style=color:#f92672>keyof</span> <span style=color:#a6e22e>O</span>&gt; <span style=color:#f92672>:</span> <span style=color:#66d9ef>never</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Extending the interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ObjectConstructor</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>keys</span>&lt;<span style=color:#f92672>O</span>&gt;(<span style=color:#a6e22e>obj</span>: <span style=color:#66d9ef>O</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>ReturnKeys</span>&lt;<span style=color:#f92672>O</span>&gt;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>ReturnKey&lt;T> 타입과 인터페이스 확장으로 Object.keys 메소드의 타입 제약을 강화할 수 있다.</p></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Lesson 49</h3><div id=outline-text-headline-8 class=outline-text-3><pre class=example>
객체 타입 확장하기 2
</pre><p>자바스크립트는 동적으로 객체를 생성할 수 있다. 특히 Object.defineProperty 를 통해 런타임에 확장이 가능하고 객체의 writable 속성을 조정하여 객체의 변경을 보호할 수 있다.
타입스크립트는 assets 키워드를 통해 타입 단정을 할 수 있다. 타입 단정을 통해 타입 좁히기 역할을 할 수 있다. 다음 예제를 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>assertIsNum</span>(<span style=color:#a6e22e>val</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>val</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#34;number&#34;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AssertionError</span>(<span style=color:#e6db74>&#34;Not a number!&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>multiply</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>assertIsNum</span>(<span style=color:#a6e22e>x</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>assertIsNum</span>(<span style=color:#a6e22e>y</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>y</span>; <span style=color:#75715e>// x, y 의 타입 정보가 없다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><p>assetIsNum 함수에 타입 단정문을 추가해보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>assertIsNum</span>(<span style=color:#a6e22e>val</span>: <span style=color:#66d9ef>any</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>asserts</span> <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>number</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>multiply</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>assertIsNum</span>(<span style=color:#a6e22e>x</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>assertIsNum</span>(<span style=color:#a6e22e>y</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>y</span>; <span style=color:#75715e>// Now also TypeScript knows that both x and y are numbers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div><p>이 개념을 Object.defineProperty 에도 적용해 볼 수 있다. defineProperty 헬퍼 함수 원형은 아래와 같다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>defineProperty</span>&lt;<span style=color:#f92672>Obj</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>object</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Key</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyKey</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>PDesc</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyDescriptor</span>&gt;
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>obj</span>: <span style=color:#66d9ef>Obj</span>, <span style=color:#a6e22e>prop</span>: <span style=color:#66d9ef>Key</span>, <span style=color:#a6e22e>val</span>: <span style=color:#66d9ef>PDesc</span>) {
</span></span><span style=display:flex><span>  Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>prop</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>PropertyKey 와 PropertyDescriptor 는 빌트인 타입이다. (obj, prop, val) 에 타입 단정을 추가해 보면 아래와 같은 모양이 될 것이다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>defineProperty</span>&lt;<span style=color:#f92672>Obj</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>object</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Key</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyKey</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>PDesc</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyDescriptor</span>&gt;
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>obj</span>: <span style=color:#66d9ef>Obj</span>, <span style=color:#a6e22e>prop</span>: <span style=color:#66d9ef>Key</span>, <span style=color:#a6e22e>val</span>: <span style=color:#66d9ef>PDesc</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>asserts</span> <span style=color:#a6e22e>obj</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>Obj</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>DefineProperty</span>&lt;<span style=color:#f92672>Key</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>PDesc</span>&gt; {
</span></span><span style=display:flex><span>  Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>prop</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>DefineProperty 타입과 이 타입이 사용하는 InferValue 제너릭 타입은 아래와 같이 정의할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DefineProperty</span>&lt;<span style=color:#f92672>Prop</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyKey</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Desc</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyDescriptor</span>&gt; <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Desc</span> <span style=color:#66d9ef>extends</span> { <span style=color:#a6e22e>writable</span>: <span style=color:#66d9ef>any</span>, <span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>val</span>: <span style=color:#66d9ef>any</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span> } <span style=color:#f92672>?</span> <span style=color:#66d9ef>never</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Desc</span> <span style=color:#66d9ef>extends</span> { <span style=color:#a6e22e>writable</span>: <span style=color:#66d9ef>any</span>, <span style=color:#66d9ef>get</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span> } <span style=color:#f92672>?</span> <span style=color:#66d9ef>never</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Desc</span> <span style=color:#66d9ef>extends</span> { <span style=color:#a6e22e>writable</span>: <span style=color:#66d9ef>false</span> } <span style=color:#f92672>?</span> <span style=color:#a6e22e>Readonly</span>&lt;<span style=color:#f92672>InferValue</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>Prop</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Desc</span>&gt;<span style=color:#f92672>&gt;</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Desc</span> <span style=color:#66d9ef>extends</span> { <span style=color:#a6e22e>writable</span>: <span style=color:#66d9ef>true</span> } <span style=color:#f92672>?</span> <span style=color:#a6e22e>InferValue</span>&lt;<span style=color:#f92672>Prop</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Desc</span>&gt; <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Readonly</span>&lt;<span style=color:#f92672>InferValue</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>Prop</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Desc</span>&gt;<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InferValue</span>&lt;<span style=color:#f92672>Prop</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>PropertyKey</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Desc</span>&gt; <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Desc</span> <span style=color:#66d9ef>extends</span> { <span style=color:#66d9ef>get</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>any</span> } <span style=color:#f92672>?</span> <span style=color:#66d9ef>never</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Desc</span> <span style=color:#66d9ef>extends</span> { <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>infer</span> <span style=color:#a6e22e>T</span> } <span style=color:#f92672>?</span> <span style=color:#a6e22e>Record</span>&lt;<span style=color:#f92672>Prop</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>T</span>&gt; <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Desc</span> <span style=color:#66d9ef>extends</span> { <span style=color:#66d9ef>get</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>infer</span> <span style=color:#a6e22e>T</span> } <span style=color:#f92672>?</span> <span style=color:#a6e22e>Record</span>&lt;<span style=color:#f92672>Prop</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>T</span>&gt; <span style=color:#f92672>:</span> <span style=color:#66d9ef>never</span>;</span></span></code></pre></div></div><p>이 작업을 객체 생성자에 적용해 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ObjectKeys</span>&lt;<span style=color:#f92672>T</span>&gt; <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>object</span> <span style=color:#f92672>?</span> (<span style=color:#66d9ef>keyof</span> <span style=color:#a6e22e>T</span>)[] <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>?</span> [] <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>extends</span> Array&lt;<span style=color:#f92672>any</span>&gt; <span style=color:#f92672>|</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>string</span>[] <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>never</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ObjectConstructor</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>keys</span>&lt;<span style=color:#f92672>T</span>&gt;(<span style=color:#a6e22e>o</span>: <span style=color:#66d9ef>T</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>ObjectKeys</span>&lt;<span style=color:#f92672>T</span>&gt;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>Object.defineProperty 대신 defineProperty 를 사용해 객체를 확장해 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>storage</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>currentValue</span>: <span style=color:#66d9ef>0</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>storage</span>, <span style=color:#e6db74>&#39;maxValue&#39;</span>, { <span style=color:#a6e22e>writable</span>: <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>9001</span> })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>maxValue</span> <span style=color:#75715e>// it&#39;s a number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>maxValue</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#75715e>// Error! It&#39;s read-only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>storageName</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;My Storage&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>storage</span>, <span style=color:#e6db74>&#39;name&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>get</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>storageName</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>name</span> <span style=color:#75715e>// it&#39;s a string!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// it&#39;s not possible to assing a value and a getter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>defineProperty</span>(<span style=color:#a6e22e>storage</span>, <span style=color:#e6db74>&#39;broken&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>get</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>storageName</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>4000</span>
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>storage</span> <span style=color:#75715e>// storage is never because we have a malicious property descriptor
</span></span></span></code></pre></div></div></div></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>Lesson 50</h3><div id=outline-text-headline-9 class=outline-text-3><pre class=example>
에필로그
</pre><p>마지막 레슨.
타입스크립트 팀에서 제공하는 정보에 귀를 기울이기. 깃헙에서 볼 수 있다. 로드맵, 다음 버전의 기능들 등. TC39 소식도 보자.
타입스크립트 핸드북을 계속 보자. Deno 와 Pika CDN 의 정보도 주시하자.
타입스크립트 위클리는 필수.
필자의 블로그도 계속 볼 것: <a href=https://fettblog.eu/>https://fettblog.eu/</a></p></div></div></div></div></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://faultnote.github.io/assets/main.js></script><script src=https://faultnote.github.io/assets/prism.js></script><script src=https://faultnote.github.io/assets/languageSelector.js></script></div></body></html>