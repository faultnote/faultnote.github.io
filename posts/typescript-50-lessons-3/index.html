<!doctype html><html lang=ko><head><title>TypeScript 50 Lessons Part 3 :: FaultNote</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="스매싱매거진의 타입스크립트 50 레슨 정리 3편"><meta name=keywords content="typescript,Stefan Baumgartner"><meta name=robots content="noodp"><link rel=canonical href=https://faultnote.github.io/posts/typescript-50-lessons-3/><script async src="https://www.googletagmanager.com/gtag/js?id=G-6J40Z181KC"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6J40Z181KC",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://faultnote.github.io/assets/style.css><link rel=apple-touch-icon href=https://faultnote.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://faultnote.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 50 Lessons Part 3"><meta property="og:description" content="스매싱매거진의 타입스크립트 50 레슨 정리 3편"><meta property="og:url" content="https://faultnote.github.io/posts/typescript-50-lessons-3/"><meta property="og:site_name" content="FaultNote"><meta property="og:image" content="https://faultnote.github.io/posts/images/cover-typescript-50-lessons.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-02-19 14:46:31 +0900 +0900"></head><body class=orange><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>FaultNote</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>한국어 ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://faultnote.github.io/>한국어</a></li><li><a href=https://faultnote.github.io/en/>English</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>소개</a></li><li><a href=/series>연재</a></li><li><a href=/blog>블로그</a></li><hr><li><a href=https://faultnote.github.io/>한국어</a></li><li><a href=https://faultnote.github.io/en/>English</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://faultnote.github.io/posts/typescript-50-lessons-3/>TypeScript 50 Lessons Part 3</a></h1><div class=post-meta><span class=post-date>2022-02-19
</span><span class=post-author>:: soomtong</span>
<span class=post-reading-time>:: 6 min read (2792 words)</span></div><span class=post-tags>#<a href=https://faultnote.github.io/tags/typescript/>typescript</a>&nbsp;
#<a href=https://faultnote.github.io/tags/javascript/>javascript</a>&nbsp;
</span><img src=https://faultnote.github.io/posts/images/cover-typescript-50-lessons.png class=post-cover alt="TypeScript 50 Lessons Part 3" title="Cover Image"><div class=post-content><div><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>타입스크립트 in 50 레슨</h2><div id=outline-text-headline-1 class=outline-text-2><p><a href=https://fettblog.eu/>스테판 바움가트너</a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.</p><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Lesson 15</h3><div id=outline-text-headline-2 class=outline-text-3><pre class=example>
타입스크립트는 값을 생성하는 영역과 타입을 생성하는 영역으로 구분, 함수는 값을 생성
</pre><p>함수는 선언부와 본문으로 구성된다. `declare` 키워드는 함수의 본문을 구현하지 않고 코드를 구성할 수 있게 해준다. 인자부와 반환부에 타입을 선언할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>query</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[])<span style=color:#f92672>:</span> <span style=color:#a6e22e>Result</span>[]</span></span></code></pre></div></div><p>실제 구현을 하게 되면 이 함수는 비동기로 작동하는데 데이터 fetch 를 위해 `fetch` 함수를 사용하기로 가정하면, 자바스크립트의 fetch 는 `Promise&lt;any>` 를 반환하기 때문에 이 값을 Result 타입으로 캐스팅하여 타입 세이프한 환경을 구성할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>query</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[]) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>`/search</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>queryString</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>response</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>json</span>() <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;)
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>`as` 키워드는 좌측의 값을 우측의 타입으로 처리한다. 함수 선언부에 반환 정보를 정의하는 것과 같은 역할을 한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>query</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[])<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>`/search</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>queryString</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>response</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>json</span>())
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>저자는 함수 선언부에 사용하는 것을 선호한다.</p></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Lesson 16</h3><div id=outline-text-headline-3 class=outline-text-3><pre class=example>
함수 인자의 콜백 함수에 타입을 정의하여 타입 시스템을 강화
</pre><p>`typeof` 연산을 함수에 적용하면 함수의 타입을 알 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SearchFn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>search</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SearchFn</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>query</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[] <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;</span></span></code></pre></div></div><p>함수 인자를 `Query` 라는 타입으로 정의해 보자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Query</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>query</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[],
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assemble</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>includeTags</span>: <span style=color:#66d9ef>boolean</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>'assemble' 인자는 함수 타입을 가지고 이 함수는 includeTags 를 받아서 string 을 반환하는 콜백 함수인 것을 알 수 있다. 물론 이렇게 개선할수도 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AssembleFn</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>includeTags</span>: <span style=color:#66d9ef>boolean</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Query</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>query</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[], <span style=color:#a6e22e>assemble</span>: <span style=color:#66d9ef>AssembleFn</span> }</span></span></code></pre></div></div><p>콜백 함수를 사용하는 코드는 특정 기능을 끼워넣을 수 있는 함수로 패턴화 된다.
브라우저의 특정 엘리먼트에서 값을 받아 다른 엘리먼트로 노출하는 함수를 정의한다면 아래와 같이 확장이 가능하다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>displaySearch</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inputId</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>outputId</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>search</span>: <span style=color:#66d9ef>SearchFn</span>
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span></span></span></code></pre></div></div><p>이 함수는 반환하는 값이 없다. (그냥 바깥 세상에 사이드이펙트만 발생시킨다.) `void` 는 lesson 17 에서 조금 더 알아본다.</p><p>`구조적 타입 시스템` 에서 함수 인자의 타입 정보는 이름에 제약되지 않고 인자의 전달 순서에 따라 제약된다. 아래 두 함수는 같은 타입 정보를 가진다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>testSearch</span>: <span style=color:#66d9ef>SearchFn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>query</span>, <span style=color:#a6e22e>tags</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Promise</span>.<span style=color:#a6e22e>resolve</span>([{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`The </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>query</span><span style=color:#e6db74>}</span><span style=color:#e6db74> test book`</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`/</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>query</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-design-patterns`</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>abstract</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`A practical book on </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>query</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    }])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>testSearch</span>: <span style=color:#66d9ef>SearchFn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>term</span>, <span style=color:#a6e22e>options</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Promise</span>.<span style=color:#a6e22e>resolve</span>([{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`The </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>term</span><span style=color:#e6db74>}</span><span style=color:#e6db74> test book`</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`/</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>term</span><span style=color:#e6db74>}</span><span style=color:#e6db74>-design-patterns`</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>abstract</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`A practical book on </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>term</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    }])
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>위 코드의 경우 'tags' 나 'options' 는 사용되지 않고 있다. 구조적 타입 시스템에서 이 두 번째 인자를 생략해도 타입 점검을 정상적으로 완료한다. 이어지는 레슨에서 이 타입들을 좀 더 다듬어 볼 예정이다.</p></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Lesson 17</h3><div id=outline-text-headline-4 class=outline-text-3><pre class=example>
대체가능성
</pre><p>이전 코드의 함수 본문에서 첫 번째 인자도 사용하지 않는다면 선언하지 않아도 된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>dummyContentSearchFn</span>: <span style=color:#66d9ef>SearchFn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Promise</span>.<span style=color:#a6e22e>resolve</span>([{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Form Design Patterns&#39;</span>, <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;/form-design-patterns&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>abstract</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;A practical book on accessible forms&#39;</span>
</span></span><span style=display:flex><span>    }])
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>자바스크립트에서 함수는 인자의 개수에 따라 주의해야할 케이스가 있다. 필요한 인자가 없는 경우와 인자가 너무 많은 경우인데 함수를 실행할 때 필요한 인자가 없는 경우 런타임에 실행 실패한다. 인자가 너무 많은 경우 초과된 인자 그냥 무시된다.
이런 오류들은 타입스크립트를 적용하면 사전 점검된다.</p><p>'SearchFn' 을 사용하는 displaySearch 함수의 인자로 콜백 함수를 전달하는데 SearchFn 의 모양을 가지면 사용할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>displaySearch</span>(<span style=color:#e6db74>&#39;input&#39;</span>, <span style=color:#e6db74>&#39;output&#39;</span>, <span style=color:#a6e22e>dummyContentSearchFn</span>)</span></span></code></pre></div></div><p>이를 대체 가능성이라 한다.</p><p>대체 가능성은 반환하는 값의 타입이 일치하면 이루어진다. 위 코드의 경우 두 콜백 함수 모두 배열 결과를 담은 promise 함수를 반환하고 있다.</p><p>타입스크립트의 `void` 는 다른 프로그래밍 언어에서 사용하는 void 와 조금 다르다.
자바스크립트의 모든 함수는 기본적으로 undefined 를 반환한다. 타입스크립트에서도 모든 함수는 반환 타입이 있다. 타입 추론이 어려울 경우 기본적으로 `void` 타입을 반환한다. void 타입의 하나의 값이 있는데 그 값은 'undefined' 이다.</p><p>void 타입은 모든 반환 타입에 대해 대체 가능하다. 콜백 함수가 void 반환인 경우 number 를 반환해도 타입 점검은 성공한다. 하지만 실제 반환되는 타입은 undefined 이기 때문에 다른 연산은 할 수 없다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>query</span>: <span style=color:#66d9ef>string</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>callback</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>results</span>: <span style=color:#66d9ef>Result</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[]) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>`/search</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>queryString</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>res</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>() <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>results</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>didItWork</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>results</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>didItWork</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>이 경우 didItWork 는 undefined 를 가지기 때문에 컴파일에 실패한다.
바닐라 자바스크립트에서도 void 를 사용하여 함수의 실행 결과를 undefined 시킬 수 있다.</p><p>함수의 반환 타입을 `void` 에서 `undefined` 로 변경하면 대체 가능성을 제거할 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>callback</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>results</span>: <span style=color:#66d9ef>Result</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>undefined</span>,</span></span></code></pre></div></div><p>그리고 옵셔널 파라미터는 가장 마지막에 전달하는게 관행이다.</p></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>Lesson 18</h3><div id=outline-text-headline-5 class=outline-text-3><pre class=example>
콜백 함수의 첫 인자에 명시적으로 this 를 추가하고 타입을 부여할 수 있다.
</pre><p>displaySearch 함수를 작성하는 과정에 this 를 사용하게 되는데 this.value 같은 경우 타입 추론이 실패하여 컴파일이 되지 않는다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>displaySearch</span>(<span style=color:#a6e22e>inputId</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>outputId</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>search</span>: <span style=color:#66d9ef>SearchFn</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#a6e22e>inputId</span>)<span style=color:#f92672>?</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;change&#39;</span>, <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>parentElement</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>classList</span>.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#39;active&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>searchTerm</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>DOM 엘리먼트도 타입스크립트를 위해 타입을 제공하고 있다. 타입을 좁혀 타입스크립트 컴파일러가 추론이 가능하도록 개선해 본다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>parentElement</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>classList</span>.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#39;active&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>HTMLInputElement</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>searchTerm</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>
</span></span><span style=display:flex><span>        }</span></span></code></pre></div></div><p>이어서 이 addEventListner 의 콜백을 별도의 함수로 분리하면 this 는 콜백 함수의 첫 번째 인자로 this 의 타입을 정의해 줄 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>inputChangeHandler</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>HTMLElement</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>parentElement</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>classList</span>.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#39;active&#39;</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>이 인자는 타입스크립트만을 위한 정보로 컴파일된 자바스크립트에는 사라지게된다.</p><div class="src src-javascript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>inputChangeHandler</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>parentElement</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>classList</span>.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#39;active&#39;</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>그리고 this 를 포함한 함수는 호출되는 컨텍스트에 따라 달라지기 때문에 this 를 HTMLElement 타입으로 추론할 수 없는 위치에서 호출하게 되면 컴파일 되지 않는다.</p></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Lesson 19</h3><div id=outline-text-headline-6 class=outline-text-3><pre class=example>
함수 타입의 추가 기능들
</pre><p>tagged template 함수는 함수 호출에 '(인자)' 대신 '`인자`' 를 사용한다. 태그드 템플릿은 템플릿 문자 배열과 대상이 되는 문자열 표현식으로 구분된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>taggedTemplate</span><span style=color:#e6db74>`템플릿A</span><span style=color:#e6db74>${</span><span style=color:#960050;background-color:#1e0010>표현식</span><span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74>템플릿B`</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>taggedTemplate</span><span style=color:#e6db74>`템플릿A</span><span style=color:#e6db74>${</span><span style=color:#960050;background-color:#1e0010>표현식</span><span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74>템플릿B</span><span style=color:#e6db74>${</span><span style=color:#960050;background-color:#1e0010>표현식</span><span style=color:#ae81ff>2</span><span style=color:#e6db74>}</span><span style=color:#e6db74>템플릿C`</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>taggedTemplate</span><span style=color:#e6db74>`템플릿A</span><span style=color:#e6db74>${</span><span style=color:#960050;background-color:#1e0010>표현식</span><span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74>템플릿B</span><span style=color:#e6db74>${</span><span style=color:#960050;background-color:#1e0010>표현식</span><span style=color:#ae81ff>2</span><span style=color:#e6db74>}</span><span style=color:#e6db74>템플릿C</span><span style=color:#e6db74>${</span><span style=color:#960050;background-color:#1e0010>표현식</span><span style=color:#ae81ff>3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>템플릿D`</span></span></span></code></pre></div></div><p>템플릿과 표현식은 배열로 처리되는데 표현식은 rest 연산자를 통해 표현된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>taggedTemplate</span>(<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>, ...<span style=color:#a6e22e>tags</span>: <span style=color:#66d9ef>string</span>[])<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;</span></span></code></pre></div></div><p>Promise 를 반환하는 경우 async 로 함수를 선언하고 await 를 통해 Promise 의 resolved 값을 받을 수 있다.</p></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Lesson 20</h3><div id=outline-text-headline-7 class=outline-text-3><pre class=example>
함수 오버로딩
</pre><p>타입스크립트는 함수 인자의 개수와 인자/반환 타입이 달라지는 경우를 위해 함수 오버로딩을 지원한다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[])<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>callback</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>results</span>: <span style=color:#66d9ef>Result</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[])<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span></span></span></code></pre></div></div><p>이 경우 실제 구현 형태는 이렇게 풀이된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>p2?</span>: <span style=color:#66d9ef>string</span>[] <span style=color:#f92672>|</span> ((<span style=color:#a6e22e>results</span>: <span style=color:#66d9ef>Result</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>), <span style=color:#a6e22e>p3?</span>: <span style=color:#66d9ef>string</span>[])</span></span></code></pre></div></div><p>처음으로 `|` 를 통한 유니언 타입이 소개되고 있다.
이 함수를 타입으로 등록하면 좀 더 나은 코드를 볼 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SearchOverload</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[] <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>callback</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>results</span>: <span style=color:#66d9ef>Result</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>, <span style=color:#a6e22e>tags?</span>: <span style=color:#66d9ef>string</span>[] <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>search</span>: <span style=color:#66d9ef>SearchOverload</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>p2?</span>: <span style=color:#66d9ef>string</span>[] <span style=color:#f92672>|</span> ((<span style=color:#a6e22e>results</span>: <span style=color:#66d9ef>Result</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>void</span>), <span style=color:#a6e22e>p3?</span>: <span style=color:#66d9ef>string</span>[]) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// body
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Lesson 21</h3><div id=outline-text-headline-8 class=outline-text-3><pre class=example>
제너레이터
</pre><p>제너레이터는 이터레이션을 구현하기 위해 시간의 흐름에 따라 값을 생성해 제공해 준다. 타입스크립트는 다양한 타입 정보를 제공하여 제너레이터 함수를 손쉽게 사용할 수 있도록 해준다.
제너레이터 함수의 반환 타입은 아래와 유사하다. async 함수가 반환하는 Promise 와 비교해 보면 도움이 될 것이다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>Generator</span>&lt;<span style=color:#f92672>1</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#a6e22e>2</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#a6e22e>3</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#a6e22e>4</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>string</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>unknown</span>&gt;</span></span></code></pre></div></div><p>제너레이터는 풀링이 필요한 시스템에서 유용하다. fetch 를 통해 데이터를 받도록 하자.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PollingResults</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>results</span>: <span style=color:#66d9ef>Result</span>[]; <span style=color:#a6e22e>done</span>: <span style=color:#66d9ef>boolean</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>polling</span>(<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>PollingResults</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/...&#39;</span>).<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>res</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>())
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>입력이 있을 때마다 백엔드에서 쿼리를 조회하는 제너레이터 함수는 이렇게 구성된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>getResults</span>(<span style=color:#a6e22e>term</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>AsyncGenerator</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[],</span> <span style=color:#a6e22e>void</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>unknown</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>state</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>polling</span>(<span style=color:#a6e22e>term</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>results</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>AsyncGenerator 타입은 타입스크립트의 시스템 인터페이스로 등록되어 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>resultsGen</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getResults</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#66d9ef>await</span>(<span style=color:#a6e22e>results</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>resultsGen</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>results</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>someFn</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>제너레이터는 이터레이터이기 때문에 `for … of` 대상이 된다.
yield 의 반환 값을 처리하기 위해 .next() 을 사용할 수 있다. `.next(value)` 를 통해 yield 의 반환 값을 받을 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>stop</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>polling</span>(<span style=color:#a6e22e>term</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stop</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>results</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>done</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>stop</span>)</span></span></code></pre></div></div><p>브라우저에서 입력된 값을 사용하는 제너레이터 호출 구문은 아래처럼 구성될 수 있다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;searchField&#39;</span>)<span style=color:#f92672>?</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;change&#39;</span>, <span style=color:#a6e22e>handleChange</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleChange</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>HTMLElement</span>, <span style=color:#a6e22e>ev</span>: <span style=color:#66d9ef>Event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>HTMLInputElement</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>resultsGen</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getResults</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>next</span>, <span style=color:#a6e22e>count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>resultsGen</span>.<span style=color:#a6e22e>next</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;undefined&#39;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>appendResultToAnswerArea</span>)
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>count</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>length</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><p>await 와 .next(isStop) 을 통해 비동기로 데이터를 요청하고 반환된 결과의 상태에 따라 응답읍 제공한다.
이 경우 AsynGenerator 의 타입은 이렇게 정의된다.</p><div class="src src-typescript"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>AsyncGenerator</span>&lt;<span style=color:#f92672>Result</span><span style=color:#960050;background-color:#1e0010>[],</span> <span style=color:#a6e22e>void</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>boolean</span>&gt;</span></span></code></pre></div></div></div></div></div></div></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://faultnote.github.io/assets/main.js></script><script src=https://faultnote.github.io/assets/prism.js></script><script src=https://faultnote.github.io/assets/languageSelector.js></script></div></body></html>