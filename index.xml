<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FaultNote</title><link>https://faultnote.github.io/</link><description>Recent content on FaultNote</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>soomtong@gmail.com (soomtong)</managingEditor><webMaster>soomtong@gmail.com (soomtong)</webMaster><lastBuildDate>Mon, 25 Dec 2023 10:00:00 +0900</lastBuildDate><atom:link href="https://faultnote.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Learning Zig</title><link>https://faultnote.github.io/posts/learning-zig/</link><pubDate>Mon, 25 Dec 2023 10:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/learning-zig/</guid><description>Learning Zig 문서를 공개해주셔서 감사합니다. 이 번역(일부 의역)은 개인적인 학습 목적으로 시작하였습니다. Learning Zig https://www.openmymind.net/learning_zig/ 위 문서를 보며 주요 내용을 정리합니다. Zig 프로그래</description><content>&lt;p>Learning Zig 문서를 공개해주셔서 감사합니다.
이 번역(일부 의역)은 개인적인 학습 목적으로 시작하였습니다.&lt;/p>
&lt;h2 id="learning-zig">Learning Zig&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://www.openmymind.net/learning_zig/">https://www.openmymind.net/learning_zig/&lt;/a>
위 문서를 보며 주요 내용을 정리합니다.&lt;/p>
&lt;/blockquote>
&lt;p>Zig 프로그래밍 언어에 대한 소개인 Zig 배우기에 오신 것을 환영합니다.
이 가이드는 Zig에 익숙해지는 것을 목표로 합니다. 독자는 특정 언어에 국한하지 않고 일반적인 프로그래밍 경험이 있다고 가정합니다.&lt;/p>
&lt;p>Zig는 현재 활발히 개발 중이며 Zig 언어와 표준 라이브러리(보통 std 라고 합니다) 모두 지속적으로 발전하고 있습니다.
이 가이드는 Zig의 최신 개발 버전을 대상으로 합니다. 그러나 일부 코드가 최신화되지 않을 수 있습니다.
최신 버전의 Zig를 다운로드한 후 일부 코드를 실행하는 데 문제가 있는 경우 알려주세요.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/karlseguin/blog/issues">https://github.com/karlseguin/blog/issues&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="zig-설치하기">Zig 설치하기&lt;/h2>
&lt;p>Zig의 다운로드 페이지에는 일반적인 플랫폼을 위해 미리 컴파일된 바이너리binary(실행파일)가 포함되어 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://ziglang.org/download/">https://ziglang.org/download/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>이 페이지에서는 최신 개발 릴리스와 주요 릴리스에 대한 바이너리를 찾을 수 있습니다.
이 가이드가 추적하는 최신 릴리스는 페이지 상단에서 찾을 수 있습니다.&lt;/p>
&lt;p>제 컴퓨터에서는 &lt;code>zig-macos-aarch64-0.12.0-dev.161+6a5463951.tar.xz&lt;/code> 를 다운로드하겠습니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] &lt;code>brew info zig&lt;/code> 를 통해 최신 릴리스를 확인할 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>다른 플랫폼이나 최신 릴리스를 사용하고 있을 수도 있습니다.
파일을 압축해제한 후에는 &lt;code>alias&lt;/code> 를 사용하거나 &lt;code>path&lt;/code> 경로에 &lt;code>zig&lt;/code> 바이너리(다른 것들과 함께)가 있어야 합니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 맥OS에서 brew 를 통해 설치하면 실행 경로에 자동으로 설치됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>이제 &lt;code>zig zen&lt;/code> 이나 &lt;code>zig version&lt;/code> 을 실행하여 zig를 사용할 준비가 되었는지 확인할 수 있습니다.&lt;/p>
&lt;h2 id="언어-개요---part-1">언어 개요 - Part 1&lt;/h2>
&lt;p>Zig는 강타입을 사용하는 컴파일 언어입니다.&lt;/p>
&lt;p>제네릭generic을 지원하고 강력한 컴파일 타임 메타프로그래밍 기능을 제공하며 가비지 컬렉터를 포함하지 않습니다.
많은 사람들이 Zig를 C의 최신 대안으로 간주합니다. 따라서 언어의 구문은 C와 유사합니다. 세미콜론으로 종결된 문과 중괄호로 구분된 블록을 사용합니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 프로그래밍 언어는 타입 시스템을 통해 견고한 프로그램을 작성하는 방향으로 발전하고, 다형성을 통해 유연하게 프로그램을 수정할 수 있도록 발전하고 있습니다. 특히 타입 시스템은 변수나 객체의 타입에 변경에 제약을 두어 프로그램의 안정성을 높이는 역할을 합니다.&lt;/p>
&lt;p>[!] 타입 시스템은 강타입과 약타입으로 구분합니다. 강타입은 자료를 표현하는 식별자의 타입이 암시적으로 변경되지 않는 것을 보장합니다. 그리고 항상 고유한 타입을 유지한다고 가정합니다. 반면 약타입은 변수의 타입이 변경되거나 모호한 경우를 가질 수 있습니다.&lt;/p>
&lt;p>[!] 타입 시스템의 또 다른 구분으로 정적 타입과 동적 타입 시스템이 있습니다. 정적 타입은 컴파일 시점에 타입을 검사합니다. 반면 동적 타입은 런타임에 타입을 검사합니다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/languages-of-type-system-aspect.png" alt="이미지">&lt;/p>
&lt;/blockquote>
&lt;p>Zig 코드는 다음과 같습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">std&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// This code won&amp;#39;t compile if `main` isn&amp;#39;t `pub` (public)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">pub&lt;/span> &lt;span style="color:#a6e22e">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">power&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">std&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;{s}&amp;#39;s power is {d}\n&amp;#34;&lt;/span>, .{&lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">power&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">power&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위의 내용을 learning.zig로 저장하고 zig run learning.zig를 실행하면 다음과 같은 내용을 확인할 수 있습니다.&lt;/p>
&lt;p>&lt;code>Goku's power is 9001.&lt;/code>&lt;/p>
&lt;p>이것은 지그를 처음 접하는 분들도 쉽게 따라할 수 있는 간단한 예제입니다. 그래도 한 줄 한 줄 살펴보도록 하겠습니다.&lt;/p>
&lt;h3 id="가져오기importing">가져오기Importing&lt;/h3>
&lt;p>표준 라이브러리나 외부 라이브러리 없이 단일 파일로 작성되는 프로그램은 거의 없습니다.
첫 번째 프로그램도 예외는 아니어서 Zig의 표준 라이브러리를 사용하여 출력을 인쇄합니다.
Zig의 가져오기 시스템은 간단하며 &lt;code>@import&lt;/code> 함수와 &lt;code>pub&lt;/code> 키워드를 사용합니다(현재 파일 외부에서 코드에 액세스할 수 있도록 하기 위해).&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>@&lt;/code> 로 시작하는 함수는 zig의 내장 함수입니다. 이러한 함수는 표준 라이브러리가 아닌 zig 컴파일러에서 제공합니다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!] 컴퓨터 프로그램을 만드는 것은 소스코드를 컴퓨터가 이해하는 기계어(머신 코드)로 변경하는 작업이라 볼 수 있습니다. 이 소스코드는 프로그래머가 만드는 것과 프로그래머에게 제공되는 것들을 조합하여 구성됩니다. 마치 레고 블럭을 사용하는 것과 유사합니다. 프로그래머에게 제공되는 코드 중 컴파일러가 컴파일 과정에 직접 끼워 넣는 것도 있고, 자주 유용하게 사용되는 것들을 표준 코드로 모아둔 것도 있고, 추가로 유료나 무료의 소스코드를 설치하여 사용하는 경우도 있습니다.&lt;/p>
&lt;p>이는 작은 블럭을 통해 여러 곳에 응용할 수 있는 코드 블럭을 만들어 재사용하는 것과 유사합니다. 이런 코드 블럭을 라이브러리라고 흔히 표현합니다. 라이브러리는 표준 라이브러리와 서드파티 라이브러리로 구분하여 부르기도 합니다.&lt;/p>
&lt;/blockquote>
&lt;p>모듈 이름을 지정하여 모듈을 가져옵니다. Zig의 표준 라이브러리는 &amp;ldquo;std&amp;quot;라는 이름을 사용하여 사용할 수 있습니다.
특정 파일을 가져오려면 가져오려는 파일에 상대적인 경로를 사용합니다.
예를 들어 User 구조체struct를 별도의 파일(예: models/user.zig)로 이동한 경우입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// models/user.zig
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">power&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그런 다음 다음을 통해 가져옵니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// main.zig
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;models/user.zig&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">User&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>User 구조체가 pub으로 표시되지 않은 경우 다음과 같은 오류가 발생합니다. &lt;code>'User' is not marked 'pub'.&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>models/user.zig는 두 개 이상의 항목을 내보낼 수 있습니다. 예를 들어 상수를 내보낼 수도 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// models/user.zig
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">MAX_POWER&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100_000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">power&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 경우 둘 다 가져올 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;models/user.zig&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">User&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">MAX_POWER&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">user&lt;/span>.&lt;span style="color:#a6e22e">MAX_POWER&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 시점에서 답변보다 질문이 더 많을 수 있습니다.
위의 코드 조각에서 user는 무엇일까요? 아직 보지 못했지만 const 대신 var를 사용하면 어떨까요?
또는 서드파티 라이브러리를 어떻게 사용하는지 궁금할 수도 있습니다.
모두 좋은 질문이지만, 이 질문에 답하기 위해서는 먼저 Zig에 대해 자세히 알아볼 필요가 있습니다.
지금은 Zig의 표준 라이브러리를 가져오는 방법, 다른 파일을 가져오는 방법, 정의를 내보내는 방법 등 지금까지 배운 내용으로 만족해야 할 것입니다.&lt;/p>
&lt;h3 id="주석comments">주석Comments&lt;/h3>
&lt;p>다음 줄은 Zig 예제의 주석입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// This code won&amp;#39;t compile if `main` isn&amp;#39;t `pub` (public)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Zig에는 C 계열의 언어에서 사용하는 &lt;code>/* ... */&lt;/code> 와 같은 여러 줄 주석문이 없습니다.&lt;/p>
&lt;p>코드와 문서의 유기적 관리를 위해 주석에 기반한 자동 문서 생성 기능을 실험적으로 지원하고 있습니다.
Zig의 &lt;a href="https://ziglang.org/documentation/master/std">표준 라이브러리 문서&lt;/a>를 보셨다면 이 기능이 실제로 작동하는 것을 보셨을 것입니다. &lt;code>//!&lt;/code> 는 최상위 문서 주석으로 알려져 있으며 파일 상단에 배치할 수 있습니다. 문서 주석으로 알려진 삼중 슬래시 주석(&lt;code>///&lt;/code>)은 함수 선언 앞과 같은 특정 위치에 넣을 수 있습니다.
두 가지 유형의 문서 주석을 잘못된 위치에 사용하려고 하면 컴파일러 오류가 발생합니다.&lt;/p>
&lt;h3 id="함수functions">함수Functions&lt;/h3>
&lt;p>다음 줄은 &lt;code>main&lt;/code> 함수의 시작입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>모든 실행 파일에는 프로그램의 진입점인 &lt;code>main&lt;/code> 이라는 함수가 필요합니다. &lt;code>main&lt;/code> 의 이름을 &lt;code>doIt&lt;/code> 과 같은 다른 이름으로 바꾸고 &lt;code>zig run learning.zig&lt;/code> 를 실행하려고 하면 &amp;rsquo;learning&amp;rsquo; 에 &amp;lsquo;main&amp;rsquo; 이라는 멤버가 없다는 오류가 발생합니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 이런 최초 진입 위치를 &lt;code>entry point&lt;/code> 라고 합니다.&lt;/p>
&lt;/blockquote>
&lt;p>위 코드는 프로그램의 시작점으로서 &lt;code>main&lt;/code> 의 특별한 역할을 무시하고, 아무런 매개변수를 받지 않고 아무것도 반환하지 않는, 즉 &lt;code>void&lt;/code> 를 반환하는 매우 기본적인 함수입니다. 다음은 조금 더 흥미로울 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> add(&lt;span style="color:#ae81ff">8999&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;8999 + 2 = {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{sum});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> add(a&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>, b&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>) &lt;span style="color:#66d9ef">i64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C와 C++ 프로그래머라면 Zig에는 선행하는 함수 선언이 필요하지 않다는 것, 즉 코드 순서상 &lt;code>add&lt;/code> 가 정의되기 전에 호출된다는 것을 알 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 특정 프로그래밍 언어는 함수가 사용되기 전에 선언되어야 합니다. 이를 &lt;code>forward declaration&lt;/code> 이라고 합니다.&lt;/p>
&lt;/blockquote>
&lt;p>다음으로 주목해야 할 것은 64비트 부호 있는 정수인 &lt;code>i64&lt;/code> 유형입니다. 다른 숫자 유형으로는 &lt;code>u8&lt;/code>, &lt;code>i8&lt;/code>, &lt;code>u16&lt;/code>, &lt;code>i16&lt;/code>, &lt;code>u32&lt;/code>, &lt;code>i32&lt;/code>, &lt;code>u47&lt;/code>, &lt;code>i47&lt;/code>, &lt;code>u64&lt;/code>, &lt;code>i64&lt;/code>, &lt;code>f32&lt;/code> 및 &lt;code>f64&lt;/code>가 있습니다.&lt;/p>
&lt;p>&lt;code>u47&lt;/code>과 &lt;code>i47&lt;/code>은 당신이 아직 깨어 있는지 확인하기 위한 테스트가 아닙니다; Zig는 임의의 비트 폭 정수를 지원합니다. 자주 사용하지는 않겠지만 유용하게 사용할 수 있습니다.
자주 사용하는 유형 중 하나는 부호 없는 포인터 크기의 정수이며 일반적으로 어떤 것의 길이/크기를 나타내는 유형인 &lt;code>usize&lt;/code> 입니다.&lt;/p>
&lt;blockquote>
&lt;p>Zig는 &lt;code>f32&lt;/code>와 &lt;code>f64&lt;/code> 외에도 &lt;code>f16&lt;/code>, &lt;code>f80&lt;/code>, &lt;code>f128&lt;/code> 부동소수점 유형도 지원합니다.&lt;/p>
&lt;/blockquote>
&lt;p>그렇게 해야 할 좋은 이유는 없지만, 다음과 같이 &lt;code>add&lt;/code> 구현을 변경하면:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> add(a&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>, b&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>) &lt;span style="color:#66d9ef">i64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">+=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>a += b;: cannot assign to constant.&lt;/code>-상수에 할당할 수 없습니다-라는 에러가 발생합니다.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-log" data-lang="log">&amp;lt;source&amp;gt;:9:7: error: cannot assign to constant
a += b;
~~^~~~
referenced by:
main: &amp;lt;source&amp;gt;:4:14
&lt;/code>&lt;/pre>&lt;p>함수의 매개변수는 상수라는 점은 나중에 더 자세히 살펴볼 중요한 교훈입니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 상수는 보통 정해진 데이터를 의미합니다. 상수를 담은 변수는 보통 변경이 불가능합니다. zig 는 함수의 매개변수에 다시 할당을 할 수 없다는 것입니다.
[!] 이는 프로그래밍 언어마다 다른 철학과 정책을 가지고 있습니다. 특별한 목적이나 언어가 만들어질 당시의 요구사항에 따라 다른 방식으로 사용되기도 합니다. 여러 방식을 지원하는 언어도 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>가독성을 높이기 위해, 함수 오버로딩(overloding; 동일한 함수에 다른 매개변수 유형 및/또는 개수에 따라)은 없습니다. 현재로서는 함수에 대해 알아야 할 모든 것이 여기까지입니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 함수 오버로딩은 같은 이름의 함수를 다양한 유형으로 사용하기 위해 제공되는 방법으로, 프로그래밍 언어의 Polymorph 주제에 해당합니다. 프로그래밍 언어들은 폴리모피즘을 구현하기 위해 오버로딩overloding, 인터페이스interface, 제너릭generic 등의 방법을 제공합니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="구조체structures">구조체Structures&lt;/h3>
&lt;p>다음 코드 줄은 스니펫의 끝에 정의된 타입인 User를 생성하는 것입니다. User의 정의는 다음과 같습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>우리 프로그램은 단일 파일이므로 &lt;code>User&lt;/code> 가 정의된 파일에서만 사용되므로 이를 공개용으로 변경할 필요는 없습니다. 하지만 그렇게 했다면 이 구조체 선언을 다른 파일에 노출하는 방법을 알지 못했을 것입니다.&lt;/p>
&lt;/blockquote>
&lt;p>구조체 필드는 쉼표로 끝나고 기본값을 지정할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>구조체를 생성할 때 &lt;strong>모든&lt;/strong> 필드를 설정해야 합니다.
예를 들어(아래 코드처럼), 기본값이 없는 &lt;code>power&lt;/code> 가 있는 선언 코드서를 사용할 때 다음과 같은 오류가 발생합니다: &lt;em>missing struct field: power&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{.name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>}; &lt;span style="color:#75715e">// no power assigned
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만, 기본값을 사용하면 위와 같은 컴파일이 정상적으로 수행됩니다.&lt;/p>
&lt;p>구조체는 메서드를 가질 수 있고, 선언(다른 구조체 포함)을 포함할 수 있으며, 심지어 아무런 필드를 선언하지 않고 사용할 수 있는데, 이 경우 네임스페이스처럼 작동합니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 흔히 모듈이나 클래스를 선언해 사용하는 경우처럼 구조체도 필드나 메소드를 묶는 namespace 역할을 할 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> SUPER_POWER &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9000&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> diagnose(user&lt;span style="color:#f92672">:&lt;/span> User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (user.power &lt;span style="color:#f92672">&amp;gt;=&lt;/span> SUPER_POWER) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;it&amp;#39;s over {d}!!!&amp;#34;&lt;/span>, .{SUPER_POWER});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!] 구조체의 필드는 &lt;code>,&lt;/code> 로 끝나야 합니다. &lt;code>;&lt;/code> 로 끝나면 컴파일 에러가 발생합니다.&lt;/p>
&lt;/blockquote>
&lt;p>메서드는 점 구문으로 호출할 수 있는 일반 함수일 뿐입니다. 이 두 가지 모두 작동합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// call diagnose on user
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>user.diagnose();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// The above is syntactical sugar for:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>User.diagnose(user);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>대부분의 경우 점 구문을 사용하지만 때로는 일반 함수보다 편의 구문 방법이 유용할 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>if&lt;/code> 문은 우리가 처음 본 제어 흐름입니다. 꽤 간단하지 않나요? 다음 파트에서 이에 대해 더 자세히 살펴보겠습니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>diagnose&lt;/code> 는 &lt;code>User&lt;/code> 구조체 안에 정의되며 첫 번째 파라미터로 &lt;code>User&lt;/code> 타입 변수를 받습니다. 따라서 점 구문을 사용하여 호출할 수 있습니다. 하지만 구조체 내의 함수들는 이 패턴을 따를 필요가 없습니다. 한 가지 일반적인 예로 구조체를 초기화하는 &lt;code>init&lt;/code> 함수를 들 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> init(name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>, power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>) User {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> power,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!] 구조체에 종속되어 구조체의 데이터를 사용하는 함수를 메소드라고 부르기도 합니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>init&lt;/code> 을 사용하는 것은 단지 관례일 뿐이며 경우에 따라 &lt;code>open&lt;/code> 또는 다른 이름이 더 적합할 수도 있습니다. 저처럼 C++ 프로그래머가 아니라면 필드를 초기화하는 문법, &lt;code>.필드이름 = 필드값&lt;/code> 이 조금 이상할 수 있지만 금방 익숙해질 것입니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 구조체의 필드 이름 앞에 &lt;code>.&lt;/code> 을 붙이는 표현법에 대한 내용입니다.&lt;/p>
&lt;/blockquote>
&lt;p>&amp;ldquo;Goku&amp;quot;를 생성할 때 &lt;code>user&lt;/code> 변수를 &lt;code>const&lt;/code> 로 선언했습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, &lt;code>user&lt;/code> 의 내용은 수정할 수 없습니다. 이 변수를 수정하려면 &lt;code>var&lt;/code> 를 사용하여 선언해야 합니다. 또한 변수에 할당된 내용에 따라 user 의 타입이 추론된다는 것을 눈치채셨을 것입니다. 이는 명시적으로 선언할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> user&lt;span style="color:#f92672">:&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!] 컴파일러에 따라 명시적으로 타입을 지정하면 컴파일러가 타입을 추론하는 시간을 줄일 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>변수의 타입을 명시해야 하는 경우도 있지만, 대부분의 경우 명시적 유형이 없는 코드가 더 가독성이 높습니다. 유형 추론은 다른 방식으로도 작동합니다. 위의 두 스니펫 모두에 해당합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> user&lt;span style="color:#f92672">:&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그래도 이 사용법은 매우 드문 경우입니다. 대신 함수에서 구조체를 반환할 때 더 자주 사용됩니다. 여기서도 타입은 함수의 반환 유형에서 유추할 수 있습니다. &lt;code>init&lt;/code> 함수는 다음과 같이 작성될 가능성이 높습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> init(name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>, power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>) User {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// instead of return User{...}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> power,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>지금까지 살펴본 대부분의 것들과 마찬가지로, 앞으로 언어의 다른 부분에 대해 이야기할 때 구조체를 다시 살펴볼 것입니다. 하지만 대부분의 경우 이들은 직관적입니다.&lt;/p>
&lt;h3 id="배열과-슬라이스arrays-and-slices">배열과 슬라이스Arrays and Slices&lt;/h3>
&lt;p>이전 코드의 마지막 줄을 간략히 설명할 수도 있지만, 이 스니핏에 &amp;ldquo;Goku&amp;quot;와 &amp;ldquo;{s}&amp;rsquo;s power is {d}\n&amp;quot;이라는 두 개의 문자열이 포함되어 있으므로 Zig의 문자열에 대해 궁금할 것입니다. 문자열을 더 잘 이해하기 위해 먼저 배열과 슬라이스를 살펴보겠습니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 스니핏snippet은 코드 조각을 의미합니다.&lt;/p>
&lt;/blockquote>
&lt;p>배열은 컴파일 시점에 정해진 길이로 고정된 크기를 가집니다. 길이는 타입의 일부이므로 부호 있는 정수 4개로 구성된 배열인 &lt;code>[4]i32&lt;/code>는 부호 있는 정수 5개로 구성된 배열인 &lt;code>[5]i32&lt;/code>와 다른 타입입니다.&lt;/p>
&lt;p>배열 길이는 초기화 과정에서 유추할 수 있습니다. 다음 코드에서 세 변수는 모두 &lt;code>[5]i32&lt;/code> 타입입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">5&lt;/span>]&lt;span style="color:#66d9ef">i32&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// we already saw this .{...} syntax with structs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// it works with arrays too
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> b&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">5&lt;/span>]&lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#f92672">=&lt;/span> .{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// use _ to let the compiler infer the length
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> [_]&lt;span style="color:#66d9ef">i32&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>반면에 슬라이스는 길이가 있는 배열에 대한 포인터입니다. 길이는 런타임에 알 수 있습니다. 포인터에 대해서는 뒷부분에서 다루겠지만 슬라이스는 배열에 대한 일종의 뷰view라고 생각하면 됩니다.&lt;/p>
&lt;blockquote>
&lt;p>Go에 익숙하다면 Zig에서 슬라이스는 용량이 &lt;strong>없고&lt;/strong> 포인터와 길이만 있다는 점이 조금 다르다는 것을 눈치채셨을 것입니다.&lt;/p>
&lt;/blockquote>
&lt;p>다음 코드를 보시면,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [_]&lt;span style="color:#66d9ef">i32&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>..&lt;span style="color:#ae81ff">4&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>저는 &lt;code>b&lt;/code>가 길이가 3이고 &lt;code>a&lt;/code>를 가리키는 포인터를 가진 슬라이스라고 말할 수 있으면 좋겠습니다. 하지만 컴파일 타임에 알려진 값, 즉 &lt;code>1&lt;/code>과 &lt;code>4&lt;/code>를 사용하여 배열을 &amp;ldquo;슬라이스&amp;quot;했으므로 길이인 &lt;code>3&lt;/code> 것도 컴파일 타임에 알 수 있습니다. 지그는 이 모든 것을 알아내어 &lt;code>b&lt;/code>는 슬라이스가 아니라 길이가 3인 정수 배열에 대한 포인터입니다. 구체적으로, 그 유형은 &lt;code>*const [3]i32&lt;/code> 입니다. 따라서 이 슬라이스 데모는 Zig의 영리함 때문에 실패합니다.&lt;/p>
&lt;p>실제 코드에서는 배열보다 슬라이스를 더 많이 사용할 것입니다. 좋든 나쁘든, 프로그램은 컴파일 과정에서의 정보보다 런타임에서 정보를 더 많이 갖는 경향이 있습니다. 그렇지만 이 작은 예제에서 원하는 것을 얻기 위해 우리는 컴파일러를 속여야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [_]&lt;span style="color:#66d9ef">i32&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> end&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>..end];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 &lt;code>b&lt;/code>는 적절한 슬라이스이며, 특히 그 유형은 &lt;code>[]const i32&lt;/code> 입니다. 슬라이스의 길이는 런타임 프로퍼티이고 타입은 컴파일 시점에 완전히 알 수 있기 때문에 슬라이스의 길이가 타입의 일부가 아님을 알 수 있습니다. 슬라이스를 만들 때 상위 제한을 생략하여 슬라이싱하는 대상(배열이든 슬라이스이든)의 끝 부분에 슬라이스를 만들 수 있습니다(예: &lt;code>const c = b[2..];&lt;/code>).&lt;/p>
&lt;blockquote>
&lt;p>만약 &lt;code>end&lt;/code>를 &lt;code>const&lt;/code>로 선언했다면 컴파일 타임에 알려진 값이 되어 &lt;code>b&lt;/code>의 길이가 컴파일 타임에 알려졌을 것이고, 따라서 슬라이스가 아닌 배열에 대한 포인터가 생성되었을 것입니다. 약간 혼란스럽긴 하지만 자주 발생하는 문제가 아니며 익히기 어렵지 않습니다. 이 시점에서 그냥 넘어가고 싶었지만 이 세부 사항을 피할 수 있는 적절한 방법을 찾지 못했습니다.&lt;/p>
&lt;/blockquote>
&lt;p>Zig를 배우면서 타입이 매우 서술적이라는 것을 알게 되었습니다. 타입은 단순히 정수나 부울, 심지어 부호 있는 32비트 정수의 배열이 아닙니다. 타입에는 다른 중요한 정보도 포함되어 있습니다. 길이가 배열 타입의 일부라고 이야기했고, 많은 예제에서 상수 또한 타입의 일부라고 설명했습니다. 예를 들어, 마지막 예제에서 &lt;code>b&lt;/code>의 타입은 &lt;code>[]const i32&lt;/code> 입니다. 다음 코드를 통해 이를 직접 확인할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [_]&lt;span style="color:#66d9ef">i32&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> end&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>..end];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&amp;#34;&lt;/span>, .{@TypeOf(b)});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>b[2] = 5;&lt;/code>와 같이 &lt;code>b&lt;/code>에 값을 쓰려고 하면 컴파일 오류가 발생합니다: &lt;em>cannot assign to constant&lt;/em>. 이는 &lt;code>b&lt;/code>의 타입 때문입니다.&lt;/p>
&lt;p>이 문제를 해결하려면 다음과 같이 변경하면 됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// replace const with var
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>..end];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 동일한 오류가 발생합니다. 왜 그럴까요? 힌트를 드리자면, &lt;code>b&lt;/code>의 유형이 무엇일까요, 더 일반적으로는 &lt;code>b&lt;/code>가 무엇일까요? 슬라이스는 배열의 &lt;code>[부분]&lt;/code>에 대한 길이이자 포인터입니다. 슬라이스의 타입은 항상 기본 배열에서 파생됩니다. &lt;code>b&lt;/code>가 &lt;code>const&lt;/code>로 선언되든 아니든, 기본 배열은 &lt;code>[5]const i32&lt;/code> 유형이므로 &lt;code>b&lt;/code>는 &lt;code>[]const i32&lt;/code> 유형이어야 합니다. &lt;code>b&lt;/code>에 쓸 수 있게 하려면 &lt;code>a&lt;/code> 를 &lt;code>const&lt;/code>에서 &lt;code>var&lt;/code>로 변경해야 합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [_]&lt;span style="color:#66d9ef">i32&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> end&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>..end];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">99&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이것은 슬라이스가 더 이상 &lt;code>[]const i32&lt;/code> 가 아니라 &lt;code>[]i32&lt;/code> 이기 때문에 작동합니다. &lt;code>b&lt;/code>가 여전히 &lt;code>const&lt;/code>인데 왜 이것이 작동하는지 궁금할 수 있습니다. 그러나 &lt;code>b&lt;/code>의 const는 &lt;code>b&lt;/code>가 가리키는 데이터가 아니라 &lt;code>b&lt;/code> 자체와 관련이 있습니다. 이것이 좋은 설명인지는 모르겠지만, 저에게는 이 코드가 그 차이를 강조합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [_]&lt;span style="color:#66d9ef">i32&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> end&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>..end];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> b[&lt;span style="color:#ae81ff">1&lt;/span>..];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>컴파일러가 알려주는 대로 &lt;em>상수에 할당할 수 없기&lt;/em> 때문에 컴파일되지 않습니다. 그러나 &lt;code>var b = a[1..end];&lt;/code>를 수행했다면, &lt;code>b&lt;/code> 자체가 더 이상 상수가 아니기 때문에 코드가 작동했을 것입니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 일부 프로그래밍 언어에서 상수 선언은 재할당을 금지하는 역할을 하기도 합니다.&lt;/p>
&lt;/blockquote>
&lt;p>앞으로 언어의 다른 측면을 보면서, 배열과 슬라이스를 더 살펴보고 문자열에 대해 자세히 알아보겠습니다.&lt;/p>
&lt;h3 id="문자열strings">문자열Strings&lt;/h3>
&lt;p>Zig에 문자열 타입이 있고 정말 멋지다고 말할 수 있으면 좋겠어요. 안타깝게도 그렇지 않습니다. 가장 간단하게 설명하자면, Zig 문자열은 바이트(&lt;code>u8&lt;/code>)의 시퀀스(즉, 배열 또는 슬라이스)입니다. 실제로 &lt;code>name&lt;/code> 필드의 정의에서 이를 확인할 수 있습니다: &lt;code>name: []const u8,&lt;/code>.&lt;/p>
&lt;p>관례에 따라, 그리고 관례에 따라서만, 이러한 문자열은 UTF-8 값만 포함해야 하는데, 그 이유는 Zig 소스 코드 자체가 UTF-8로 인코딩되기 때문입니다. 그러나 이것은 강제 사항이 아니며, ASCII 또는 UTF-8 문자열을 나타내는 &lt;code>[]const u8&lt;/code> 과 임의의 바이너리 데이터를 나타내는 &lt;code>[]const u8&lt;/code> 사이에는 실제로 아무런 차이가 없습니다. 같은 타입인데 어떻게 차이가 있을 수 있겠습니까?&lt;/p>
&lt;p>배열과 슬라이스에 대해 배웠다면 &lt;code>[]const u8&lt;/code>이 바이트의 상수 배열(여기서 바이트는 부호 없는 8비트 정수)에 대한 슬라이스라고 추측하는 것이 맞을 것입니다. 하지만 코드 어디에도 배열을 슬라이스하거나 배열이 있는 것은 아니죠? 그저 &lt;code>user.name&lt;/code> 에 &amp;ldquo;Goku&amp;quot;를 할당했을 뿐입니다. 어떻게 작동했을까요?&lt;/p>
&lt;p>소스 코드에서 볼 수 있는 문자열 리터럴은 컴파일 타임에 알려진 길이를 갖습니다. 컴파일러는 &amp;ldquo;Goku&amp;quot;의 길이가 4라는 것을 알고 있습니다. 따라서 &amp;ldquo;Goku&amp;quot;는 &lt;code>[4]const u8&lt;/code> 과 같은 배열로 표현하는 것이 가장 좋다고 생각할 수 있습니다. 하지만 문자열 리터럴에는 몇 가지 특별한 속성이 있습니다. 문자열 리터럴은 컴파일된 바이너리 내의 특별한 위치에 저장되고 중복 제거됩니다. 따라서 문자열 리터럴에 대한 변수는 이 특별한 위치에 대한 포인터가 됩니다. 즉, &amp;ldquo;Goku&amp;quot;의 유형은 4바이트의 상수 배열에 대한 포인터인 &lt;code>*const [4]u8&lt;/code> 에 더 가깝다는 뜻입니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 리터럴literal 은 소스코드에서 다른 표현으로 분해되지 않는 가장 작은 단위의 코드 조각을 의미합니다. 예를 들어, &lt;code>5&lt;/code> 는 리터럴이지만 &lt;code>5 + 1&lt;/code> 은 리터럴이 아닙니다. 그리고 &lt;code>5 + 1&lt;/code> 은 &lt;code>6&lt;/code> 이라는 리터럴로 분해됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>이외에도 더 있습니다. 문자열 리터럴은 널null 로 종료됩니다. 즉, 항상 끝에 &lt;code>\0&lt;/code> 이 있습니다. 널로 끝나는 문자열은 C 와 상호 작용할 때 중요합니다. 메모리에서 &amp;ldquo;Goku&amp;quot;는 실제로 다음과 같이 보일 것입니다: &lt;code>{'G', 'o', 'k', 'u', 0}&lt;/code> 이므로 유형이 &lt;code>*const [5]u8&lt;/code> 이라고 생각할 수 있습니다. 그러나 이것은 기껏해야 모호하고 최악의 경우 위험할 수 있습니다(널 종결자를 덮어쓸 수 있습니다). 대신 Zig에는 널로 종료된 배열을 표현하는 고유한 구문이 있습니다. &amp;ldquo;Goku&amp;quot;의 타입은 다음과 같습니다: &lt;code>*const [4:0]u8&lt;/code>, 널로 끝나는 4바이트 배열을 가리키는 포인터입니다. 문자열에 대해 이야기할 때는 널로 끝나는 바이트 배열에 초점을 맞추고 있지만(C에서 문자열이 일반적으로 표현되는 방식이므로), 이 구문이 더 일반적입니다: &lt;code>[LENGTH:SENTINEL]&lt;/code> 여기서 &amp;ldquo;센티넬Setinel&amp;quot;은 배열의 끝에서 발견되는 특수 값입니다. 따라서 이 구문이 왜 필요한지 모르겠지만, 다음과 같은 구문은 완전히 유효합니다:&lt;/p>
&lt;blockquote>
&lt;p>[!] 문자열 종료로 null 을 사용하지 않는 프로그래밍 언어도 있습니다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// an array of 3 booleans with false as the sentinel value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>]&lt;span style="color:#66d9ef">bool&lt;/span>{&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// This line is more advanced, and is not going to get explained!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{std.mem.asBytes(&lt;span style="color:#f92672">&amp;amp;&lt;/span>a).&lt;span style="color:#f92672">*&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 이렇게 출력됩니다: &lt;code>{ 0, 1, 0, 0}&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>마지막 줄이 상당히 전문적인 내용이고 설명할 의도가 없기 때문에 이 예제를 포함시키는 것을 망설였습니다. 반대로, 원하신다면 지금까지 설명한 내용을 더 잘 살펴보기 위해 실행하고 실습해 볼 수 있는 예제입니다.&lt;/p>
&lt;/blockquote>
&lt;p>제가 충분히 설명했다고 해도 여전히 한 가지 궁금한 점이 있을 것입니다. &amp;ldquo;Goku&amp;quot;가 &lt;code>*const [4:0]u8&lt;/code> 이라면 어떻게 &lt;code>name&lt;/code> 에 &lt;code>[]const u8&lt;/code> 을 할당할 수 있었을까요? 답은 간단합니다: Zig가 강제로 타입을 지정하기 때문입니다. 몇 가지 다른 타입 사이에서 이 작업을 수행하지만 문자열에서 가장 분명합니다. 즉, 함수에 &lt;code>[]const u8&lt;/code> 매개변수가 있거나 구조체에 &lt;code>[]const u8&lt;/code> 필드가 있는 경우 문자열 리터럴을 사용할 수 있습니다. 널로 끝나는 문자열은 배열이고 배열은 길이가 알려져 있기 때문에, 이 강제성은 문자열을 반복하여 널 종결자를 찾을 필요가 없다는 점에서 효율적입니다.&lt;/p>
&lt;p>따라서 문자열에 대해 이야기할 때 문자열은 보통 &lt;code>[]const u8&lt;/code> 을 의미합니다. 필요한 경우 널로 끝나는 문자열을 명시적으로 명시하면 자동으로 &lt;code>[]const u8&lt;/code> 로 강제 변환될 수 있습니다. 하지만 &lt;code>[]const u8&lt;/code> 은 임의의 바이너리 데이터를 표현하는 데에도 사용되므로 Zig에는 상위 프로그래밍 언어와 같은 문자열 개념이 없다는 점을 기억하세요. 게다가 Zig의 표준 라이브러리에는 아주 기본적인 유니코드 모듈만 있습니다.&lt;/p>
&lt;p>물론, 실제 프로그램에서 대부분의 문자열(더 일반적으로는 배열)은 컴파일 시점에 알 수 없습니다. 대표적인 예가 프로그램이 컴파일될 때 알 수 없는 사용자 입력입니다. 이 부분은 메모리에 대해 이야기할 때 다시 살펴봐야 할 부분입니다. 하지만 간단히 말하자면, 컴파일 시점에 값을 알 수 없고 따라서 길이도 알 수 없는 데이터의 경우 런타임에 메모리를 동적으로 할당해야 한다는 것입니다. 여전히 &lt;code>[]const u8&lt;/code> 타입인 문자열 변수는 이 동적으로 할당된 메모리를 가리키는 부분이 될 것입니다.&lt;/p>
&lt;h3 id="컴프타임과-애니타입comptime-and-anytype">컴프타임과 애니타입comptime and anytype&lt;/h3>
&lt;p>마지막 남은 코드 라인에는 눈에 보이는 것보다 훨씬 더 많은 일이 벌어지고 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s}&amp;#39;s power is {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user.name, user.power});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서는 대충 훑어보기만 하겠지만, Zig의 더 강력한 기능 중 몇 가지를 강조할 수 있는 기회를 마련해줍니다. 완전히 익히지는 못했더라도 최소한 알고 있어야 할 기능들입니다.&lt;/p>
&lt;p>Zig의 첫 번째 컨셉은 바로 컴파일 시간 실행, 즉 &lt;code>comptime&lt;/code> 입니다. 이는 Zig 메타프로그래밍 기능의 핵심이며, 이름에서 알 수 있듯이 런타임이 아닌 컴파일 타임에 코드를 실행하는 것을 중심으로 합니다. 이 가이드에서는 컴프타임으로 할 수 있는 일의 표면적인 부분만 다루겠지만, 컴프타임comptime은 항상 사용되는 기능입니다.&lt;/p>
&lt;p>위의 줄에서 컴파일 타임 실행에 필요한 것이 무엇인지 궁금할 수 있습니다. &lt;code>print&lt;/code> 함수를 정의하려면 첫 번째 매개변수인 문자열 형식은 컴파일 타임에 대해 알 수 있어야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;#34;fmt&amp;#34; 변수 앞에 &amp;#34;comptime&amp;#34;이 있는 것을 확인하세요.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> print(&lt;span style="color:#66d9ef">comptime&lt;/span> fmt&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>, args&lt;span style="color:#f92672">:&lt;/span> anytype) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그 이유는 Zig 의 &lt;code>print&lt;/code> 가 대부분의 다른 언어에서는 얻을 수 없는 추가 컴파일 시간 검사를 수행하기 때문입니다. 어떤 종류의 검사일까요? 형식을 &lt;code>&amp;quot;it's over {d}\n&amp;quot;&lt;/code>으로 변경했지만 두 개의 인수는 그대로 유지했다고 가정해 봅시다. 그래도 컴파일 시간에 오류가 발생합니다: &lt;em>unused argument in &amp;ldquo;it&amp;rsquo;s over {d}&amp;rdquo;&lt;/em>. 이 과정에는 형식 검사도 수행합니다. 형식 문자열을 &lt;code>&amp;quot;{s}'s power is {s}\n&amp;quot;&lt;/code> 으로 변경하면 &lt;em>invalid format string &amp;rsquo;s&amp;rsquo; for type &amp;lsquo;u64&amp;rsquo;&lt;/em> 오류를 만납니다. 컴파일 시점에 문자열 형식을 알 수 없는 경우 이러한 검사는 컴파일 시점에 수행할 수 없습니다. 따라서 컴파일 타임에 알려진 값이 필요합니다.&lt;/p>
&lt;p>컴프타임이 코딩에 즉각적으로 영향을 미치는 곳은 정수 및 부동 소수점 리터럴의 기본 유형인 특수 &lt;code>comptime_int&lt;/code> 및 &lt;code>comptime_float&lt;/code> 입니다. 다음 코드 줄은 유효하지 않습니다: &lt;code>var i = 0;&lt;/code>. 이 코드를 컴파일 시 오류가 발생합니다. &lt;em>variable of type &amp;lsquo;comptime_int&amp;rsquo; must be const or comptime&lt;/em>. &lt;code>comptime&lt;/code> 코드는 컴파일 시점에 알려진 데이터로만 작동할 수 있으며, 정수 및 부동 소수점의 경우 이러한 데이터는 특수 &lt;code>comptime_int&lt;/code> 및 &lt;code>comptime_float&lt;/code> 타입으로 식별됩니다. 이 타입의 값은 컴파일 시간 실행에 사용할 수 있습니다. 하지만 컴파일 시간 실행을 위해 코드를 작성하는 데 대부분의 시간을 소비하지 않을 가능성이 높으므로 특별히 유용한 기본값은 아닙니다. 그래서 변수에 명시적으로 타입을 지정해야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> i&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> j&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">f64&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>이 오류는 &lt;code>var&lt;/code> 를 사용했기 때문에 발생한 것일 뿐, &lt;code>const&lt;/code> 를 사용했다면 오류가 발생하지 않았을 것입니다. 이 에러의 전체 요점은 &lt;code>comptime_int&lt;/code>가 &lt;em>반드시&lt;/em> &lt;code>const&lt;/code>여야 한다는 것입니다.&lt;/p>
&lt;/blockquote>
&lt;p>다음 파트에서는 제네릭을 살펴볼 때 컴프타임에 대해 좀 더 자세히 살펴보겠습니다.&lt;/p>
&lt;p>우리 코드 줄의 또 다른 특별한 점은, 위의 &lt;code>print&lt;/code> 정의에서 알 수 있듯이 &lt;code>anytype&lt;/code> 으로 매핑되는 이상한 &lt;code>.{user.name, user.power}&lt;/code> 입니다. 이 유형을 Java의 &lt;code>Object&lt;/code> 나 Go의 &lt;code>any&lt;/code>(일명 &lt;code>interface{}&lt;/code>)와 혼동해서는 안 됩니다. 오히려 컴파일 시점에 Zig는 전달된 모든 유형에 대한 특별한 print 함수를 생성합니다.&lt;/p>
&lt;p>그러면 무엇을 전달할 것인가라는 질문이 생깁니다. 컴파일러가 구조체의 유형을 유추할 때 &lt;code>.{...}&lt;/code> 표기법을 본 적이 있을 것입니다. 이것도 비슷합니다. 익명 구조체 리터럴을 생성합니다. 다음 코드를 살펴봅시다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{@TypeOf(.{.year &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2023&lt;/span>, .month &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>})});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 출력합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span>{&lt;span style="color:#66d9ef">comptime&lt;/span> year&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">comptime_int&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2023&lt;/span>, &lt;span style="color:#66d9ef">comptime&lt;/span> month&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">comptime_int&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서는 익명의 구조체 필드 이름인 &lt;code>year&lt;/code>와 &lt;code>month&lt;/code>을 지정했습니다. 원래 코드에서는 그렇지 않았습니다. 이 경우 필드 이름은 자동으로 &amp;ldquo;0&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo; 등으로 생성됩니다. 인쇄 함수는 이러한 필드가 있는 구조를 예상하고 문자열 형식의 서수 위치를 사용하여 적절한 인수를 가져옵니다.&lt;/p>
&lt;p>Zig에는 함수 오버로딩이 없으며, 가변 함수(임의의 수의 인수를 갖는 함수)도 없습니다. 하지만 컴파일러 자체에서 추론하고 생성한 타입을 포함하여 전달된 타입을 기반으로 특수한 함수를 생성할 수 있는 컴파일러가 있습니다.&lt;/p>
&lt;h2 id="언어-개요---part-2">언어 개요 - Part 2&lt;/h2>
&lt;p>이번 파트에서는 이전 파트에서 이어서 언어에 익숙해지는 시간을 갖겠습니다. 구조체를 넘어 Zig의 제어 흐름과 타입을 살펴볼 것입니다. 첫 번째 파트에서 언어의 구문 대부분을 다루었으므로 이제 언어와 표준 라이브러리를 더 많이 다룰 수 있습니다.&lt;/p>
&lt;h3 id="흐름-제어control-flow">흐름 제어Control Flow&lt;/h3>
&lt;p>Zig의 제어 흐름은 익숙할 수 있지만, 아직 살펴보지 않은 언어의 측면과 추가적인 시너지 효과가 있습니다. 제어문에 대한 간략한 개요부터 시작해서 특별한 제어 흐름 동작을 유도하는 기능들에 대해 논의하겠습니다.&lt;/p>
&lt;p>논리 연산자 &lt;code>&amp;amp;&amp;amp;&lt;/code> 및 &lt;code>||&lt;/code> 대신 &lt;code>and&lt;/code> 또는 &lt;code>or&lt;/code> 연산자를 사용한다는 것을 알 수 있습니다. 대부분의 언어에서와 마찬가지로 &lt;code>and&lt;/code> 및 &lt;code>or&lt;/code> 는 실행 흐름을 제어합니다. 왼쪽이 거짓이면 &lt;code>and&lt;/code>의 오른쪽은 평가되지 않고, 왼쪽이 참이면 &lt;code>or&lt;/code>의 오른쪽은 평가되지 않습니다. 지그에서는 제어 흐름이 키워드로 수행되므로 &lt;code>and&lt;/code> 및 &lt;code>or&lt;/code> 가 키워드로 사용됩니다.&lt;/p>
&lt;p>또한, 비교 연산자 &lt;code>==&lt;/code> 는 &lt;code>[]const u8&lt;/code> 과 같은 슬라이스, 즉 문자열 사이에서는 작동하지 않습니다. 대부분의 경우, 두 슬라이스의 길이를 비교한 다음 바이트를 비교하는 것은 &lt;code>std.mem.eql(u8, str1, str2)&lt;/code> 을 사용하게 됩니다.&lt;/p>
&lt;p>지그의 &lt;code>if&lt;/code>, &lt;code>else if&lt;/code> 및 &lt;code>else&lt;/code> 는 일반적으로 사용됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// std.mem.eql does a byte-by-byte comparison
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// for a string it&amp;#39;ll be case sensitive
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (std.mem.eql(&lt;span style="color:#66d9ef">u8&lt;/span>, method, &lt;span style="color:#e6db74">&amp;#34;GET&amp;#34;&lt;/span>) &lt;span style="color:#66d9ef">or&lt;/span> std.mem.eql(&lt;span style="color:#66d9ef">u8&lt;/span>, method, &lt;span style="color:#e6db74">&amp;#34;HEAD&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// handle a GET request
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (std.mem.eql(&lt;span style="color:#66d9ef">u8&lt;/span>, method, &lt;span style="color:#e6db74">&amp;#34;POST&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// handle a POST request
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>std.mem.eql&lt;/code> 의 첫 번째 인수는 타입(이 경우 &lt;code>u8&lt;/code>)입니다. 이것은 우리가 처음 본 제네릭 함수입니다. 나중에 더 자세히 살펴보겠습니다.&lt;/p>
&lt;/blockquote>
&lt;p>위의 예제는 ASCII 문자열을 비교하는 것이므로 대소문자를 구분하지 않을수도 있습니다. 대소문자를 구분하지 않으려면 &lt;code>std.ascii.eqlIgnoreCase(str1, str2)&lt;/code> 가 더 나은 옵션일 수 있습니다.&lt;/p>
&lt;p>삼항 연산자는 없지만, 다음과 같이 &lt;code>if/else&lt;/code> 를 사용할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> super &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (power &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">9000&lt;/span>) &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>switch&lt;/code> 는 if/else if/else 중첩과 유사하지만 더욱 철저하다는 장점이 있습니다. 즉, 모든 경우를 다루지 않으면 컴파일 타임 오류가 발생합니다. 이 코드는 컴파일되지 않습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> anniversaryName(years_married&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u16&lt;/span>) []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (years_married) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;paper&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;cotton&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;leather&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;flower&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;wood&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;sugar&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>switch&lt;/code>는 모든 가능성을 처리해야 한다고 들었습니다. 그러면 &lt;code>years_married&lt;/code> 가 16비트 정수이므로 64K 건의 경우를 처리해야 한다는 뜻일까요? 예, 하지만 다행히도 &lt;code>다른else&lt;/code> 방법이 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;sugar&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no more gifts for you&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여러 케이스를 결합하거나 범위 표현을 사용할 수 있으며 복잡한 사례에는 블록을 사용할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> arrivalTimeDesc(minutes&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u16&lt;/span>, is_late&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>) []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (minutes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;arrived&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;soon&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>...&lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no more than 5 minutes&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>is_late) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;sorry, it&amp;#39;ll be a while&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// todo, something is very wrong
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;never&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>switch&lt;/code> 는 여러 경우에 유용하지만, 열거형을 다룰 때 그 철저한 특성이 빛을 발하는데, 이에 대해서는 곧 설명하겠습니다.&lt;/p>
&lt;p>Zig의 &lt;code>for&lt;/code> 루프는 배열, 슬라이스 및 범위를 반복하는 데 사용됩니다. 예를 들어 배열에 값이 포함되어 있는지 확인하기 위해 다음과 같이 작성할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> contains(haystack&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u32&lt;/span>, needle&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u32&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (haystack) &lt;span style="color:#f92672">|&lt;/span>value&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (needle &lt;span style="color:#f92672">==&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>for&lt;/code> 루프는 각각의 길이가 같은 시퀀스만 있으면 한 번에 여러 시퀀스에서 작동할 수 있습니다. 위에서는 &lt;code>std.mem.eql&lt;/code> 함수를 사용했습니다. (거의) 다음과 같은 모습입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> eql(&lt;span style="color:#66d9ef">comptime&lt;/span> T&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span>, a&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> T, b&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> T) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// if they arent&amp;#39; the same length, the can&amp;#39;t be equal
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (a.len &lt;span style="color:#f92672">!=&lt;/span> b.len) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (a, b) &lt;span style="color:#f92672">|&lt;/span>a_elem, b_elem&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (a_elem &lt;span style="color:#f92672">!=&lt;/span> b_elem) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>최초의 &lt;code>if&lt;/code> 검사는 단순히 성능 최적화를 위한 것이 아니라 필수적인 보호 장치입니다. 이를 제거하고 길이가 다른 인수를 전달하면 런타임에 &lt;em>for loop over objects with non-equal lengths(길이가 같지 않은 객체에 대한 for 루프)&lt;/em> 패닉을 일으킬 수 있습니다.&lt;/p>
&lt;p>&lt;code>for&lt;/code> 루프는 다음과 같은 범위에 대한 반복도 할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>..&lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{i});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>우리의 &lt;code>switch&lt;/code> 범위는 &lt;code>3...6&lt;/code> 의 세 점을 사용했지만, 이 범위는 &lt;code>0..10&lt;/code> 의 두 점을 사용합니다. &lt;code>switch&lt;/code> 케이스는 두 숫자, 하한값과 상한값 모두 포함하지만 &lt;code>for&lt;/code> 는 상한값을 제외하려 하기 때문입니다.&lt;/p>
&lt;/blockquote>
&lt;p>이 기능은 하나 이상의 시퀀스와 함께 사용하면 더욱 빛을 발합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> indexOf(haystack&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u32&lt;/span>, needle&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u32&lt;/span>) &lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (haystack, &lt;span style="color:#ae81ff">0&lt;/span>..) &lt;span style="color:#f92672">|&lt;/span>value, i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (needle &lt;span style="color:#f92672">==&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>널nullable 타입을 살짝 엿보았습니다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!] 함수의 반환 타입 정보 앞에 &lt;code>?&lt;/code>가 붙어 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>범위range의 끝은 &lt;code>haystack&lt;/code> 의 길이에서 유추할 수 있지만, 우리는 스스로 생각하고 쓸 수 있습니다: &lt;code>0..hastack.len&lt;/code>. &lt;code>for&lt;/code> 루프는 보다 일반적인 &lt;code>init; compare; step&lt;/code> 구문을 지원하지 않습니다. 이를 위해 우리는 &lt;code>while&lt;/code> 에 의존합니다.&lt;/p>
&lt;p>&lt;code>while&lt;/code> 은 &lt;code>while (condition) { }&lt;/code>의 형태의 단순한 형태로 반복을 더 잘 제어할 수 있습니다. 예를 들어 문자열에서 이스케이프 시퀀스의 수를 계산할 때 &lt;code>\\&lt;/code>가 이중으로 계산되지 않도록 이터레이터를 2씩 증가시켜야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> i&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> escape_count&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> src.len) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (src[i] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">&amp;#39;\\&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> escape_count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>while&lt;/code> 에는 조건이 거짓일 때 실행되는 &lt;code>else&lt;/code> 절이 있을 수 있습니다. 또한 각 반복 후에 실행할 문을 허용합니다. 이 기능은 &lt;code>for&lt;/code> 가 사용되기 전에 여러 시퀀스를 지원하기 위해 일반적으로 사용되었습니다. 위는 다음과 같이 작성할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> i&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> escape_count&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// this part
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">while&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> src.len) &lt;span style="color:#f92672">:&lt;/span> (i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (src[i] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">&amp;#39;\\&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// +1 here, and +1 above == +2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> escape_count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!] &lt;code>while&lt;/code> 의 한 반복이 끝나면 &lt;code>: (i += 1)&lt;/code> 이 실행됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>break&lt;/code> 와 &lt;code>continue&lt;/code>는 가장 안쪽 루프에서 벗어나거나 다음 반복으로 이동하는 데 지원됩니다.&lt;/p>
&lt;p>블록에 레이블을 지정할 수 있으며 &lt;code>break&lt;/code> 및 &lt;code>continue&lt;/code>는 특정 레이블을 대상으로 지정할 수 있습니다. 인위적인 예제입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>outer&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>..&lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i..&lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>j&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">*&lt;/span> j &lt;span style="color:#f92672">&amp;gt;&lt;/span> (i&lt;span style="color:#f92672">+&lt;/span>i &lt;span style="color:#f92672">+&lt;/span> j&lt;span style="color:#f92672">+&lt;/span>j)) &lt;span style="color:#66d9ef">continue&lt;/span> &lt;span style="color:#f92672">:&lt;/span>outer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{d} + {d} &amp;gt;= {d} * {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{i&lt;span style="color:#f92672">+&lt;/span>i, j&lt;span style="color:#f92672">+&lt;/span>j, i, j});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>break&lt;/code> 에는 블록에서 값을 반환하는 또 다른 흥미로운 행동이 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> personality_analysis &lt;span style="color:#f92672">=&lt;/span> blk&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tea_vote &lt;span style="color:#f92672">&amp;gt;&lt;/span> coffee_vote) &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#f92672">:&lt;/span>blk &lt;span style="color:#e6db74">&amp;#34;sane&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tea_vote &lt;span style="color:#f92672">==&lt;/span> coffee_vote) &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#f92672">:&lt;/span>blk &lt;span style="color:#e6db74">&amp;#34;whatever&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tea_vote &lt;span style="color:#f92672">&amp;lt;&lt;/span> coffee_vote) &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#f92672">:&lt;/span>blk &lt;span style="color:#e6db74">&amp;#34;dangerous&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이와 같은 블록은 세미콜론으로 끝나야 합니다.&lt;/p>
&lt;p>나중에 태그 유니온, 에러 유니온 및 선택적 타입에 대해 살펴볼 때 이러한 제어 흐름 구조가 제공하는 다른 기능에 대해 살펴보겠습니다.&lt;/p>
&lt;h3 id="열거enums">열거Enums&lt;/h3>
&lt;p>열거형은 레이블이 지정된 정수 상수입니다. 열거형은 구조체와 매우 유사하게 정의됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// could be &amp;#34;pub&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> Status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bad,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unknown,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그리고 구조체와 마찬가지로, 열거형을 매개변수로 사용할 수도 있고 사용하지 않을 수도 있는 함수를 비롯한 다른 정의를 포함할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Stage &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> validate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> awaiting_confirmation,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> confirmed,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> completed,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> isComplete(self&lt;span style="color:#f92672">:&lt;/span> Stage) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> self &lt;span style="color:#f92672">==&lt;/span> .confirmed &lt;span style="color:#66d9ef">or&lt;/span> self &lt;span style="color:#f92672">==&lt;/span> .err;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>열거형의 문자열 표현을 원하면 내장된 &lt;code>@tagName(enum)&lt;/code> 함수를 사용하면 됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>자기 소환의 구조체 타입은 &lt;code>.{...}&lt;/code> 표기법을 사용하여 할당 또는 반환 타입에 근거하여 추론할 수 있습니다. 위에서는 열거형 타입이 &lt;code>Stage&lt;/code> 타입인 &lt;code>self&lt;/code>와의 비교를 기반으로 추론되는 것을 볼 수 있습니다. 명시적으로 작성할 수도 있었습니다: &lt;code>return self == Stage.confirmed 또는 self == Stage.err;&lt;/code>. 하지만 열거형을 다룰 때는 종종 &lt;code>.$value&lt;/code> 표기법을 통해 열거형 타입이 생략되는 것을 볼 수 있습니다.&lt;/p>
&lt;p>&lt;code>switch&lt;/code>의 철저한 특성으로 인해 가능한 모든 경우를 처리할 수 있으므로 이는 열거형과 잘 어울립니다. 하지만 &lt;code>switch&lt;/code>의 &lt;code>else&lt;/code> 절을 사용할 때는 새로 추가된 열거형 값과 일치하게 되므로 원하는 동작이 아닐 수도 있으므로 주의하세요.&lt;/p>
&lt;h3 id="태그드-유니언tagged-unions">태그드 유니언Tagged Unions&lt;/h3>
&lt;p>공용체는 값이 가질 수 있는 타입의 집합을 정의합니다. 예를 들어, 이 &lt;code>Number&lt;/code> 유니온은 &lt;code>integer&lt;/code>, &lt;code>float&lt;/code> 또는 &lt;code>nan&lt;/code>(숫자가 아님) 중 하나일 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> Number{.int &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{n.int});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Number &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">union&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">f64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nan&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>공용체는 한 번에 하나의 필드만 설정할 수 있으므로 설정되지 않은 필드에 액세스하려고 하면 오류가 발생합니다. &lt;code>int&lt;/code> 필드를 설정했기 때문에 &lt;code>n.float&lt;/code>에 액세스하려고 하면 오류가 발생합니다. 필드 중 하나인 &lt;code>nan&lt;/code> 의 타입은 &lt;code>void&lt;/code> 입니다. 그렇다면 그 값을 어떻게 설정할까요? &lt;code>{}&lt;/code>를 사용하면 됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> Number{.nan &lt;span style="color:#f92672">=&lt;/span> {}};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>공용체를 사용할 때 어려운 점은 어떤 필드가 설정되어 있는지 파악하는 것입니다. 이때 태그가 지정된 유니온이 유용합니다. 태그가 지정된 유니온은 열거형과 유니온을 병합하여 스위치 문에서 사용할 수 있습니다. 이 예제를 살펴보겠습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> ts &lt;span style="color:#f92672">=&lt;/span> Timestamp{.unix &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1693278411&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{ts.seconds()});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> TimestampType &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unix,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> datetime,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Timestamp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">union&lt;/span>(TimestampType) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unix&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> datetime&lt;span style="color:#f92672">:&lt;/span> DateTime,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> DateTime &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> month&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> day&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hour&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> minute&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> seconds(self&lt;span style="color:#f92672">:&lt;/span> Timestamp) &lt;span style="color:#66d9ef">u16&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .datetime &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span>dt&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> dt.second,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .unix &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span>ts&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> seconds_since_midnight&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#f92672">=&lt;/span> @rem(ts, &lt;span style="color:#ae81ff">86400&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> @intCast(@rem(seconds_since_midnight, &lt;span style="color:#ae81ff">60&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>switch&lt;/code>의 각 케이스가 해당 필드의 타이핑된 값을 캡처하는 것을 볼 수 있습니다. 즉, &lt;code>dt&lt;/code>는 &lt;code>Timestamp.DateTime&lt;/code>이고 &lt;code>ts&lt;/code>는 &lt;code>i32&lt;/code>입니다. 구조체가 다른 타입 안에 중첩된 구조를 본 것은 이번이 처음입니다. &lt;code>DateTime&lt;/code>은 유니온 외부에서 정의될 수도 있었습니다. 그리고 두 개의 새로운 내장 함수도 보입니다: 나머지를 가져오는 &lt;code>@rem&lt;/code>과 결과를 &lt;code>u16&lt;/code>으로 변환하는 &lt;code>@intCast&lt;/code>입니다(&lt;code>@intCast&lt;/code>는 값이 반환되고 있으므로 반환 유형에서 &lt;code>u16&lt;/code>을 원한다고 추론합니다).&lt;/p>
&lt;p>위의 예제에서 볼 수 있듯이 태그된 공용체는 가능한 모든 구현을 미리 알고 태그된 공용체에 담을 수 있다면 인터페이스와 비슷하게 사용할 수 있습니다.&lt;/p>
&lt;p>마지막으로 태그된 유니온의 열거형 타입을 추론할 수 있습니다. &lt;code>TimestampType&lt;/code>을 정의하는 대신 이렇게 할 수도 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Timestamp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">union&lt;/span>(&lt;span style="color:#66d9ef">enum&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unix&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> datetime&lt;span style="color:#f92672">:&lt;/span> DateTime,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그러면 Zig는 유니온의 필드를 기반으로 암시적 열거형을 만들었을 것입니다.&lt;/p>
&lt;h3 id="옵셔널optional">옵셔널Optional&lt;/h3>
&lt;p>모든 값은 타입 앞에 물음표인 &lt;code>?&lt;/code>를 붙여서 선택 사항으로 선언할 수 있습니다. 선택적 유형은 &lt;code>null&lt;/code> 이거나 정의된 유형의 값일 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> home&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">?&lt;/span>[]&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> name&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">?&lt;/span>[]&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Leto&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>명시적 타입의 필요성은 명확해야 합니다. 만약 &lt;code>const name = &amp;quot;Leto&amp;quot;;&lt;/code>를 수행했다면, 추론된 타입은 비선택적 타입인 &lt;code>[]const u8&lt;/code> 이 될 것입니다.&lt;/p>
&lt;p>&lt;code>.?&lt;/code>는 선택적 타입 뒤에 있는 값에 액세스하는 데 사용됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{name.&lt;span style="color:#f92672">?&lt;/span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 null 에 &lt;code>.?&lt;/code>를 사용하면 런타임 패닉이 발생합니다. &lt;code>if&lt;/code> 문은 옵션의 래핑을 안전하게 해제할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (home) &lt;span style="color:#f92672">|&lt;/span>h&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// h is a []const u8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// we have a home value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we don&amp;#39;t have a home value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>orelse&lt;/code>를 사용하여 옵셔널을 언래핑하거나 코드를 실행할 수 있습니다. 이는 일반적으로 기본값을 지정하거나 함수에서 복귀하는 데 사용됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> h &lt;span style="color:#f92672">=&lt;/span> home &lt;span style="color:#66d9ef">orelse&lt;/span> &lt;span style="color:#e6db74">&amp;#34;unknown&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// or maybe
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// exit our function
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> h &lt;span style="color:#f92672">=&lt;/span> home &lt;span style="color:#66d9ef">orelse&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그러나 &lt;code>orelse&lt;/code>는 블록을 지정하여 더 복잡한 로직을 실행할 수도 있습니다. 선택적 타입은 &lt;code>while&lt;/code>과도 통합되며, 반복자를 만드는 데 자주 사용됩니다. 이터레이터를 구현하지는 않겠지만 이 더미 코드가 의미가 있기를 바랍니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (rows.next()) &lt;span style="color:#f92672">|&lt;/span>row&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something with our row
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="언디파인드undefined">언디파인드Undefined&lt;/h3>
&lt;p>지금까지 살펴본 모든 변수는 적절한 값으로 초기화되었습니다. 하지만 때로는 변수가 선언될 때 그 값을 알 수 없는 경우가 있습니다. 옵셔널도 하나의 옵션이지만 항상 의미가 있는 것은 아닙니다. 이러한 경우 변수를 &lt;code>undefined&lt;/code> 로 설정하여 초기화되지 않은 상태로 둘 수 있습니다.&lt;/p>
&lt;p>일반적으로 이 작업을 수행하는 경우는 어떤 함수에 의해 채워질 배열을 만들 때입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> pseudo_uuid&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">16&lt;/span>]&lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std.crypto.random.bytes(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pseudo_uuid);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위의 코드로 16바이트의 배열이 생성되지만 메모리는 초기화되지 않은 상태로 남습니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 물론 이후의 코드에 의해 랜덤한 값으로 채워질 것입니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="에러errors">에러Errors&lt;/h3>
&lt;p>Zig에는 간단하고 실용적인 오류 처리 기능이 있습니다. 모든 것은 열거형처럼 보이고 열거형처럼 동작하는 오류 집합으로 시작됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Like our struct in Part 1, OpenError can be marked as &amp;#34;pub&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// to make it accessible outside of the file it is defined in
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> OpenError &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessDenied,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NotFound,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!] 이는 &lt;code>error&lt;/code> 라는 타입이 명시적으로 제공된다고 볼 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>main&lt;/code>을 포함한 함수는 이제 이 오류를 반환할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> OpenError.AccessDenied;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> OpenError &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AccessDenied,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NotFound,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 함수를 실행하려고 하면 다음과 같은 오류가 발생합니다: &lt;em>expected type &amp;lsquo;void&amp;rsquo;, found &amp;rsquo;error{AccessDenied,NotFound}&amp;rsquo;&lt;/em>.
반환 타입이 &lt;code>void&lt;/code>인 &lt;code>main&lt;/code>을 정의했지만 무언가(물론 에러지만 여전히 &lt;code>void&lt;/code>는 아님)를 반환한다는 뜻입니다. 이 문제를 해결하려면 함수의 반환 유형을 변경해야 합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() OpenError&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> OpenError.AccessDenied;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이를 에러 유니온 타입이라고 하며, 함수가 &lt;code>OpenError&lt;/code> 에러 또는 &lt;code>void&lt;/code>(즉, 아무것도 반환하지 않음)를 반환할 수 있음을 나타냅니다. 지금까지 우리는 명확하게, 함수가 반환할 수 있는 오류에 대해 오류 집합을 만들고 함수의 오류 유니온 반환 유형에 해당하는 오류 집합을 사용했습니다.
하지만 오류와 관련해서는 Zig에 몇 가지 깔끔한 트릭이 있습니다. 첫째, 에러 유니온을 &lt;code>에러 집합!반환 타입&lt;/code>으로 지정하는 대신 Zig가 에러 집합을 유추하도록 할 수 있습니다: &lt;code>!반환 타입&lt;/code>을 사용하면 됩니다. 따라서 &lt;code>main&lt;/code>을 다음과 같이 정의할 수 있고, 아마도 앞으로는 이렇게 사용할 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>둘째, Zig는 암시적으로 에러 집합을 생성할 수 있습니다. 에러 집합을 생성하는 대신 다음과 같이 할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>.AccessDenied;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>완전히 명시적인 접근 방식과 암시적 접근 방식이 정확히 동등한 것은 아닙니다. 예를 들어, 암시적 오류 집합이 있는 함수를 참조하려면 특수한 &lt;code>anyerror&lt;/code> 유형을 사용해야 합니다. 라이브러리 개발자는 코드 자체 문서화같은 것 보다, 명시적인 방식이 더 유리하다고 생각할 수 있습니다. 하지만 저는 암시적 에러 집합과 추론된 에러 유니온 모두 실용적이라고 생각하며, 두 가지를 모두 많이 사용합니다.&lt;/p>
&lt;p>에러 유니온의 진정한 가치는 &lt;code>catch&lt;/code>와 &lt;code>try&lt;/code> 형태의 내장된 언어 기능에 있습니다. 에러 유니온을 반환하는 함수 호출에는 &lt;code>catch&lt;/code> 절을 포함할 수 있습니다. 예를 들어, http 서버 라이브러리에는 다음과 같은 코드가 있을 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>action(req, res) &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">|&lt;/span>err&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>.BrokenPipe &lt;span style="color:#66d9ef">or&lt;/span> err &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>.ConnectionResetByPeer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (err &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>.BodyTooBig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">431&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.body &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Request body is too big&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">500&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.body &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Internal Server Error&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// todo: log err
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>switch&lt;/code> 버전이 더 관용적입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>action(req, res) &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">|&lt;/span>err&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (err) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">error&lt;/span>.BrokenPipe, &lt;span style="color:#66d9ef">error&lt;/span>.ConnectionResetByPeer) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">error&lt;/span>.BodyTooBig &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">431&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.body &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Request body is too big&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">500&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.body &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Internal Server Error&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 모든 것이 꽤 멋지지만, 사실 여러분이 &lt;code>catch&lt;/code>에서 할 수 있는 일반적인 작업은 호출자에게 오류를 버블 처리하는 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>action(req, res) &lt;span style="color:#66d9ef">catch&lt;/span> &lt;span style="color:#f92672">|&lt;/span>err&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> err;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이것은 매우 일반적으로 &lt;code>try&lt;/code>가 하는 일입니다. 보통 위와 같이 하지 않고:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> action(req, res);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이것은 반드시 오류를 처리해야 하는 경우에 특히 유용합니다. 아마도 여러분은 대부분 &lt;code>try&lt;/code> 또는 &lt;code>catch&lt;/code>로 이를 처리할 것입니다.&lt;/p>
&lt;p>Go 개발자는 &lt;code>try&lt;/code>가 &lt;code>if err != nil { return err }&lt;/code>보다 키 입력 횟수가 적다는 것을 알 수 있습니다.&lt;/p>
&lt;p>대부분의 경우 &lt;code>try&lt;/code>와 &lt;code>catch&lt;/code>를 사용하게 되겠지만, 옵셔널 타입과 마찬가지로 &lt;code>if&lt;/code>와 &lt;code>while&lt;/code>에서도 에러 유니온이 지원됩니다. &lt;code>while&lt;/code>의 경우 조건이 오류를 반환하면 &lt;code>else&lt;/code> 절이 실행됩니다.&lt;/p>
&lt;p>모든 에러를 담을 수 있는 특별한 &lt;code>anyerror&lt;/code> 타입이 있습니다. 함수를 &lt;code>!TYPE&lt;/code>이 아닌 &lt;code>anyerror!TYPE&lt;/code>을 반환하는 것으로 정의할 수도 있지만, 이 둘은 동일하지 않습니다. 유추된 오류 집합은 함수가 반환할 수 있는 것을 기반으로 만들어집니다. &lt;code>anyerror&lt;/code>는 프로그램의 모든 오류 집합의 상위 집합인 전역 오류 집합입니다. 따라서 함수 시그니처에 &lt;code>anyerror&lt;/code>를 사용하면 함수가 실제로는 반환할 수 없는 오류를 반환할 수 있다는 신호가 될 수 있습니다. &lt;code>anyerror&lt;/code>는 모든 오류와 함께 작동할 수 있는 함수 매개변수나 구조체 필드에 사용됩니다(로깅 라이브러리를 예로 들 수 있습니다).&lt;/p>
&lt;p>함수가 에러 유니온 옵셔널 타입을 반환하는 경우는 드물지 않습니다. 추론된 오류 집합을 사용하면 다음과 같이 보입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// load the last saved game
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> loadLast() &lt;span style="color:#f92672">!?&lt;/span>Save {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TODO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이러한 함수를 사용하는 방법은 여러 가지가 있지만, 가장 간결한 방법은 &lt;code>try&lt;/code>를 사용하여 에러를 언래핑한 다음 &lt;code>otherwise&lt;/code>를 사용하여 선택사항을 언래핑하는 것입니다. 다음은 실제 동작하는 스켈레톤입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// This is the line you want to focus on
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> save &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">try&lt;/span> Save.loadLast()) &lt;span style="color:#66d9ef">orelse&lt;/span> Save.blank();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{save});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> Save &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lives&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> level&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u16&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> loadLast() &lt;span style="color:#f92672">!?&lt;/span>Save {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//todo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> blank() Save {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .lives &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Zig는 더 심층적인 내용을 가지며 각 언어 기능에는 더 큰 능력이 있지만, 이 첫 두 부분에서 살펴본 내용은 언어의 매우 중요한 부분입니다. 이는 언어의 기초가 되어 우리가 구문에 얽매이지 않고 더 복잡한 주제를 탐구할 수 있게 해줄 것입니다.&lt;/p>
&lt;h2 id="스타일-가이드">스타일 가이드&lt;/h2>
&lt;p>이 짧은 파트에서는 컴파일러가 강제하는 두 가지 코딩 규칙과 표준 라이브러리의 명명 규칙을 다룹니다.&lt;/p>
&lt;h3 id="사용되지-않는-변수unused-variables">사용되지 않는 변수Unused Variables&lt;/h3>
&lt;p>Zig는 변수가 사용되지 않는 것을 허용하지 않습니다. 다음 코드는 두 개의 컴파일 타임 에러를 발생시킵니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> add(&lt;span style="color:#ae81ff">8999&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> add(a&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>, b&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>) &lt;span style="color:#66d9ef">i64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// notice this is a + a, not a + b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>첫 번째 오류는 &lt;code>sum&lt;/code>이 &lt;em>사용되지 않은 지역 상수&lt;/em>이기 때문입니다. 두 번째 오류는 &lt;code>b&lt;/code>가 &lt;em>사용되지 않은 함수 매개변수&lt;/em>이기 때문입니다. 이 코드에서는 명백한 버그입니다. 하지만 사용하지 않는 변수와 함수 매개변수가 있는 데에는 정당한 이유가 있을 수 있습니다. 이러한 경우 변수를 밑줄(&lt;code>_&lt;/code>)로 할당할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&lt;/span> add(&lt;span style="color:#ae81ff">8999&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// or
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">=&lt;/span> add(&lt;span style="color:#ae81ff">8999&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> add(a&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>, b&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>) &lt;span style="color:#66d9ef">i64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>_ = b;&lt;/code> 대신 함수 매개변수의 이름을 &lt;code>_&lt;/code>로 지정할 수도 있지만, 제 생각에는 이렇게 하면 이 코드의 독자는 사용하지 않는 매개변수가 무엇인지 고민하게 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> add(a&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>, _&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>) &lt;span style="color:#66d9ef">i64&lt;/span> {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>std&lt;/code>도 사용되지 않지만 오류를 생성하지 않습니다. 향후 어느 시점이 되면 Zig는 이를 컴파일 타임 에러로 처리할 것으로 예상됩니다.&lt;/p>
&lt;h3 id="쉐도잉shadowing">쉐도잉Shadowing&lt;/h3>
&lt;p>Zig는 한 식별자가 같은 이름을 사용하여 다른 식별자를 &amp;ldquo;숨기는&amp;rdquo; 것을 허용하지 않습니다. 다음 코드는 소켓에서 무언가 읽기 위한 코드인데 유효하지 않습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> read(stream&lt;span style="color:#f92672">:&lt;/span> std.net.Stream) &lt;span style="color:#f92672">!&lt;/span>[]&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> buf&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">512&lt;/span>]&lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> read &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> stream.read(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (read &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>.Closed;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> buf[&lt;span style="color:#ae81ff">0&lt;/span>..read];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>read&lt;/code> 변수가 함수 이름을 가리고 있습니다. 이 규칙은 일반적으로 개발자가 의미 없는 짧은 이름을 사용하도록 유도하기 때문에 저는 이 규칙을 좋아하지 않습니다. 예를 들어, 이 코드를 컴파일하려면 &lt;code>read&lt;/code>를 &lt;code>n&lt;/code>으로 변경해야 합니다. 제 생각에는 개발자가 가장 읽기 쉬운 이름을 더 좋은 위치에 두는 것이 좋습니다.&lt;/p>
&lt;h3 id="명명-규칙naming-convention">명명 규칙Naming Convention&lt;/h3>
&lt;p>컴파일러가 강제하는 규칙 외에도 원하는 명명 규칙을 자유롭게 따를 수 있습니다. 하지만 표준 라이브러리에서 타사 라이브러리에 이르기까지 상호 작용하게 될 대부분의 코드가 이 규칙을 사용하므로 Zig의 자체 명명 규칙을 이해하는 것이 도움이 됩니다.&lt;/p>
&lt;p>Zig의 소스 코드는 4개의 공백으로 들여쓰기되어 있습니다. 저는 개인적으로 탭을 사용하는데, 객관적으로 이 방식이 사용하기 쉽습니다.&lt;/p>
&lt;p>함수 이름은 camelCase, 변수는 소문자와 밑줄이 있는 소문자(일명 snake_ case)입니다. 타입은 PascalCase 입니다. 이 세 가지 규칙 사이에는 흥미로운 겹침이 있습니다. 타입을 참조하는 변수나 타입을 반환하는 함수는 타입 규칙을 따르며 PascalCase입니다. 이미 보셨겠지만 놓치셨을 수도 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{@TypeOf(.{.year &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2023&lt;/span>, .month &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>})});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리는 다른 내장 함수를 보았습니다: &lt;code>@import&lt;/code>, &lt;code>@rem&lt;/code> 및 &lt;code>@intCast&lt;/code> 입니다. 이것들은 함수이기 때문에 카멜 케이스입니다. &lt;code>@TypeOf&lt;/code>도 내장 함수이지만 왜 파스칼 케이스일까요? 타입을 반환하므로 타입 명명 규칙이 사용되기 때문입니다. Zig의 명명 규칙을 사용하여 &lt;code>@TypeOf&lt;/code>의 결과를 변수에 할당한다면, 그 변수 역시 파스칼 케이스가 되어야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> T &lt;span style="color:#f92672">=&lt;/span> @TypeOf(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{T});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>zig&lt;/code> 실행 파일에는 파일이나 디렉터리를 지정하면 Zig의 자체 스타일 가이드에 따라 파일 형식을 지정하는 &lt;code>fmt&lt;/code> 명령이 있습니다만 모든 것을 다루지는 않습니다. 예를 들어 들여쓰기와 괄호 위치는 조정하지만, 식별자의 대소문자는 변경하지 않습니다.&lt;/p>
&lt;h2 id="포인터">포인터&lt;/h2>
&lt;p>Zig 는 가비지 컬랙터를 가지고 있지 않습니다. 메모리 관리의 부담은 개발자에게 있습니다. 이것은 애플리케이션의 성능, 안정성 및 보안에 직접적인 영향을 미치므로 큰 책임이 따릅니다.&lt;/p>
&lt;p>우리는 포인터에 대해 얘기해 보겠습니다. 이것은 그 자체로 중요한 주제이지만, 우리의 프로그램 데이터를 메모리 중심으로 볼 수 있도록 훈련시키기 위해서도 중요합니다. 포인터, 힙 할당 및 댕글링 포인터에 익숙하다면 몇 가지 부분을 건너뛰고 Zig에 특화된 &lt;a href="https://www.openmymind.net/learning_zig/heap_memory/">힙 메모리 및 할당자&lt;/a> 부분으로 건너뛰어도 됩니다.&lt;/p>
&lt;hr>
&lt;p>다음 코드는 파워가 1인 사용자를 만들고, 그 사용자의 파워를 1 증가시키는 &lt;code>levelUp&lt;/code> 함수를 호출합니다. 어떤 결과가 나올지 예상할 수 있나요?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this line has been added
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> levelUp(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;User {d} has power of {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user.id, user.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.power &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기에는 함정이 있습니다. 이 코드는 컴파일되지 않아요: &lt;em>cannot assign to constant&lt;/em>. 우리는 파트 1에서 함수 매개변수가 상수라는 것을 보았습니다. 따라서 &lt;code>user.power += 1;&lt;/code> 는 유효하지 않습니다. 컴파일 타임 오류를 수정하려면 &lt;code>levelUp&lt;/code> 함수를 다음과 같이 변경할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> u &lt;span style="color:#f92672">=&lt;/span> user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u.power &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>컴파일은 되지만 출력은 &lt;em>User 1 has power of 100&lt;/em> 입니다. 우리 코드의 의도는 분명히 &lt;code>levelUp&lt;/code> 이 사용자의 파워를 &lt;code>101&lt;/code> 로 증가시키는 것입니다. 어떻게 된 일일까요?&lt;/p>
&lt;p>To understand, it helps to think about data with respect to memory, and variables as labels that associate a type with a specific memory location. For example, in &lt;code>main&lt;/code>, we create a &lt;code>User&lt;/code>. A simple visualization of this data in memory would be:
이 과정을 이해하기 위해 데이터를 메모리와 연계하여 생각하고, 변수를 특정 메모리 위치에 타입과 연결하는 레이블로 생각하는 것이 도움이 됩니다. 예를 들어, &lt;code>main&lt;/code> 에서 &lt;code>User&lt;/code>를 만듭니다. 이 데이터를 담은 메모리에 대해 간단히 시각화하면 다음과 같습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>user -&amp;gt; ------------ (id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------ (power)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>주목해야할 두 가지 사항이 있습니다. 첫 번째는 &lt;code>user&lt;/code> 변수가 구조체의 시작 부분을 가리킨다는 것입니다. 두 번째는 필드가 순차적으로 배치된다는 것입니다. &lt;code>user&lt;/code> 도 타입이 있다는 것을 기억하세요. 이 타입은 &lt;code>id&lt;/code> 가 64비트 정수이고 &lt;code>power&lt;/code> 가 32비트 정수라는 것을 알려줍니다. 데이터의 시작 위치에 대한 참조와 타입을 갖고 있으므로 컴파일러는 &lt;code>user.power&lt;/code> 를 &lt;em>시작 위치에서 64비트 떨어진 곳에 있는 32비트 정수에 접근&lt;/em> 으로 번역할 수 있습니다. 이것이 변수의 힘입니다. 변수는 메모리를 참조하고 메모리를 의미있게 이해하고 조작하는 데 필요한 타입 정보를 포함합니다.&lt;/p>
&lt;blockquote>
&lt;p>기본적으로, Zig는 구조체의 메모리 레이아웃에 대한 보장을 하지 않습니다. 필드를 알파벳 순서로, 크기가 증가하는 순서로 또는 적당한 간격을 두고 저장할 수 있습니다. 코드를 올바르게 번역할 수 있다면 컴파일러가 원하는 대로 할 수 있습니다. 이 유동적인 배치는 특정 최적화를 가능하게 할 수 있습니다. &lt;code>packed struct&lt;/code>를 선언하지 않으면 메모리 배치 순서에 대한 강력한 보장을 받을 수 없습니다. 그래도 &lt;code>user&lt;/code>의 시각화는 합리적이고 유용합니다.&lt;/p>
&lt;/blockquote>
&lt;p>다음은 메모리 주소를 포함하는 약간 다른 시각화입니다. 이 데이터의 시작 주소는 제가 임의로 정한 주소입니다. 이 주소는 &lt;code>user&lt;/code> 변수가 참조하는 메모리 주소이며, 첫 번째 필드인 &lt;code>id&lt;/code> 의 값입니다. 그러나 이 초기 주소가 주어지면 모든 후속 주소는 상대 주소를 알 수 있습니다. &lt;code>id&lt;/code> 가 64비트 정수이므로 8바이트의 메모리를 차지합니다. 따라서 &lt;code>power&lt;/code> 는 $start_address + 8 에 있어야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>user -&amp;gt; ------------ (id: 1043368d0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------ (power: 1043368d8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To verify this for yourself, I&amp;rsquo;d like to introduce the addressof operator: &lt;code>&amp;amp;&lt;/code>. As the name implies, the addressof operator returns the address of an variable (it can also return the address of a function, isn&amp;rsquo;t that something?!). Keeping the existing &lt;code>User&lt;/code> definition, try this &lt;code>main&lt;/code>:&lt;/p>
&lt;p>이를 직접 확인하기 위해 주소 연산자인 &lt;code>&amp;amp;&lt;/code> 를 소개하겠습니다. 이름에서 알 수 있듯이 주소 연산자는 변수의 주소를 반환합니다(함수의 주소도 반환할 수 있습니다. 대단하지 않나요?!). 기존의 &lt;code>User&lt;/code> 정의를 유지한 상태에서 다음 &lt;code>main&lt;/code> 코드를 사용해보세요:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{*}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">{*}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">{*}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{&lt;span style="color:#f92672">&amp;amp;&lt;/span>user, &lt;span style="color:#f92672">&amp;amp;&lt;/span>user.id, &lt;span style="color:#f92672">&amp;amp;&lt;/span>user.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드를 실행하면 &lt;code>user&lt;/code>, &lt;code>user.id&lt;/code> 및 &lt;code>user.power&lt;/code> 의 주소가 출력됩니다. 플랫폼 및 기타 요소에 따라 다른 결과가 나올 수 있지만, 아마도, &lt;code>user&lt;/code> 와 &lt;code>user.id&lt;/code> 의 주소가 동일하고 &lt;code>user.power&lt;/code> 가 8바이트 오프셋에 있는 것을 확인할 수 있습니다. 저는 다음과 같은 결과를 얻었습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>learning.User@1043368d0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>u64@1043368d0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>i32@1043368d8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!] &lt;code>learning&lt;/code> 은 사용자가 작성한 파일 이름으로 대체됩니다. 저자는 &lt;code>learning.zig&lt;/code> 라는 파일을 만들었습니다.&lt;/p>
&lt;/blockquote>
&lt;p>주소 연산자는 포인터를 값으로 반환합니다. 값에 대한 포인터는 고유한 타입입니다. &lt;code>T&lt;/code> 타입의 값에 대한 주소는 &lt;code>*T&lt;/code> 입니다. 이를 &lt;em>T에 대한 포인터&lt;/em> 라고 표현합니다. 따라서 &lt;code>user&lt;/code> 의 주소를 가져오면 &lt;code>*User&lt;/code> 또는 &lt;code>User&lt;/code> 에 대한 포인터를 얻게 됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> user_p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{@TypeOf(user_p)});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리의 처음 목표는 &lt;code>levelUp&lt;/code> 함수를 통해 사용자의 &lt;code>power&lt;/code> 를 1 증가시키는 것이었습니다. 코드는 컴파일되었지만 &lt;code>power&lt;/code> 를 출력하면 여전히 원래 값이었습니다. 다소 극단적인 예이긴 하지만, &lt;code>main&lt;/code> 과 &lt;code>levelUp&lt;/code> 에서 &lt;code>user&lt;/code> 의 주소를 출력하도록 코드를 변경해 봅시다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// added this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;main: {*}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{&lt;span style="color:#f92672">&amp;amp;&lt;/span>user});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> levelUp(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;User {d} has power of {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user.id, user.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// add this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;levelUp: {*}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{&lt;span style="color:#f92672">&amp;amp;&lt;/span>user});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> u &lt;span style="color:#f92672">=&lt;/span> user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u.power &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드를 실행해 보면, 두 개의 다른 주소가 출력됩니다. 이는 &lt;code>levelUp&lt;/code> 에서 수정되는 &lt;code>user&lt;/code> 가 &lt;code>main&lt;/code> 의 &lt;code>user&lt;/code> 와 다르다는 것을 의미합니다. 이는 Zig 가 levelUp 함수에 값을 복사해서 전달하기 때문에 발생합니다. 이는 기본적으로 이상하게 보일 수 있지만, 이렇게 하는 장점 중 하나는 함수를 호출하는 쪽에서는 함수가 매개변수를 수정하지 않을 것이라는 것을 확신할 수 있다는 것입니다(수정할 수 없으므로). 많은 경우, 이러한 기본값이 보장된다는 것은 좋은 일입니다. 물론 때로는 &lt;code>levelUp&lt;/code> 처럼 함수가 매개변수를 수정하길 원하는 경우도 있습니다. 이를 위해 &lt;code>levelUp&lt;/code> 이 &lt;code>main&lt;/code> 의 실제 &lt;code>user&lt;/code> 에서 작동하도록 해야 합니다. 이를 위해 함수에 &lt;code>user&lt;/code> 의 주소를 전달하면 됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// user -&amp;gt; &amp;amp;user
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> levelUp(&lt;span style="color:#f92672">&amp;amp;&lt;/span>user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;User {d} has power of {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user.id, user.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// User -&amp;gt; *User
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.power &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리는 두 곳을 변경해야 했습니다. 첫 번째는 &lt;code>levelUp&lt;/code> 을 &lt;code>user&lt;/code> 대신 &lt;code>&amp;amp;user&lt;/code> 로 호출하는 것입니다. 이는 함수가 더 이상 &lt;code>User&lt;/code> 를 받지 않고 &lt;code>*User&lt;/code> 를 받는다는 것을 의미합니다. 이것이 두 번째 변경 사항입니다.&lt;/p>
&lt;p>이제 코드가 의도한 대로 작동합니다. 여전히 함수 매개변수와 메모리 모델에는 많은 미묘한 점이 있지만, 우리는 진전을 이루고 있습니다. 이제 말씀드리고 싶은 것은, 구체적인 구문을 제외하고는 이 모든 것이 Zig 에만 해당하는 것은 아니라는 것입니다. 우리가 여기서 탐구하는 모델은 가장 일반적인 모델이며, 일부 언어는 개발자에게 많은 세부 사항과 유연성을 숨기기도 합니다.&lt;/p>
&lt;h3 id="메소드methods">메소드Methods&lt;/h3>
&lt;p>아마도 그동안, 여러분은 &lt;code>levelUp&lt;/code> 을 &lt;code>User&lt;/code> 구조체의 메소드로 작성했을 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.power &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 의문이 생깁니다: 포인터 수신자를 가진 메소드를 어떻게 호출할까요? 아마도 &lt;code>&amp;amp;user.levelUp()&lt;/code> 와 같은 것을 해야 할 것입니다. 다행히 실제로는 그냥 일반적으로 호출하면 됩니다. 즉, &lt;code>user.levelUp()&lt;/code> 입니다. Zig는 메소드가 포인터를 기대한다는 것을 알고 값을 올바르게 전달합니다(참조로).&lt;/p>
&lt;p>포인터를 설명하기 위해 초반에 함수를 선택한 이유는 함수가 명시적이어서 더 쉽게 배울 수 있기 때문이었습니다.&lt;/p>
&lt;h3 id="변하지-않는-함수-파라미터constant-function-parameters">변하지 않는 함수 파라미터Constant Function Parameters&lt;/h3>
&lt;p>저는 기본적으로 Zig가 값을 복사해서 전달한다(&amp;ldquo;pass by value&amp;rdquo; 라고 부릅니다)고 암시했습니다. 곧 우리는 현실이 조금 더 미묘하다는 것을 알게 될 것입니다(힌트: 중첩된 객체가 있는 복잡한 값은 어떻게 될까요?).&lt;/p>
&lt;p>단순한 타입을 고수하더라도, Zig는 코드의 의도가 보존되는 한 원하는 방식으로 매개변수를 전달할 수 있습니다. 우리의 원래 &lt;code>levelUp&lt;/code> 에서 매개변수는 &lt;code>User&lt;/code> 였으므로, Zig는 함수가 그것을 변형하지 않는다는 것을 보장할 수 있다면, user 의 복사본이나 &lt;code>main.user&lt;/code>에 대한 참조를 전달할 수 있습니다(궁극적으로는 우리는 변형을 원했지만 &lt;code>User&lt;/code> 타입을 만들면서 컴파일러에 변형을 원하지 않는다고 알린 것입니다).&lt;/p>
&lt;p>이러한 자유로움 덕분에 Zig는 매개변수 타입에 따라 가장 최적의 전략을 사용할 수 있습니다. &lt;code>User&lt;/code>와 같은 작은 타입은 값으로 전달(즉, 복사)하는 것이 비용이 적게 듭니다. 더 큰 타입은 참조로 전달하는 것이 더 저렴할 수 있습니다. Zig는 코드의 의도가 보존된다면 어떤 방식이든 사용할 수 있습니다. 어느 정도는 Zig가 상수 함수 매개변수 전략을 가지고 있기 때문에 가능합니다.&lt;/p>
&lt;p>이제 함수 매개변수가 상수인 이유 중 하나를 알게 되었습니다.&lt;/p>
&lt;p>어쩌면 여러분은 참조로 전달하는 것이 어떻게든 정말 작은 구조체를 복사하는 것보다 느릴 수 있다는 것에 대해 궁금해 할 것입니다. 다음에 더 명확하게 살펴 보겠지만, 요점은 포인터인 &lt;code>user&lt;/code> 를 사용할 때 &lt;code>user.power&lt;/code> 를 하는 것은 약간의 오버헤드를 추가한다는 것입니다. 컴파일러는 값을 복사하는 비용과 포인터를 통해 간접적으로 필드에 액세스하는 비용을 고려해야 합니다.&lt;/p>
&lt;h3 id="포인터의-포인터pointer-to-pointer">포인터의 포인터Pointer to Pointer&lt;/h3>
&lt;p>앞서 &lt;code>main&lt;/code> 함수 내의 &lt;code>user&lt;/code> 의 메모리가 어떻게 보이는지 살펴보았습니다. 이제 &lt;code>levelUp&lt;/code> 을 변경했으니 그 메모리는 어떻게 보일까요?:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>main:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user -&amp;gt; ------------ (id: 1043368d0) &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------ (power: 1043368d8) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------ |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. empty space |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. or other data |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>levelUp: |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user -&amp;gt; ------------- (*User) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1043368d0 |----------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>levelUp&lt;/code> 안에서 &lt;code>user&lt;/code> 는 &lt;code>User&lt;/code> 의 포인터입니다. 그 값은 주소입니다. 물론 어떤 주소든 가능한 것은 아니지만, &lt;code>main.user&lt;/code> 의 주소입니다. &lt;code>levelUp&lt;/code> 의 &lt;code>user&lt;/code> 변수가 구체적인 값을 나타낸다는 것을 명시하는 것이 가치가 있습니다. 이 값은 주소입니다. 그리고, 그것은 단순한 주소가 아닌 &lt;code>*User&lt;/code> 타입이기도 합니다. 모든 것이 매우 일관성 있습니다. 포인터에 대해 이야기하든 아니든 상관없습니다: 변수는 주소와 타입 정보를 연결합니다. 포인터의 유일한 특별한 점은, 예를 들어 &lt;code>user.power&lt;/code> 와 같은 점 표기법을 사용할 때, &lt;code>user&lt;/code> 가 포인터라는 것을 알고 있기 때문에 Zig 가 주소를 자동으로 따라가게 된다는 것입니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 변수가 구체적인 값과 타입 정보를 가지고 있다는 점 때문에 단순히 변수라고 통칭하는 대신 식별자라고 부르기도 합니다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>어떤 언어는 포인터를 통해 필드에 접근할 때 다른 기호를 요구합니다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>[!] 예를 들어 C 에서는 &lt;code>user-&amp;gt;power&lt;/code> 와 같이 &lt;code>-&amp;gt;&lt;/code> 기호를 사용합니다.&lt;/p>
&lt;/blockquote>
&lt;p>여기서 이해해야 할 중요한 점은 &lt;code>levelUp&lt;/code> 의 &lt;code>user&lt;/code> 변수 자체가 어떤 주소의 메모리에 존재한다는 것입니다. 이전과 마찬가지로 직접 확인할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{*}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">{*}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{&lt;span style="color:#f92672">&amp;amp;&lt;/span>user, user});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.power &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드는 &lt;code>user&lt;/code> 변수가 참조하는 주소와 그 값(즉, &lt;code>main&lt;/code> 에서의 &lt;code>user&lt;/code> 의 주소)을 출력합니다.&lt;/p>
&lt;p>만약 &lt;code>user&lt;/code> 가 &lt;code>*User&lt;/code> 라면, &lt;code>&amp;amp;user&lt;/code> 는 무엇일까요? &lt;code>**User&lt;/code> 이거나 &lt;code>User&lt;/code> 의 &lt;em>포인터를 가리키는 포인터&lt;/em>입니다. 메모리가 부족할 때까지 이렇게 할 수 있습니다!&lt;/p>
&lt;p>어떤 경우에는 여러 수준의 간접 참조가 필요한 경우가 있습니다. 하지만 지금은 필요하지 않습니다. 이 섹션의 목적은 포인터가 특별한 것이 아니라는 것을 보여주는 것입니다. 포인터는 주소와 타입으로 이루어진 값일 뿐입니다.&lt;/p>
&lt;h3 id="중첩된-포인터nested-pointers">중첩된 포인터Nested Pointers&lt;/h3>
&lt;p>지금까지 우리의 &lt;code>User&lt;/code> 는 두 개의 정수를 포함하는 간단한 구조체였습니다. 그것의 메모리를 시각화하는 것은 쉽고, &amp;ldquo;복사&amp;quot;에 대해 이야기할 때 모호함이 없습니다. 하지만 &lt;code>User&lt;/code>가 더 복잡해지고 포인터를 포함하면 어떻게 될까요?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리는 슬라이스 타입의 &lt;code>name&lt;/code> 을 추가했습니다. 되짚어 보자면 슬라이스는 길이와 포인터를 가집니다. &lt;code>user&lt;/code> 를 &lt;code>&amp;quot;Goku&amp;quot;&lt;/code> 로 초기화한다면 메모리에 어떻게 보일까요?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>user -&amp;gt; ------------- (id: 1043368d0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (power: 1043368d8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.len: 1043368dc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 4 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.ptr: 1043368e4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------| 1182145c0 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ............. empty space
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ............. or other data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ---&amp;gt; ------------- (1182145c0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;G&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;o&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;k&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;u&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>새 &lt;code>name&lt;/code> 필드는 &lt;code>len&lt;/code> 과 &lt;code>ptr&lt;/code> 필드로 구성된 슬라이스입니다. 이들은 다른 필드와 함께 순차적으로 배치됩니다. 64비트 플랫폼에서 &lt;code>len&lt;/code> 과 &lt;code>ptr&lt;/code> 모두 64비트 또는 8바이트일 것입니다. 흥미로운 부분은 &lt;code>name.ptr&lt;/code> 의 값입니다: 이것은 메모리의 다른 곳을 가리키는 주소입니다.&lt;/p>
&lt;blockquote>
&lt;p>우리는 문자열 리터럴을 사용했기 때문에 &lt;code>user.name.ptr&lt;/code> 는 컴파일된 바이너리 안의 모든 상수가 저장된 영역 내에서 특정 위치를 가리킵니다.&lt;/p>
&lt;/blockquote>
&lt;p>깊은 중첩을 사용하는 타입은 이보다 훨씬 복잡해질 수 있습니다. 하지만 간단하든 복잡하든 모두 동일하게 작동합니다. 특히, &lt;code>levelUp&lt;/code> 이 &lt;code>User&lt;/code> 를 받고 Zig 가 복사본을 제공하는 원래 코드로 돌아간다면, 중첩된 포인터를 가진 우리 코드는 어떻게 보일까요?&lt;/p>
&lt;p>정답은 값의 얕은 복사(shallow copy)만이 이루어진다는 것입니다. 다른 말로 하면, 변수가 직접 참조하는 메모리만 복사된다는 것입니다. &lt;code>levelUp&lt;/code> 이 &lt;code>user&lt;/code> 의 반쪽짜리 복사본을 얻을 것 같지만, 아마도 잘못된 &lt;code>name&lt;/code> 을 가진 것 같지만, 포인터(우리의 &lt;code>user.name.ptr&lt;/code>)는 값이고, 그 값은 주소입니다. 주소의 복사본은 여전히 같은 주소입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>main: user -&amp;gt; ------------- (id: 1043368d0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (power: 1043368d8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.len: 1043368dc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 4 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.ptr: 1043368e4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1182145c0 |-------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>levelUp: user -&amp;gt; ------------- (id: 1043368ec) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (power: 1043368f4) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.len: 1043368f8) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 4 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.ptr: 104336900) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1182145c0 |-------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. empty space |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. or other data |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (1182145c0) &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;G&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;o&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;k&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;u&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Our function can&amp;rsquo;t mutate the fields directly accessible by &lt;code>main.user&lt;/code> since it got a copy, but it does have access to the same &lt;code>name&lt;/code>, so can it mutate that? In this specific case, no, &lt;code>name&lt;/code> is a &lt;code>const&lt;/code>. Plus, our value &amp;ldquo;Goku&amp;rdquo; is a string literal which are always immutable. But, with a bit of work, we can see the implication of shallow copying:
위의 예에서, 얕은 복사가 작동함을 알 수 있습니다. 포인터의 값은 주소이므로, 값 복사는 동일한 주소를 얻게 됩니다. 이는 가변성에 관한 중요한 함의를 가집니다. 우리 함수는 복사본을 얻었기 때문에 &lt;code>main.user&lt;/code> 가 직접 액세스할 수 있는 필드를 수정할 수 없지만, 동일한 &lt;code>name&lt;/code> 에 액세스할 수 있으므로 수정할 수 있을까요? 안됩니다. &lt;code>name&lt;/code> 은 &lt;code>const&lt;/code> 입니다. 게다가, 우리의 문자열 리터럴인 &amp;ldquo;Goku&amp;quot;는 항상 불변입니다. 하지만, 조금의 작업을 통해 얕은 복사의 깊은 의미를 알 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">4&lt;/span>]&lt;span style="color:#66d9ef">u8&lt;/span>{&lt;span style="color:#e6db74">&amp;#39;G&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;k&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;u&amp;#39;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// slice it, [4]u8 -&amp;gt; []u8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .name &lt;span style="color:#f92672">=&lt;/span> name[&lt;span style="color:#ae81ff">0&lt;/span>..],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> levelUp(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user.name});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.name[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;!&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// []const u8 -&amp;gt; []u8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">u8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드는 &amp;ldquo;Go!u&amp;quot;를 출력합니다. 우리는 &lt;code>name&lt;/code>의 타입을 &lt;code>[]const u8&lt;/code>에서 &lt;code>[]u8&lt;/code>로 변경하고, 항상 불변인 문자열 리터럴 대신 배열을 만들고 슬라이스해야 했습니다. 일부 사람들은 여기에 일관성이 없다고 생각할 수 있습니다. 값으로 전달하면 함수가 직접 필드를 수정하지 못하지만, 포인터 뒤에 있는 값은 수정할 수 있습니다. 만약 우리가 &lt;code>name&lt;/code>을 불변으로 만들고 싶다면, &lt;code>[]u8&lt;/code> 대신 &lt;code>[]const u8&lt;/code>로 선언해야 합니다.&lt;/p>
&lt;p>어떤 언어는 다른 구현을 가지고 있지만, 많은 언어가 정확히 이렇게 작동합니다(또는 매우 유사합니다). 이 모든 것이 낯설게 느껴질 수 있지만, 일상적인 프로그래밍에는 기본적입니다. 좋은 소식은 간단한 예제와 코드 조각을 사용하여 이를 마스터할 수 있다는 것입니다. 시스템의 다른 부분이 복잡해지더라도 더 복잡해지지는 않는다는 것입니다.&lt;/p>
&lt;h3 id="재귀-구조체recursive-structures">재귀 구조체Recursive Structures&lt;/h3>
&lt;p>때로는 구조체가 자신의 구조를 사용해야 하는 경우도 있습니다. 기존 코드를 유지하면서, &lt;code>User&lt;/code>에 &lt;code>?User&lt;/code> 타입의 &lt;code>manager&lt;/code>를 추가해보겠습니다. 이와 동시에 두 개의 &lt;code>User&lt;/code>를 만들고 다른 하나를 다른 하나의 관리자로 지정해보겠습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> leto &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .manager &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> duncan &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .manager &lt;span style="color:#f92672">=&lt;/span> leto,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">{any}&amp;#34;&lt;/span>, .{leto, duncan});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> manager&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">?&lt;/span>User,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 컴파일되지 않습니다: &lt;em>struct &amp;rsquo;learning.User&amp;rsquo; depends on itself&lt;/em>. 이는 모든 타입이 컴파일 타임에 알려진 크기를 가져야 한다는 것 때문에 실패합니다.&lt;/p>
&lt;p>우리가 &lt;code>name&lt;/code> 을 추가하며 다른 길이의 이름을 가지더라도 이 문제를 겪지 않았습니다. 이 문제는 값의 크기가 아니라 타입 자체의 크기 때문에 발생합니다. Zig는 위에서 설명한 것과 같이 필드의 오프셋 위치를 기반으로 필드에 액세스하기 위해 이 정보가 필요합니다. &lt;code>name&lt;/code> 은 슬라이스, &lt;code>[]const u8&lt;/code> 이었고, 이는 알려진 크기를 가지고 있습니다: 16바이트로 &lt;code>len&lt;/code> 의 8바이트와 &lt;code>ptr&lt;/code> 의 8바이트입니다.&lt;/p>
&lt;p>아마 이것이 옵셔널이거나 공용체에 대한 문제일 것이라고 생각할 수 있습니다. 그러나 옵셔널과 공용체 모두 가능한 가장 큰 크기가 알려져 있고 Zig는 그것을 사용할 수 있습니다. 재귀 구조체는 이러한 상한선이 없습니다. 구조체는 한 번, 두 번 또는 수백만 번 재귀될 수 있습니다. 이 재귀 타입의 크기는 &lt;code>User&lt;/code> 의 &lt;code>User&lt;/code> 로 증가하며 컴파일 타임에 알 수 없습니다.&lt;/p>
&lt;p>우리는 &lt;code>name&lt;/code> 에서 답을 보았습니다: 포인터를 사용하세요. 포인터는 항상 &lt;code>usize&lt;/code> 바이트를 사용합니다. 64비트 플랫폼에서는 8바이트입니다. 실제 이름 &amp;ldquo;Goku&amp;quot;가 &lt;code>user&lt;/code> 와 함께 저장되지 않았던 것처럼, 포인터를 사용하면 Zig 의 메모리 관리자가 &lt;code>user&lt;/code> 의 메모리 레이아웃에 묶이지 않습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> leto &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .manager &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> duncan &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// changed from leto -&amp;gt; &amp;amp;leto
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .manager &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>leto,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">{any}&amp;#34;&lt;/span>, .{leto, duncan});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// changed from ?const User -&amp;gt; ?*const User
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> manager&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">?*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> User,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>어쩌면 여러분은 재귀 구조체가 필요하지 않을 수도 있지만, 이것은 데이터 모델링에 관한 것이 아닙니다. 포인터와 메모리 모델을 이해하고 컴파일러가 무엇을 하는지 더 잘 이해하기 위한 것입니다.&lt;/p>
&lt;hr>
&lt;p>많은 개발자들이 포인터에 어려움을 겪는데, 포인터에는 이해하기 어려운 부분이 있을 수 있습니다. 정수나 문자열 또는 &lt;code>User&lt;/code> 와 같이 구체적으로 느껴지지 않기 때문입니다. 이 모든 것이 명확하지 않아도 앞으로 나아갈 수 있습니다. 하지만 이것은 마스터할 가치가 있습니다. 그리고 Zig에만 해당하는 것이 아닙니다. 이러한 세부 사항은 Ruby, Python 및 JavaScript와 같은 언어에서 숨겨질 수 있지만, C#, Java 및 Go와 같은 언어에서는 그렇지 않습니다. 따라서 코드를 작성하는 방식과 코드가 실행되는 방식에 영향을 미칩니다. 따라서 시간을 들여서 예제를 살펴보고 변수와 주소를 확인하기 위해 디버그 출력문을 추가하세요. 더 많이 탐색할수록 더 명확해질 것입니다.&lt;/p>
&lt;h2 id="스택-메모리stack-memory">스택 메모리Stack Memory&lt;/h2>
&lt;p>포인터를 자세히 살펴봄으로써 변수, 데이터 및 메모리 간의 관계에 대한 통찰력을 얻었습니다. 그래서 우리는 메모리가 어떻게 보이는지에 대한 감을 잡았지만, 데이터와, 이에 따라 메모리가 어떻게 관리되는지에 대해서는 아직 이야기하지 않았습니다. 짧은 수명의 간단한 스크립트의 경우, 이는 아마도 중요하지 않을 것입니다. 32GB 랩탑 시대에, 여러분은 프로그램을 시작하고, 몇 백 메가바이트의 RAM을 사용하여 파일을 읽고 HTTP 응답에 대해 구문 분석하고, 놀라운 일을 하고, 종료할 수 있습니다. 프로그램이 종료되면, OS는 프로그램에 할당한 메모리를 다른 용도로 사용할 수 있음을 알고 있습니다.&lt;/p>
&lt;p>하지만 며칠 또는 몇 달 또는 심지어 몇 년 동안 실행되는 프로그램의 경우, 메모리는 제한적이고 귀중한 자원이 되며, 아마도 동일한 컴퓨터에서 실행되는 다른 프로세스가 찾고 있을 것입니다. 프로그램이 종료되기를 기다리지 않고 메모리를 해제할 수 있는 단순한 방법이 없습니다. 이것은 가비지 컬렉터의 주요 역할입니다: 더 이상 사용되지 않는 데이터를 알고 그 메모리를 해제하는 것입니다. Zig에서는 여러분이 가비지 컬렉터입니다.&lt;/p>
&lt;p>여러분이 작성하는 대부분의 프로그램은 메모리의 세 가지 &amp;ldquo;영역&amp;quot;을 사용합니다. 첫 번째는 전역 공간으로, 문자열 리터럴을 비롯한 프로그램 상수가 저장되는 곳입니다. 모든 전역 데이터는 바이너리에 포함되어 있으며, 컴파일 타임(때로는 런타임)에 완전히 알려져 있으며 불변입니다. 이 데이터는 프로그램이 끝날 동안 존재하며, 더 많거나 적은 메모리가 필요하지 않습니다. 바이너리의 크기에 미치는 영향을 제외하고는, 이것은 전혀 걱정할 필요가 없습니다.&lt;/p>
&lt;p>메모리의 두 번째 영역은 호출 스택으로, 이번 파트의 주제입니다. 세 번째 영역은 힙이며, 다음 파트의 주제입니다.&lt;/p>
&lt;blockquote>
&lt;p>메모리 영역 간에 실제 물리적인 차이는 없으며, 이는 OS와 실행 파일에 의해 논리적으로 생성된 개념입니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="스택-프레임stack-frames">스택 프레임Stack Frames&lt;/h3>
&lt;p>지금까지 우리가 본 모든 데이터는 바이너리 또는 로컬 변수의 전역 데이터 섹션에 저장된 상수였습니다. &amp;ldquo;로컬&amp;quot;은 변수가 선언된 범위 내에서만 유효하다는 것을 의미합니다. Zig에서 범위는 중괄호, &lt;code>{ ... }&lt;/code>로 시작하고 끝납니다. 대부분의 변수는 함수(함수 매개변수 포함) 또는 &lt;code>if&lt;/code> 와 같은 제어 흐름 블록에 범위가 지정됩니다. 하지만 지금까지 살펴본 것처럼 임의의 블록을 생성하여 임의의 범위를 지정할 수 있습니다.&lt;/p>
&lt;p>이전 파트에서 우리는 &lt;code>main&lt;/code> 과 &lt;code>levelUp&lt;/code> 함수의 메모리를 시각화했는데, 각각 &lt;code>User&lt;/code>를 가지고 있었습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>main: user -&amp;gt; ------------- (id: 1043368d0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (power: 1043368d8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.len: 1043368dc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 4 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.ptr: 1043368e4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1182145c0 |-------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>levelUp: user -&amp;gt; ------------- (id: 1043368ec) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (power: 1043368f4) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.len: 1043368f8) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 4 | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.ptr: 104336900) |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1182145c0 |-------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. empty space |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. or other data |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (1182145c0) &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;G&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;o&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;k&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;u&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>levelUp&lt;/code> 이 &lt;code>main&lt;/code> 바로 뒤에 있는 이유가 있습니다: 이것은 &amp;ldquo;간소화된&amp;rdquo; 호출 스택입니다. 프로그램이 시작되면, &lt;code>main&lt;/code>과 그 로컬 변수는 호출 스택에 푸시됩니다. &lt;code>levelUp&lt;/code>이 호출되면, 매개변수와 모든 로컬 변수가 호출 스택에 이어서 푸시됩니다. 중요한 것은 &lt;code>levelUp&lt;/code>이 반환되면, 스택에서 팝됩니다. &lt;code>levelUp&lt;/code>이 반환되고 제어가 &lt;code>main&lt;/code>으로 돌아오면, 호출 스택은 다음과 같이 보입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>main: user -&amp;gt; ------------- (id: 1043368d0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (power: 1043368d8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 100 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.len: 1043368dc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 4 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (name.ptr: 1043368e4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | 1182145c0 |-------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. empty space |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ............. or other data |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ------------- (1182145c0) &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;G&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;o&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;k&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | &amp;#39;u&amp;#39; |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>함수가 호출되면 해당 함수의 전체 스택 프레임이 호출 스택에 푸시됩니다. 이것은 우리가 모든 타입의 크기를 알아야 하는 이유 중 하나입니다. 아마 특정 코드 줄이 실행될 때까지 사용자의 이름 길이를 모를 수 있지만(상수 문자열 리터럴이 아니라고 가정한다면), 우리는 우리 함수가 &lt;code>User&lt;/code>를 가지고 있고, 다른 필드 더불어 &lt;code>name.len&lt;/code> 에 8바이트, &lt;code>name.ptr&lt;/code> 에 8바이트가 필요하다는 것을 알고 있습니다.&lt;/p>
&lt;p>함수가 반환되면, 호출 스택에 마지막으로 푸시된 함수의 스택 프레임이 팝됩니다. 놀라운 일이 일어났습니다: &lt;code>levelUp&lt;/code> 이 사용한 메모리가 자동으로 해제되었습니다! 엄밀히 말하면, 그 메모리는 OS에 반환될 수 있지만, 제가 알고 있는 한, 실제로 호출 스택을 축소하는 구현은 없습니다(물론 필요하면 동적으로 스택을 늘릴 수는 있습니다). 하지만, &lt;code>levelUp&lt;/code>의 스택 프레임을 저장하는 데 사용된 메모리는 이제 다른 스택 프레임을 위해 우리 프로세스 내에서 사용할 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>일반적인 프로그램에서는 호출 스택이 상당히 커질 수 있습니다. 일반적인 프로그램에서 사용하는 모든 프레임워크 코드와 라이브러리 사이에 함수가 깊게 중첩되어 있기 때문입니다. 일반적으로, 이것은 문제가 되지 않지만, 때때로 스택 오버플로 오류를 겪을 수 있습니다. 이것은 우리의 호출 스택이 공간을 모두 사용했을 때 발생합니다. 대부분의 경우, 이것은 재귀 함수(자기 자신을 호출하는 함수)에서 발생합니다.&lt;/p>
&lt;/blockquote>
&lt;p>글로벌 데이터와 마찬가지로 호출 스택은 OS와 실행 파일에 의해 관리됩니다. 프로그램이 시작되고, 그 후에 시작하는 각 스레드마다 호출 스택이 생성됩니다(이 스택의 크기는 일반적으로 OS에서 구성할 수 있음). 호출 스택은 프로그램의 수명 동안 또는 스레드의 경우 스레드의 수명 동안 존재합니다. 프로그램 또는 스레드가 종료되면 호출 스택이 해제됩니다. 하지만 글로벌 데이터에는 프로그램의 모든 글로벌 데이터가 있는 반면, 호출 스택에는 현재 실행 중인 함수 계층 구조에 대한 스택 프레임만 있습니다. 이는 메모리 사용량 측면에서 효율적일 뿐만 아니라 스택 프레임을 스택에 넣거나 뺄 수 있는 단순성 측면에서도 효율적입니다.&lt;/p>
&lt;h3 id="댕글링-포인터dangling-pointers">댕글링 포인터Dangling Pointers&lt;/h3>
&lt;p>호출 스택은 단순성과 효율성 모두에서 놀랍습니다. 하지만 두려움도 있습니다: 함수가 반환되면, 그 함수의 로컬 데이터는 더 이상 액세스할 수 없습니다. 이것은 합리적으로 들릴 수 있습니다. 그것은 결국 &lt;em>로컬&lt;/em> 데이터이기 때문입니다. 하지만 심각한 문제를 야기할 수 있습니다. 다음 코드를 살펴보세요:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user1 &lt;span style="color:#f92672">=&lt;/span> User.init(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user2 &lt;span style="color:#f92672">=&lt;/span> User.init(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;User {d} has power of {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user1.id, user1.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;User {d} has power of {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user2.id, user2.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init(id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> power,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>언뜻 보기에는 다음과 같은 출력을 기대하는 것이 합리적입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>User 1 has power of 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>User 2 has power of 20
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>나는 다음과 같은 결과를 얻었습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>User 2 has power of 20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>User 9114745905793990681 has power of 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!] zig 0.11 x86_64-macos.13.6.1 에서 아래의 결과를 얻었습니다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>User 2 has power of 20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>User 2 has power of 20
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>당신은 아마 다른 결과를 얻을 수 있습니다. 하지만 제 출력을 기반으로, &lt;code>user1&lt;/code> 은 &lt;code>user2&lt;/code> 의 값을 상속받았고, &lt;code>user2&lt;/code> 의 값은 무의미합니다. 이 코드의 주요 문제는 &lt;code>User.init&lt;/code> 이 로컬 유저의 주소인 &lt;code>&amp;amp;user&lt;/code> 를 반환한다는 것입니다. 이것은 댕글링 포인터(dangling pointer)라고 불리며, 유효하지 않은 메모리를 참조하는 포인터입니다. 이것은 많은 세그폴트의 원인이 됩니다.&lt;/p>
&lt;p>호출 스택에서 스택 프레임이 팝되면, 그 메모리에 대한 모든 참조는 유효하지 않습니다. 그 메모리에 액세스하려고 시도한 결과는 정의되지 않음을 반환합니다. 아마도 말도 안되는 데이터를 얻거나 세그폴트가 발생할 것입니다. 우리는 나의 출력에서 어떤 의미를 찾아볼 수 있지만, 이는 우리가 원하거나 또는 신뢰할 수 있는 행동이 아닙니다.&lt;/p>
&lt;p>이런 유형의 버그에 대한 한 가지 도전 과제는 가비지 컬렉터가 있는 언어에서 위의 코드가 완벽하게 동작한다는 것입니다. 예를 들어 Go는 로컬 변수인 &lt;code>user&lt;/code>가 &lt;code>init&lt;/code> 함수 밖에서도 생존한다는 것을 감지하고 필요한 만큼 유효성을 보장합니다(Go가 이것을 어떻게 하는지는 구현 세부 사항이지만, 힙으로 데이터를 이동하는 것을 포함하여 몇 가지 옵션이 있습니다. 이것은 다음 파트에서 설명할 것입니다).&lt;/p>
&lt;p>또 다른 문제는 유감스럽게도 이것이 발견하기 어려운 버그가 될 수 있다는 것입니다. 위의 예에서, 우리는 분명히 로컬의 주소를 반환하고 있습니다. 하지만 이러한 동작은 중첩된 함수와 복잡한 데이터 유형 안에 숨어 있을 수 있습니다. 다음 미완성 코드에서 어떤 문제점을 발견하실 수 있나요?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> read() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> input &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> readUserInput();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Parser.parse(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Parser.parse&lt;/code> 가 반환하는 것이 무엇이든 &lt;code>input&lt;/code> 보다 오래 갑니다. 만약 &lt;code>Parser&lt;/code> 가 &lt;code>input&lt;/code> 의 참조를 가지고 있다면, 그것은 우리의 앱을 부수기 위해 기다리는 댕글링 포인터가 될 것입니다. 이상적으로, &lt;code>Parser&lt;/code> 가 &lt;code>input&lt;/code> 이 존재하는 동안 살아있어야 한다면, 그것의 복사본을 만들고 그 복사본은 자신의 수명에 묶여 있을 것입니다(다음 파트에서 더 자세히 설명합니다). 하지만 이 계약을 강제할 수 있는 것은 없습니다. &lt;code>Parser&lt;/code> 의 문서는 &lt;code>input&lt;/code> 에 대해 기대하는 것이나 그것으로 무엇을 하는지에 대해 알려줄 수 있습니다. 그것이 없다면, 우리는 코드를 파헤쳐서 알아내야 할 수도 있습니다.&lt;/p>
&lt;hr>
&lt;p>초기의 버그를 해결하는 가장 간단한 방법은 &lt;code>init&lt;/code> 을 &lt;code>*User&lt;/code>(&lt;code>User&lt;/code> 에 대한 포인터) 대신 &lt;code>User&lt;/code> 를 반환하도록 변경하는 것입니다. 그러면 &lt;code>return &amp;amp;user;&lt;/code> 대신 &lt;code>return user;&lt;/code> 를 할 수 있습니다. 하지만 항상 그렇지는 않습니다. 데이터는 종종 함수 범위의 엄격한 경계를 넘어서 존재해야 합니다. 이를 위해 다음 파트의 주제인 세 번째 메모리 영역인 힙이 있습니다.&lt;/p>
&lt;p>힙에 대해 자세히 알아보기 전, 이 가이드를 끝내기 전에 마지막으로 댕글링 포인터의 예제 하나를 더 보게 될 것입니다. 그때까지 우리는 언어의 충분한 부분을 다루어 조금 덜 복잡한 예제를 제공할 것입니다. 나는 이 주제를 다시 다루고 싶습니다. 가비지 컬렉터가 있는 언어에서 온 개발자들에게는 이것이 버그와 좌절감을 유발할 수 있기 때문입니다. 이것은 당신이 해결할 수 있는 것입니다. 데이터가 어디에 있고 언제 존재하는지를 알고 있어야 합니다.&lt;/p>
&lt;h2 id="힙-메모리와-메모리-할당자">힙 메모리와 메모리 할당자&lt;/h2>
&lt;p>지금까지 우리가 살펴 본 모든 것은 미리 크기를 지정해야 한다는 제약 조건을 가지고 있었습니다. 배열은 항상 컴파일 타임에 알려진 길이를 가지고 있습니다(사실 길이는 타입의 일부입니다). 우리가 본 모든 문자열은 컴파일 타임에 알려진 문자열 리터럴이었습니다.&lt;/p>
&lt;p>또한 지금까지 살펴본 두 가지 메모리 관리 전략인 글로벌 데이터와 호출 스택은 간단하고 효율적이지만, 제한적입니다. 두 가지 모두 동적으로 크기가 조정된 데이터를 처리할 수 없으며, 데이터 수명과 관련하여 경직되어 있습니다.&lt;/p>
&lt;p>이 부분은 두 테마로 구성됩니다. 첫 번째는 우리의 세 번째 메모리 영역인 힙에 대한 일반적인 개요입니다. 다른 하나는 힙 메모리를 관리하는 Zig의 간단하지만 독특한 접근 방식입니다. C의 &lt;code>malloc&lt;/code> 을 사용해 힙 메모리에 익숙하시더라도 첫 번째 부분은 Zig에 매우 특화되어 있기 때문에 읽어보시는 것이 좋습니다.&lt;/p>
&lt;h3 id="힙the-heap">힙The Heap&lt;/h3>
&lt;p>힙은 우리가 마음대로 사용할 수 있는 세 번째이자 마지막 메모리 영역입니다. 글로벌 데이터와 호출 스택에 비해 힙은 무엇이든 할 수 있는 황무지와도 같습니다. 특히 힙에서는 런타임에 알려진 크기로 런타임에 메모리를 생성하고 그 수명을 완벽하게 제어할 수 있습니다.&lt;/p>
&lt;p>호출 스택은 스택 프레임을 푸시하고 팝하는 방식으로 데이터를 관리하는 간단하고 예측 가능한 방식 때문에 놀랍습니다. 이 장점은 단점이기도 합니다: 데이터의 수명은 콜 스택에 있는 데이터의 위치에 묶여 있습니다. 힙은 정확히 반대입니다. 내장된 수명 주기가 없으므로 데이터는 필요한 만큼 오래 살 수 있습니다. 이 장점은 단점이기도 합니다: 내장된 수명 주기가 없으므로 우리가 스스로 데이터를 해제하지 않으면 아무도 해제하지 않습니다.&lt;/p>
&lt;p>예제를 살펴보겠습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we&amp;#39;ll be talking about allocators shortly
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ** The next two lines are the important ones **
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(&lt;span style="color:#66d9ef">usize&lt;/span>, &lt;span style="color:#66d9ef">try&lt;/span> getRandomCount());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> allocator.free(arr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>..arr.len) &lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr[i] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{arr});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> getRandomCount() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> seed&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> std.os.getrandom(std.mem.asBytes(&lt;span style="color:#f92672">&amp;amp;&lt;/span>seed));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> random &lt;span style="color:#f92672">=&lt;/span> std.rand.DefaultPrng.init(seed);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> random.random().uintAtMost(&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리는 곧 Zig 할당자에 대해 곧 다루겠지만, 지금은 &lt;code>allocator&lt;/code> 가 &lt;code>std.mem.Allocator&lt;/code> 인 것만 알아두세요. 우리는 두 가지 메서드를 사용하고 있습니다: &lt;code>alloc&lt;/code> 과 &lt;code>free&lt;/code>. &lt;code>allocator.alloc&lt;/code> 을 &lt;code>try&lt;/code> 와 함께 호출하기 때문에, 우리는 그것이 실패할 수 있다는 것을 알고 있습니다. 현재, 유일한 가능한 오류는 &lt;code>OutOfMemory&lt;/code> 입니다. 이 함수의 매개변수는 대부분 그것이 어떻게 작동하는지를 알려줍니다: 타입(&lt;code>T&lt;/code>)과 카운트를 원하고, 성공하면 &lt;code>[]T&lt;/code> 의 슬라이스를 반환합니다. 이 할당은 런타임에 발생합니다 - 런타임에만 카운트가 알려져 있기 때문입니다.&lt;/p>
&lt;p>일반적으로 모든 &lt;code>alloc&lt;/code> 은 대응하는 &lt;code>free&lt;/code> 가 있습니다. &lt;code>alloc&lt;/code>은 메모리를 할당하고, &lt;code>free&lt;/code>는 메모리를 해제합니다. 이 간단한 코드가 여러분의 상상력을 제한하지 않도록 하세요. 이 &lt;code>try alloc&lt;/code> + &lt;code>defer free&lt;/code> 패턴은 흔히 볼 수 있으며, 여기에는 그럴만한 좋은 이유가 있습니다: 할당하는 위치에 가까이 해제하는 코드를 두는 것이 비교적 무난합니다. 하지만 한 곳에서 할당하고 다른 한 곳에서 해제하는 것도 마찬가지로 흔합니다. 우리가 말했듯이, 힙에는 내장된 수명 주기 관리가 없습니다. HTTP 핸들러에서 메모리를 할당하고, 이 코드의 완전히 다른 부분인 백그라운드 스레드에서 해제할 수 있습니다.&lt;/p>
&lt;h3 id="defer-와-errdefer">defer 와 errdefer&lt;/h3>
&lt;p>짧게 돌아보면, 위의 코드는 새로운 언어 기능을 소개했습니다: &lt;code>defer&lt;/code> 는 주어진 코드 또는 블록의 범위가 끝날 때 실행합니다. &amp;ldquo;Scope 종료&amp;quot;는 스코프의 끝에 도달하거나 해당 범위 안에서 반환하는 것을 포함합니다. &lt;code>defer&lt;/code> 는 할당자나 메모리 관리와 엄격하게 관련이 없습니다; 어떤 코드든 실행할 수 있습니다. 하지만 위의 사용법이 일반적으로 흔합니다.&lt;/p>
&lt;p>Zig의 defer는 Go와 비슷하지만 한 가지 큰 차이점이 있습니다. Zig에서는 defer가 포함된 범위의 끝에서 실행됩니다. Go에서는 defer가 포함된 함수의 끝에서 실행됩니다. Zig의 접근 방식은 Go 개발자가 아니라면 그리 놀랍지 않을 것입니다.&lt;/p>
&lt;p>&lt;code>defer&lt;/code> 의 상대적인 개념으로 &lt;code>errdefer&lt;/code> 가 있는데, 이 역시 마찬가지로 주어진 코드나 블록을 범위 종료 시 실행되지만, 오류가 반환될 때만 실행합니다. 이것은 더 복잡한 설정을 수행하거나 오류로 인해 이전 할당을 취소해야 할 때 유용합니다.&lt;/p>
&lt;p>The following example is a jump in complexity. It showcases both &lt;code>errdefer&lt;/code> and a common pattern that sees &lt;code>init&lt;/code> allocating and &lt;code>deinit&lt;/code> freeing:
다음 예제는 복잡성이 급증한 예시입니다. &lt;code>errdefer&lt;/code> 와 함께 &lt;code>init&lt;/code> 이 할당하고 &lt;code>deinit&lt;/code> 이 해제하는 일반적인 패턴을 모두 보여줍니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Allocator &lt;span style="color:#f92672">=&lt;/span> std.mem.Allocator;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> Game &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> players&lt;span style="color:#f92672">:&lt;/span> []Player,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> history&lt;span style="color:#f92672">:&lt;/span> []Move,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator&lt;span style="color:#f92672">:&lt;/span> Allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator, player_count&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>) &lt;span style="color:#f92672">!&lt;/span>Game {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> players &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(Player, player_count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">errdefer&lt;/span> allocator.free(players);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// store 10 most recent moves per player
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> history &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(Move, player_count &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .players &lt;span style="color:#f92672">=&lt;/span> players,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .history &lt;span style="color:#f92672">=&lt;/span> history,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .allocator &lt;span style="color:#f92672">=&lt;/span> allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> deinit(game&lt;span style="color:#f92672">:&lt;/span> Game) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> game.allocator;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator.free(game.players);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator.free(game.history);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 두 가지를 강조했으면 좋겠네요. 첫째, &lt;code>errdefer&lt;/code> 의 유용성입니다. 일반적인 상황에서 &lt;code>players&lt;/code> 는 &lt;code>init&lt;/code> 에서 할당되고 &lt;code>deinit&lt;/code> 에서 해제됩니다. 하지만 &lt;code>history&lt;/code> 의 초기화가 실패하는 예외적인 경우가 있습니다. 이 경우에는 오직 &lt;code>players&lt;/code> 의 할당만 취소해야 합니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] &lt;code>players&lt;/code> 는 할당은 성공했고, &lt;code>history&lt;/code> 의 할당은 실패했기 때문에 해제해야 할 것이 없기 때문입니다.&lt;/p>
&lt;/blockquote>
&lt;p>이 코드에서 두 번째로 주목할 점은 동적으로 할당된 두 슬라이스인 &lt;code>players&lt;/code> 와 &lt;code>history&lt;/code> 의 수명이 우리의 애플리케이션 로직에 기반한다는 것입니다. &lt;code>deinit&lt;/code> 을 언제 호출해야 하는지 또는 누가 호출해야 하는지를 규정하는 규칙은 없습니다. 이것은 임의의 수명을 제공하기 때문에 좋지만, &lt;code>deinit&lt;/code> 을 호출하지 않거나 한 번 이상 호출하여 프로그램을 망칠 수도 있기 때문에 좋지 않습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>init&lt;/code> 과 &lt;code>deinit&lt;/code> 이라는 이름은 특별한 것이 아닙니다. 그것들은 Zig 표준 라이브러리가 사용하고 커뮤니티가 채택한 것일 뿐입니다. 경우에 따라 표준 라이브러리를 포함해 &lt;code>open&lt;/code> 과 &lt;code>close&lt;/code> 또는 다른 더 적절한 이름을 사용하기도 합니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="중복-해제와-메모리-누수double-free--memory-leaks">중복 해제와 메모리 누수Double Free &amp;amp; Memory Leaks&lt;/h3>
&lt;p>바로 위에서, 나는 무언가가 해제되어야 하는 시점을 규정하는 규칙이 없다고 언급했습니다. 하지만 이는 전적으로 사실이 아니며, 몇 가지 중요한 규칙이 있지만, 단지 여러분의 세심한 주의 없이 강제되지 않을 뿐입니다.&lt;/p>
&lt;p>첫 번째 규칙은 같은 메모리를 두 번 해제할 수 없다는 것입니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(&lt;span style="color:#66d9ef">usize&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator.free(arr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator.free(arr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;This won&amp;#39;t get printed&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드의 마지막 줄은 예측이므로 출력되지 않습니다. 이것은 같은 메모리를 두 번 &lt;code>free&lt;/code> 하기 때문입니다. 이것은 double-free 라고 알려져 있으며 잘못된 동작입니다. 이것은 피하기에 충분히 간단해 보일 수 있지만, 복잡한 수명을 가진 큰 프로젝트에서는 추적하기 어려울 수 있습니다.&lt;/p>
&lt;p>두 번째 규칙은 참조가 없는 메모리를 해제할 수 없다는 것입니다. 당연하게 들릴 수도 있지만, 누가 메모리를 해제할 책임이 있는지는 항상 명확하지 않습니다. 다음은 새로운 소문자 문자열을 생성합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Allocator &lt;span style="color:#f92672">=&lt;/span> std.mem.Allocator;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> allocLower(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator, str&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>) &lt;span style="color:#f92672">!&lt;/span>[]&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> dest &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(&lt;span style="color:#66d9ef">u8&lt;/span>, str.len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (str, &lt;span style="color:#ae81ff">0&lt;/span>..) &lt;span style="color:#f92672">|&lt;/span>c, i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dest[i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>...&lt;span style="color:#e6db74">&amp;#39;Z&amp;#39;&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> c &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> c,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위의 코드는 괜찮습니다. 하지만 다음 사용법은 그렇지 않습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// For this specific code, we should have used std.ascii.eqlIgnoreCase
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> isSpecial(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator, name&lt;span style="color:#f92672">:&lt;/span> [] &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> lower &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocLower(allocator, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std.mem.eql(&lt;span style="color:#66d9ef">u8&lt;/span>, lower, &lt;span style="color:#e6db74">&amp;#34;admin&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이것이 메모리 누수입니다. &lt;code>allocLower&lt;/code> 에서 생성된 메모리는 해제되지 않습니다. 그것만이 아니라, &lt;code>isSpecial&lt;/code> 이 반환되면 절대 해제될 수 없습니다. 가비지 컬렉터가 있는 언어에서는 데이터에 도달할 수 없게 되면, 언젠가 가비지 컬렉터에 의해 해제됩니다. 하지만 위의 코드에서 &lt;code>isSpecial&lt;/code> 이 반환되면, 할당된 메모리에 대한 유일한 참조인 &lt;code>lower&lt;/code> 변수를 잃습니다. 메모리는 프로세스가 종료될 때까지 회수되지 못합니다. 우리의 함수는 몇 바이트만 누수할 수 있지만, 이것이 오래 실행되는 프로세스이고 이 함수가 반복적으로 호출된다면, 결국 메모리가 부족해질 것입니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 함수 결과가 반환되면 콜 스택에서 호출된 함수에서 사용된 지역 변수들이, 메모리가 할당된 레퍼런스를 포함하여 사라지기(스택에서 자동으로 팝되기) 때문입니다. 해제할 참조가 없어지는 것입니다.&lt;/p>
&lt;/blockquote>
&lt;p>최소한 double free 의 경우, 우리는 하드 크래시를 얻을 것입니다. 메모리 누수는 교묘하게 일어날 수 있습니다. 근본 원인을 식별하기 어려울 수 있다는 것만이 아닙니다. 아주 작은 누수나 드물게 실행되는 코드의 누수는 더 어려울 수 있습니다. 이는 매우 흔한 문제이기 때문에 Zig가 도움을 제공하는데, 이는 할당자에 대해 이야기할 때 살펴볼 것입니다.&lt;/p>
&lt;h3 id="create-와-destroy">create 와 destroy&lt;/h3>
&lt;p>&lt;code>std.mem.Allocator&lt;/code> 의 &lt;code>alloc&lt;/code> 메서드는 2번째 매개변수로 전달된 길이를 가진 슬라이스를 반환합니다. 하나의 값만 사용 한다면, &lt;code>alloc&lt;/code> 과 &lt;code>free&lt;/code> 대신 &lt;code>create&lt;/code> 과 &lt;code>destroy&lt;/code> 를 사용하면 됩니다. 얼마 전, 포인터에 대해 배우면서, 우리는 &lt;code>User&lt;/code> 를 생성하고 그의 힘을 증가시키려고 시도했습니다. 여기 &lt;code>create&lt;/code> 를 사용한 힙 기반 버전의 코드입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// again, we&amp;#39;ll talk about allocators soon!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// create a User on the heap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.create(User);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// free the memory allocated for the user at the end of this scope
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">defer&lt;/span> allocator.destroy(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this line has been added
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> levelUp(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;User {d} has power of {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{user.id, user.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> levelUp(user&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>User) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.power &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>create&lt;/code> 메소드는 하나의 매개변수인 타입(&lt;code>T&lt;/code>)을 받습니다. 그것은 그 타입의 포인터 또는 오류를 반환합니다. 즉, &lt;code>!*T&lt;/code> 입니다. 아마도 우리가 &lt;code>user&lt;/code> 를 생성했지만 &lt;code>id&lt;/code> 와/또는 &lt;code>power&lt;/code> 를 설정하지 않으면 어떻게 될지 궁금할 것입니다. 이는 그 필드들을 &lt;code>undefined&lt;/code> 로 설정하는 것과 같으며, 그 동작은, 역시, 정의되지 않음입니다.&lt;/p>
&lt;p>우리가 댕글링 포인터를 살펴볼 때, 지역변수 user 의 잘못된 주소를 반환하는 함수가 있었습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init(id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> power,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this is a dangling pointer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 경우, &lt;code>User&lt;/code> 를 반환하는 것이 더 합리적이었을 수도 있습니다. 하지만 때로는 함수가 생성하는 것에 대한 포인터를 반환하고 싶을 것입니다. 이것은 콜 스택의 엄격함으로부터 자유로운 수명을 원할 때 사용할 것입니다. 위의 댕글링 포인터를 해결하기 위해, 우리는 &lt;code>create&lt;/code> 를 사용할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// our return type changed, since init can now fail
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// *User -&amp;gt; !*User
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> init(allocator&lt;span style="color:#f92672">:&lt;/span> std.mem.Allocator, id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>, power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>) &lt;span style="color:#f92672">!*&lt;/span>User{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.create(User);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">=&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> power,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>user.* = .{...}&lt;/code> 형태의 문법을 소개합니다. 조금 이상하고, 그닥 좋아하지 않지만, 그래도 종종 볼 것입니다. 오른쪽 부분은 이미 보았던 것입니다: 추론된 타입을 가진 구조체 초기화입니다. 우리는 명시적으로 &lt;code>user.* = User{...}&lt;/code> 를 사용할 수 있습니다. 왼쪽의 &lt;code>user.*&lt;/code> 는 포인터를 역참조하는 방법입니다. &lt;code>&amp;amp;&lt;/code> 는 &lt;code>T&lt;/code> 를 가져와서 &lt;code>*T&lt;/code> 를 반환합니다. &lt;code>.*&lt;/code> 는 반대로, &lt;code>*T&lt;/code> 타입의 값에 적용되어 &lt;code>T&lt;/code> 를 반환합니다. &lt;code>create&lt;/code> 는 &lt;code>!*User&lt;/code> 를 반환하므로, 우리의 &lt;code>user&lt;/code> 는 &lt;code>*User&lt;/code> 타입입니다.&lt;/p>
&lt;h3 id="allocatorshttpswwwopenmymindnetlearning_zigheap_memoryallocators">&lt;a href="https://www.openmymind.net/learning_zig/heap_memory/#allocators">Allocators&lt;/a>&lt;/h3>
&lt;p>Zig 의 핵심 원칙 중 하나는 &lt;em>숨겨진 메모리 할당이 없다&lt;/em> 입니다. 당신의 배경에 따라서는, 그것은 그다지 특별하지 않게 들릴 수도 있습니다. 하지만 표준 라이브러리의 &lt;code>malloc&lt;/code> 함수로 메모리를 할당 하는 C와는 완전히 대조적입니다. C 에서는 함수가 메모리를 할당하는지 여부를 알고 싶다면, 소스 코드를 읽고 &lt;code>malloc&lt;/code> 호출을 찾아야 합니다.&lt;/p>
&lt;p>Zig 는 디폴트 메모리 할당자가 없습니다. 위의 모든 예제에서 메모리를 할당하는 함수는 &lt;code>std.mem.Allocator&lt;/code> 매개변수를 가져왔습니다. 관례상, 이것은 일반적으로 첫 번째 매개변수입니다. Zig 의 표준 라이브러리와 대부분의 서드파티 라이브러리는 메모리를 할당하려면 호출자가 할당자를 제공해야 한다고 요구합니다.&lt;/p>
&lt;p>이 명시성은 두 가지 형태 중 하나를 취할 수 있습니다. 간단한 경우에는, 할당자는 각 함수 호출에 제공됩니다. 이에 대한 많은 예제가 있지만, &lt;code>std.fmt.allocPrint&lt;/code> 는 언젠가는 필요할 것입니다. 우리가 사용해온 &lt;code>std.debug.print&lt;/code> 와 유사하지만, stderr 에 쓰는 대신 문자열을 할당하고 반환합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> say &lt;span style="color:#f92672">=&lt;/span> std.fmt.allocPrint(allocator, &lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s over {d}!!!&amp;#34;&lt;/span>, .{user.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defer&lt;/span> allocator.free(say);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>또 다른 형태는 할당자가 &lt;code>init&lt;/code> 에 전달되고, 그런 다음 객체 내부에서 사용되는 경우입니다. 우리는 위에서 &lt;code>Game&lt;/code> 구조체를 사용했습니다. 이것은 덜 명시적입니다. 왜냐하면 당신은 객체가 사용할 할당자를 주었지만, 어떤 메서드 호출이 실제로 할당할지 알 수 없기 때문입니다. 이 접근 방식은 수명이 긴 객체에 더 적합합니다.&lt;/p>
&lt;p>메모리 할당자 주입의 장점은 명시성뿐만 아니라 유연성입니다. &lt;code>std.mem.Allocator&lt;/code> 는 &lt;code>alloc&lt;/code>, &lt;code>free&lt;/code>, &lt;code>create&lt;/code> 와 &lt;code>destroy&lt;/code> 함수를 비롯한 몇 가지 다른 함수를 제공하는 인터페이스입니다. 지금까지 우리는 &lt;code>std.heap.GeneralPurposeAllocator&lt;/code> 만 보았지만, 다른 구현체도 표준 라이브러리나 써드파티 라이브러리에 사용할 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>Zig 에는 인터페이스를 만드는 좋은 문법 설탕이 없습니다. 인터페이스 수명 동작에 대한 하나의 패턴은 태그된 유니온이지만, 이것은 진정한 인터페이스에 비해 비교적 제한적입니다. 다른 패턴도 등장하여 표준 라이브러리 전체에서 사용되고 있습니다. 예를 들어, &lt;code>std.mem.Allocator&lt;/code> 와 같습니다. 관심이 있다면, 저는 &lt;a href="https://www.openmymind.net/Zig-Interfaces/">인터페이스를 설명하는 별도의 블로그 포스트&lt;/a>를 썼습니다.&lt;/p>
&lt;/blockquote>
&lt;p>라이브러리를 구축하는 경우, &lt;code>std.mem.Allocator&lt;/code> 를 받고 사용자가 사용할 할당자 구현을 결정하도록 하는 것이 가장 좋습니다. 그렇지 않으면, 올바른 할당자를 선택해야 하는데, 우리가 볼 것처럼, 이들은 서로 배타적이지 않습니다. 프로그램 내에서 서로 다른 얼로케이터를 만들어야 하는 데는 그럴 만한 이유가 있을 수 있습니다.&lt;/p>
&lt;h3 id="범용-얼로케이터general-purpose-allocator">범용 얼로케이터General Purpose Allocator&lt;/h3>
&lt;p>이름에서 알 수 있듯이, &lt;code>std.heap.GeneralPurposeAllocator&lt;/code> 는 모든 것을 위한 &amp;ldquo;일반적인 목적&amp;quot;의, 스레드 안전한 얼로케이터로서 여러분의 애플리케이션의 메인 얼로케이터로 사용될 수 있습니다. 많은 프로그램에서, 이것은 유일하게 필요한 얼로케이터일 것입니다. 프로그램이 시작되면, 얼로케이터가 생성되고 필요한 함수에 전달됩니다. 이어지는 HTTP 서버 라이브러리의 샘플 코드는 좋은 예입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> httpz &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;httpz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// create our general purpose allocator
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// get an std.mem.Allocator from it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// pass our allocator to functions and libraries that require it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> httpz.Server().init(allocator, .{.port &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5882&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> router &lt;span style="color:#f92672">=&lt;/span> server.router();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> router.get(&lt;span style="color:#e6db74">&amp;#34;/api/user/:id&amp;#34;&lt;/span>, getUser);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// blocks the current thread
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> server.listen();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리는 &lt;code>GeneralPurposeAllocator&lt;/code> 를 생성하고, &lt;code>std.mem.Allocator&lt;/code> 를 얻고, HTTP 서버의 &lt;code>init&lt;/code> 함수에 전달합니다. 더 복잡한 프로젝트에서는, &lt;code>allocator&lt;/code> 는 코드의 여러 부분에 전달되고, 각각은 그것을 자신의 함수, 객체 및 이를 의존하는 곳에 전달할 수 있습니다.&lt;/p>
&lt;p>아마도 &lt;code>gpa&lt;/code> 의 생성 주위의 구문이 조금 이상하게 보일 수 있습니다. 이게 뭐죠: &lt;code>GeneralPurposeAllocator(.{}){}&lt;/code>? 우리가 본 모든 것들을 모아둔 것 뿐입니다. &lt;code>std.heap.GeneralPurposeAllocator&lt;/code> 는 함수이며, PascalCase 를 사용하고 있기 때문에, 우리는 그것이 타입을 반환한다는 것을 알고 있습니다. (다음 파트에서 제네릭에 대해 더 이야기할 것입니다). 타입을 반환한다는 것을 알면, 아마도 더 명확한 버전이 해독하기 쉬울 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> T &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> T{};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// is the same as:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>아직 &lt;code>.{}&lt;/code> 의 의미에 대해 잘 모를 수 있습니다. 이 또한 이전에 본 적이 있습니다: 이것은 암시적 타입을 가진 구조체 초기화 코드입니다. 타입은 무엇이고 필드는 어디에 있을까요? 타입은 &lt;code>std.heap.general_purpose_allocator.Config&lt;/code> 이지만, 직접 노출되지 않기 때문에 명시적이지 않습니다. 어떤 필드도 설정되지 않았습니다. 왜냐하면 &lt;code>Config&lt;/code> 구조체는 우리가 사용할 기본값을 정의하기 때문입니다. 이것은 구성 / 옵션과 같은 일반적인 패턴입니다. 사실, 우리는 &lt;code>.{.port = 5882}&lt;/code> 를 &lt;code>init&lt;/code> 에 전달할 때 다시 한 번 보게 됩니다. 이 경우, 우리는 &lt;code>port&lt;/code> 를 제외한 모든 필드에 대해 기본값을 사용합니다.&lt;/p>
&lt;h3 id="stdtestingallocator">std.testing.allocator&lt;/h3>
&lt;p>바라기는 우리가 메모리 누수에 대해 이야기하고, Zig 가 도움을 줄 수 있다고 언급했을 때, 충분히 고민하였고 더 배우고 싶어했을 것입니다. 이 도움은 &lt;code>std.testing.allocator&lt;/code> 에서 제공되며, 마찬가지로 &lt;code>std.mem.Allocator&lt;/code> 입니다. 현재, 이것은 &lt;code>GeneralPurposeAllocator&lt;/code> 를 사용하여 구현되었으며, Zig 의 테스트 러너에 통합되었지만, 이것은 구현에 대한 세부 사항입니다. 중요한 것은 우리가 테스트에서 &lt;code>std.testing.allocator&lt;/code> 를 사용한다면, 우리는 대부분의 메모리 누수를 잡을 수 있다는 것입니다.&lt;/p>
&lt;p>You&amp;rsquo;re likely already familiar with dynamic arrays, often called ArrayLists. In many dynamic programming languages all arrays are dynamic arrays. Dynamic arrays support a variable number of elements. Zig has a proper generic ArrayList, but we&amp;rsquo;ll create one specifically to hold integers and to demonstrate leak detection:
여러분은 이미 동적 배열에 익숙할 것입니다. 많은 동적 프로그래밍 언어에서 모든 배열은 동적 배열입니다. 동적 배열은 가변 길이의 요소를 지원합니다. Zig 에는 제대로 된 제네릭 ArrayList 가 있지만, 우리는 정수를 가지며 특별히 메모리 누수 감지를 보여주기 위한 예제를 하나를 만들 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> IntList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">i64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator&lt;span style="color:#f92672">:&lt;/span> Allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator) &lt;span style="color:#f92672">!&lt;/span>IntList {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .pos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .allocator &lt;span style="color:#f92672">=&lt;/span> allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .items &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(&lt;span style="color:#66d9ef">i64&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> deinit(self&lt;span style="color:#f92672">:&lt;/span> IntList) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.allocator.free(self.items);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> add(self&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>IntList, value&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i64&lt;/span>) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> pos &lt;span style="color:#f92672">=&lt;/span> self.pos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> self.items.len;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pos &lt;span style="color:#f92672">==&lt;/span> len) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we&amp;#39;ve run out of space
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// create a new slice that&amp;#39;s twice as large
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> larger &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> self.allocator.alloc(&lt;span style="color:#66d9ef">i64&lt;/span>, len &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// copy the items we previously added to our new space
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> @memcpy(larger[&lt;span style="color:#ae81ff">0&lt;/span>..len], self.items);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.items &lt;span style="color:#f92672">=&lt;/span> larger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.items[pos] &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.pos &lt;span style="color:#f92672">=&lt;/span> pos &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>흥미로운 부분은 &lt;code>add&lt;/code> 에서 &lt;code>pos == len&lt;/code> 이 되었을 때입니다. 이는 우리가 현재 배열을 채웠고 더 큰 배열을 생성해야 한다는 것을 나타냅니다. 우리는 다음과 같이 &lt;code>IntList&lt;/code> 를 사용할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Allocator &lt;span style="color:#f92672">=&lt;/span> std.mem.Allocator;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> IntList.init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> list.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>..&lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> list.add(@intCast(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{list.items[&lt;span style="color:#ae81ff">0&lt;/span>..list.pos]});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>코드가 실행되고 올바른 결과를 출력합니다. 하지만, 우리가 &lt;code>list&lt;/code> 에서 &lt;code>deinit&lt;/code> 를 호출했음에도 불구하고, 메모리 누수가 있습니다. 이것을 잡지 못했더라도 괜찮습니다. 우리는 테스트를 작성하고 &lt;code>std.testing.allocator&lt;/code> 를 사용할 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> testing &lt;span style="color:#f92672">=&lt;/span> std.testing;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">test&lt;/span> &lt;span style="color:#e6db74">&amp;#34;IntList: add&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We&amp;#39;re using testing.allocator here!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> IntList.init(testing.allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> list.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>..&lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> list.add(@intCast(i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> testing.expectEqual(@as(&lt;span style="color:#66d9ef">usize&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>), list.pos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> testing.expectEqual(@as(&lt;span style="color:#66d9ef">i64&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>), list.items[&lt;span style="color:#ae81ff">0&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> testing.expectEqual(@as(&lt;span style="color:#66d9ef">i64&lt;/span>, &lt;span style="color:#ae81ff">11&lt;/span>), list.items[&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> testing.expectEqual(@as(&lt;span style="color:#66d9ef">i64&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>), list.items[&lt;span style="color:#ae81ff">2&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> testing.expectEqual(@as(&lt;span style="color:#66d9ef">i64&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>), list.items[&lt;span style="color:#ae81ff">3&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> testing.expectEqual(@as(&lt;span style="color:#66d9ef">i64&lt;/span>, &lt;span style="color:#ae81ff">14&lt;/span>), list.items[&lt;span style="color:#ae81ff">4&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>@as&lt;/code> 는 타입 강제 변환을 수행하는 내장 함수입니다. 우리의 테스트에서 왜 이렇게 많이 사용해야 하는지 궁금하다면, 여러분만 그런 것은 아닙니다. 기술적으로는 두 번째 매개변수, &amp;ldquo;실제&amp;quot;가 첫 번째, &amp;ldquo;예상&amp;quot;으로 강제 변환되기 때문입니다. 위의 예에서, &amp;ldquo;예상&amp;quot;은 모두 &lt;code>comptime_int&lt;/code> 이므로 문제가 발생합니다. 저 포함, 많은 사람들 이를 &lt;a href="https://github.com/ziglang/zig/issues/4437">이상하고 불행한 행동&lt;/a>이라고 생각합니다.&lt;/p>
&lt;/blockquote>
&lt;p>코드를 따라가, 테스트를 &lt;code>IntList&lt;/code> 와 &lt;code>main&lt;/code> 과 같은 파일에 넣으세요. Zig 테스트는 보통 같은 파일에 작성되며, 종종 테스트하는 코드 근처에 있습니다. 우리가 &lt;code>zig test learning.zig&lt;/code> 를 사용하여 테스트를 실행하면, 놀라운 실패가 발생합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>Test [1/1] test.IntList: add... [gpa] (err): memory address 0x101154000 leaked:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/code/zig/learning.zig:26:32: 0x100f707b7 in init (test)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .items = try allocator.alloc(i64, 2),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/code/zig/learning.zig:55:29: 0x100f711df in test.IntList: add (test)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> var list = try IntList.init(testing.allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>... MORE STACK INFO ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[gpa] (err): memory address 0x101184000 leaked:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/code/test/learning.zig:40:41: 0x100f70c73 in add (test)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> var larger = try self.allocator.alloc(i64, len * 2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/code/test/learning.zig:59:15: 0x100f7130f in test.IntList: add (test)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> try list.add(@intCast(i+10));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기에는 여러 건의 메모리 누수가 있습니다. 다행히도 테스트 얼로케이터는 누수가 발생한 메모리가 어디에서 할당되었는지 정확하게 알려줍니다. 이제 누수를 찾을 수 있습니까? 그렇지 않다면, 일반적으로 모든 &lt;code>alloc&lt;/code> 은 대응하는 &lt;code>free&lt;/code> 가 있어야 한다는 것을 기억하세요. 우리의 코드는 &lt;code>deinit&lt;/code> 에서 한 번 &lt;code>free&lt;/code> 를 호출합니다. 그러나 &lt;code>init&lt;/code> 에서 한 번 호출되고, 그리고 더 많은 공간이 필요할 때마다 &lt;code>add&lt;/code> 가 호출되고, 우리는 더 많은 공간이 필요합니다. 우리가 더 많은 공간을 &lt;code>alloc&lt;/code> 할 때마다, 우리는 이전의 &lt;code>self.items&lt;/code> 를 &lt;code>free&lt;/code> 해야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// existing code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> larger &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> self.allocator.alloc(&lt;span style="color:#66d9ef">i64&lt;/span>, len &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@memcpy(larger[&lt;span style="color:#ae81ff">0&lt;/span>..len], self.items);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Added code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// free the previous allocation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>self.allocator.free(self.items);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드를 추가하면, &lt;code>larger&lt;/code> 슬라이스에 항목을 복사한 후, 문제가 해결됩니다. &lt;code>zig test learning.zig&lt;/code> 를 실행하면 오류가 없어야 합니다.&lt;/p>
&lt;h3 id="투기장-할당자arenaallocator">투기장 할당자ArenaAllocator&lt;/h3>
&lt;p>범용 얼로케이터는 모든 가능한 경우에 잘 작동하기 때문에 합리적인 기본값입니다. 하지만 프로그램 내에서는 더 특수한 얼로케이터에서 이점을 얻을 수 있는 할당 패턴이 있을 수 있습니다. 예를 들어, 처리가 완료되면 버려질 수 있는 짧은 수명의 상태가 필요할 때입니다. 파서는 종종 이러한 요구 사항을 가지고 있습니다. 스켈레톤 &lt;code>parse&lt;/code> 함수는 다음과 같을 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> parse(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator, input&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>) &lt;span style="color:#f92672">!&lt;/span>Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> state &lt;span style="color:#f92672">=&lt;/span> State{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">512&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .nesting &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(NestType, &lt;span style="color:#ae81ff">10&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> allocator.free(state.buf);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> allocator.free(state.nesting);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> parseInternal(allocator, state, input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>관리하기 그리 어렵지 않지만, &lt;code>parseInternal&lt;/code> 는 바로 해제해야 할 다른 짧은 수명의 할당이 필요할 수 있습니다. 대안으로, 우리는 한 번에 모든 할당을 해제할 수 있는 ArenaAllocator 를 만들 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> parse(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator, input&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>) &lt;span style="color:#f92672">!&lt;/span>Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// create an ArenaAllocator from the supplied allocator
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> arena &lt;span style="color:#f92672">=&lt;/span> std.heap.ArenaAllocator.init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this will free anything created from this arena
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">defer&lt;/span> arena.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// create an std.mem.Allocator from the arena, this will be
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// the allocator we&amp;#39;ll use internally
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> aa &lt;span style="color:#f92672">=&lt;/span> arena.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> state &lt;span style="color:#f92672">=&lt;/span> State{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we&amp;#39;re using aa here!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> aa.alloc(&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#ae81ff">512&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we&amp;#39;re using aa here!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .nesting &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> aa.alloc(NestType, &lt;span style="color:#ae81ff">10&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we&amp;#39;re passing aa here, so any we&amp;#39;re guaranteed that
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// any other allocation will be in our arena
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> parseInternal(aa, state, input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ArenaAllocator&lt;/code> 는 자식 할당자를 가져와서, 이 경우 &lt;code>init&lt;/code> 에 전달된 할당자를 가져와서 새로운 &lt;code>std.mem.Allocator&lt;/code> 를 만듭니다. 이 새로운 할당자가 메모리를 할당하거나 생성할 때, 우리는 &lt;code>free&lt;/code> 나 &lt;code>destroy&lt;/code> 를 호출할 필요가 없습니다. 우리가 &lt;code>arena&lt;/code> 에서 &lt;code>deinit&lt;/code> 을 호출할 때 모든 것이 해제될 것입니다. 사실, &lt;code>ArenaAllocator&lt;/code> 의 &lt;code>free&lt;/code> 와 &lt;code>destroy&lt;/code> 는 아무것도 하지 않습니다.&lt;/p>
&lt;p>&lt;code>ArenaAllocator&lt;/code> 는 신중하게 사용해야 합니다. 개별 할당을 해제할 수 있는 방법이 없기 때문에, 메모리가 합리적으로 증가되는 범위 내에서 &lt;code>deinit&lt;/code> 이 호출되는지 확인해야 합니다. 흥미롭게도, 그 지식은 내부적이거나 외부적일 수 있습니다. 예를 들어, 위의 스켈레톤에서는, 상태의 수명의 세부 사항은 내부적인 문제이므로 ArenaAllocator 를 활용하는 것이 합리적입니다.&lt;/p>
&lt;blockquote>
&lt;p>이전의 모든 할당을 해제하는 매커니즘을 가진 ArenaAllocator 와 같은 할당자는 모든 &lt;code>alloc&lt;/code> 에 대응하는 &lt;code>free&lt;/code> 가 있어야 한다는 규칙을 깰 수 있습니다. 어쨋든, 만약 여러분이 &lt;code>std.mem.Allocator&lt;/code> 를 받는다면, 여러분은 내부 구현에 대해 단정해서는 안됩니다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>IntList&lt;/code> 도 마찬가지 입니다. 10개 또는 1000만개의 값을 저장하는 데 사용될 수 있습니다. 몇 밀리초 또는 몇 주에 걸친 수명을 가질 수 있습니다. 이는 할당자의 타입을 결정할 수 있는 위치가 아닙니다. &lt;code>IntList&lt;/code> 를 사용하는 코드가 이 지식을 가지고 있습니다. 원래, 우리는 &lt;code>IntList&lt;/code> 를 다음과 같이 관리했습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> IntList.init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defer&lt;/span> list.deinit();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 우리는 ArenaAllocator 를 대신 제공할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> arena &lt;span style="color:#f92672">=&lt;/span> std.heap.ArenaAllocator.init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defer&lt;/span> arena.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> aa &lt;span style="color:#f92672">=&lt;/span> arena.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> IntList.init(aa);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// I&amp;#39;m honestly torn on whether or not we should call list.deinit.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Technically, we don&amp;#39;t have to since we call defer arena.deinit() above.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> list.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntList&lt;/code> 는 &lt;code>std.mem.Allocator&lt;/code> 를 다루기 때문에 변경할 필요가 없습니다. 그리고 &lt;code>IntList&lt;/code> 가 자체적으로 어레나를 생성한다면, 그것도 작동할 것입니다. 어레나 내에서 어레나를 생성할 수 없는 이유는 없습니다.&lt;/p>
&lt;p>마지막 간단한 예로, 위에서 언급한 HTTP 서버는 &lt;code>Response&lt;/code> 에서 어레나 얼로케이터를 노출합니다. 응답이 전송되면, 어레나는 지워집니다. 어레나의 예측 가능한 수명(요청 시작부터 요청 종료까지)은 효율적인 옵션으로 만듭니다. 성능과 사용의 편이성 측면에서 효율적입니다.&lt;/p>
&lt;h3 id="고정-버퍼-할당자fixedbufferallocator">고정 버퍼 할당자FixedBufferAllocator&lt;/h3>
&lt;p>마지막으로 살펴볼 할당자는 우리가 제공하는 버퍼(즉, &lt;code>[]u8&lt;/code>)에서 메모리를 할당하는 &lt;code>std.heap.FixedBufferAllocator&lt;/code> 입니다. 이 할당자에는 두 가지 주요 이점이 있습니다. 첫째, 사용할 수 있는 모든 메모리가 미리 생성되기 때문에 빠릅니다. 둘째, 자연스럽게 메모리 할당량을 제한합니다. 이 엄격한 제한은 단점으로도 볼 수 있습니다. 또 다른 단점은 &lt;code>free&lt;/code> 와 &lt;code>destroy&lt;/code> 가 마지막 할당/생성 항목에만 작동한다는 것입니다(스택을 생각하세요). 마지막이 아닌 할당을 해제하는 것은 안전하게 호출할 수 있지만, 아무것도 하지 않습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> buf&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">150&lt;/span>]&lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> fa &lt;span style="color:#f92672">=&lt;/span> std.heap.FixedBufferAllocator.init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> fa.reset();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> fa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> json &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> std.json.stringifyAlloc(allocator, .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .this_is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;an anonymous struct&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .above &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .last_param &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;are options&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, .{.whitespace &lt;span style="color:#f92672">=&lt;/span> .indent_2});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{json});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드는 다음을 출력합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;this_is&amp;#34;: &amp;#34;an anonymous struct&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;above&amp;#34;: true,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;last_param&amp;#34;: &amp;#34;are options&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>만약 우리의 &lt;code>buf&lt;/code> 를 &lt;code>[120]u8&lt;/code> 로 바꾼다면, &lt;code>OutOfMemory&lt;/code> 오류가 발생합니다.&lt;/p>
&lt;blockquote>
&lt;p>[!] 변환되는 문자와 메타 정보의 용량이 120 바이트를 초과하기 때문입니다.&lt;/p>
&lt;/blockquote>
&lt;p>고정 버퍼 할당자와, 그리고 그보다 덜하지만 어레나 할당자와 같은 경우, 일반적인 패턴은 &lt;code>reset&lt;/code> 을 사용하여 재사용하는 것입니다. 이것은 이전의 모든 할당을 해제하고 할당자를 재사용할 수 있도록 합니다.&lt;/p>
&lt;hr>
&lt;p>기본 얼로케이터가 없기 때문에, Zig 는 할당에 대해 투명하고 유연합니다. &lt;code>std.mem.Allocator&lt;/code> 인터페이스는 강력하며, 우리가 &lt;code>ArenaAllocator&lt;/code> 에서 보았듯이, 더 일반적인 것들을 감싸고 있는 특수화된 얼로케이터를 허용합니다.&lt;/p>
&lt;p>일반적으로, 힙 할당의 능력과 관련된 책임은 아마도 명백할 것입니다. 임의의 크기의 메모리를 임의의 수명으로 할당하는 능력은 대부분의 프로그램에 필수적입니다.&lt;/p>
&lt;p>그러나, 동적 메모리가 가져오는 복잡성 때문에, 대체제를 계속 주시해야 합니다. 예를 들어, 위에서는 &lt;code>std.fmt.allocPrint&lt;/code> 를 사용했지만 표준 라이브러리에는 &lt;code>std.fmt.bufPrint&lt;/code> 도 있습니다. 후자는 할당자 대신 버퍼를 사용합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Leto&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> buf&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">100&lt;/span>]&lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> greeting &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> std.fmt.bufPrint(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#e6db74">&amp;#34;Hello {s}&amp;#34;&lt;/span>, .{name});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{greeting});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 API 는 메모리 관리 부담을 호출자에게 이동합니다. 만약 우리가 더 긴 &lt;code>name&lt;/code> 또는 더 작은 &lt;code>buf&lt;/code> 를 가졌다면, 우리의 &lt;code>bufPrint&lt;/code> 는 &lt;code>NoSpaceLeft&lt;/code> 오류를 반환할 수 있습니다. 하지만 애플리케이션에는 최대 이름 길이와 같은 알려진 한계가 있는 경우가 많습니다. 이러한 경우 &lt;code>bufPrint&lt;/code> 는 더 안전하고 빠릅니다.&lt;/p>
&lt;p>동적 할당을 대체할 수 있는 또 다른 방법은 &lt;code>std.io.Writer&lt;/code> 에 데이터를 스트리밍하는 것입니다. 우리의 &lt;code>Allocator&lt;/code> 와 마찬가지로, &lt;code>Writer&lt;/code> 는 파일과 같은 많은 타입에 의해 구현되는 인터페이스입니다. 위에서 우리는 동적으로 할당된 문자열에 JSON 을 직렬화하기 위해 &lt;code>stringifyAlloc&lt;/code> 를 사용했습니다. 우리는 &lt;code>stringify&lt;/code> 를 사용하고 &lt;code>Writer&lt;/code> 를 제공할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> out &lt;span style="color:#f92672">=&lt;/span> std.io.getStdOut();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> std.json.stringify(.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .this_is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;an anonymous struct&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .above &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .last_param &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;are options&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, .{.whitespace &lt;span style="color:#f92672">=&lt;/span> .indent_2}, out.writer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>할당자는 함수의 첫 번째 매개변수로 주어지는 경우가 많지만, 스트림 작성자는 일반적으로 마지막에 전달됩니다. ಠ_ಠ&lt;/p>
&lt;/blockquote>
&lt;p>많은 경우 스트림 작성자를 &lt;code>std.io.BufferedWriter&lt;/code> 로 래핑하면 성능이 크게 향상합니다.&lt;/p>
&lt;p>우리의 목표는 모든 동적 할당을 제거하는 것이 아닙니다. 이런 대안은 특정한 경우에만 의미가 있기 때문에 작동하지 않을 것입니다. 하지만 이제 여러분은 다양한 옵션을 마음대로 사용할 수 있습니다. 스택 프레임부터 범용 얼로케이터, 그리고 정적 버퍼, 스트리밍 작성자와 특수화된 얼로케이터와 같은 중간에 있는 모든 것들까지 사용할 수 있습니다.&lt;/p>
&lt;h2 id="제네릭">제네릭&lt;/h2>
&lt;p>이전 파트에서 우리는 &lt;code>IntList&lt;/code> 라는 기본적인 동적 배열을 만들었습니다. 이 데이터 구조의 목표는 동적인 개수의 값을 저장하는 것이었습니다. 우리가 사용한 알고리즘은 모든 데이터 타입에 대해 작동하지만, 우리의 구현은 &lt;code>i64&lt;/code> 값에 묶여 있었습니다. 제네릭은 알고리즘과 데이터 구조를 특정 타입으로부터 추상화하는 것을 목표로 합니다.&lt;/p>
&lt;p>많은 프로그래밍 언어가 특별한 구문과 특정 규칙을 사용하여 제네릭을 구현합니다. Zig 는 제네릭이 특정 기능보다는 언어가 무엇을 할 수 있는지를 표현하는 데 더 가깝습니다. 구체적으로, 제네릭은 Zig 의 강력한 컴파일 타임 메타 프로그래밍을 활용합니다.&lt;/p>
&lt;p>우리는 방향을 잡기 위해 단순한 예제를 보면서 시작할 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> arr&lt;span style="color:#f92672">:&lt;/span> IntArray(&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{arr});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> IntArray(&lt;span style="color:#66d9ef">comptime&lt;/span> length&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>) &lt;span style="color:#66d9ef">type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [length]&lt;span style="color:#66d9ef">i64&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위의 코드는 &lt;code>{ 1, 10, 100 }&lt;/code> 를 출력합니다. 흥미로운 부분은 함수가 &lt;code>type&lt;/code> 을 반환한다는 것입니다(따라서 함수는 PascalCase 입니다). 그리고 그냥 타입이 아니라, 함수 매개변수를 기반으로 한 타입입니다. 이 코드가 작동하는 이유는 &lt;code>length&lt;/code> 를 &lt;code>comptime&lt;/code> 으로 선언했기 때문입니다. 즉, &lt;code>IntArray&lt;/code> 를 호출하는 사람은 컴파일 타임에 알수 있는 &lt;code>length&lt;/code> 매개변수를 전달해야 합니다. 이것은 우리의 함수가 &lt;code>type&lt;/code> 을 반환하고 &lt;code>타입 정보&lt;/code>는 항상 컴파일 타임에 알려져 있어야 하기 때문에 반드시 필요합니다.&lt;/p>
&lt;p>함수는 원시 타입과 배열뿐만 아니라 &lt;em>어떤&lt;/em> 타입이든 반환할 수 있습니다. 예를 들어, 작은 변경을 통해 구조체를 반환하도록 만들 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> arr&lt;span style="color:#f92672">:&lt;/span> IntArray(&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr.items[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr.items[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr.items[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{arr.items});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> IntArray(&lt;span style="color:#66d9ef">comptime&lt;/span> length&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>) &lt;span style="color:#66d9ef">type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items&lt;span style="color:#f92672">:&lt;/span> [length]&lt;span style="color:#66d9ef">i64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이상하게 보일지 모르지만, &lt;code>arr&lt;/code> 의 타입은 실제로 &lt;code>IntArray(3)&lt;/code> 입니다. 그것은 다른 타입과 마찬가지로 타입이며, &lt;code>arr&lt;/code> 은 다른 값과 마찬가지로 값입니다. &lt;code>IntArray(7)&lt;/code> 을 호출하면 다른 타입이 될 것입니다. 아마 우리는 더 깔끔하게 만들 수 있을 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> IntArray(&lt;span style="color:#ae81ff">3&lt;/span>).init();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr.items[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr.items[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr.items[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{arr.items});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> IntArray(&lt;span style="color:#66d9ef">comptime&lt;/span> length&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>) &lt;span style="color:#66d9ef">type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items&lt;span style="color:#f92672">:&lt;/span> [length]&lt;span style="color:#66d9ef">i64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init() IntArray(length) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .items &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>언뜻 보기에는 기존 코드보다 더 깔끔해 보이지 않을 수 있습니다. 하지만 이름 없이 함수에 중첩되어 있을 뿐, 우리의 구조체는 지금까지 본 다른 모든 구조체와 같습니다. 필드가 있고 함수가 있습니다. 프로그래머들이 말하는 것처럼, &lt;em>오리처럼 보인다면&amp;hellip;&lt;/em>. 음, 이것은 마치 보통의 구조체처럼 헤엄치고, 꽥꽥거립니다. 왜냐하면 이것도 구조체이기 때문입니다.&lt;/p>
&lt;p>우리는 타입을 반환하는 함수와 관련된 구문에 익숙해지기 위해 이 길을 걸어왔습니다. 더 일반적인 제네릭을 얻으려면, 마지막으로 한 가지 변경을 해야 합니다: 함수는 &lt;code>type&lt;/code> 을 인자로 가져야 합니다. 사실, 이것은 작은 변경이지만 &lt;code>type&lt;/code> 은 &lt;code>usize&lt;/code> 보다 더 추상적으로 느껴질 수 있으므로 천천히 진행했습니다. 우리의 이전 &lt;code>IntList&lt;/code> 를 어떤 타입과도 작동하도록 수정해 보겠습니다. 먼저 골격부터 만들어보겠습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> List(&lt;span style="color:#66d9ef">comptime&lt;/span> T&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span>) &lt;span style="color:#66d9ef">type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items&lt;span style="color:#f92672">:&lt;/span> []T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator&lt;span style="color:#f92672">:&lt;/span> Allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator) &lt;span style="color:#f92672">!&lt;/span>List(T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .pos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .allocator &lt;span style="color:#f92672">=&lt;/span> allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .items &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(T, &lt;span style="color:#ae81ff">4&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위의 &lt;code>struct&lt;/code> 는 &lt;code>i64&lt;/code> 가 &lt;code>T&lt;/code> 로 대체된 것을 제외하면 우리의 &lt;code>IntList&lt;/code> 와 거의 동일합니다. &lt;code>T&lt;/code> 는 특별해 보일 수 있지만, 그것은 그냥 변수 이름입니다. 우리는 &lt;code>item_type&lt;/code> 으로 부를 수 있습니다. 그러나 Zig 의 네이밍 컨벤션을 따르면, &lt;code>type&lt;/code> 의 변수는 PascalCase 입니다.&lt;/p>
&lt;blockquote>
&lt;p>좋든 나쁘든 타입 파라미터를 나타내기 위해 단일 문자를 사용하는 것은 Zig 보다 훨씬 오래되었습니다. &lt;code>T&lt;/code> 는 대부분의 언어에서 일반적인 기본값이지만, 여러분은 해시 맵 같은 키와 값 파라미터 타입에 대해 &lt;code>K&lt;/code> 와 &lt;code>V&lt;/code> 와 같은 문맥별 변형을 보게 될 것입니다.&lt;/p>
&lt;/blockquote>
&lt;p>우리의 기본 구조에 대해 잘 모르겠다면, &lt;code>T&lt;/code> 가 사용되는 두 곳을 생각해보세요: &lt;code>items: []T&lt;/code> 와 &lt;code>allocator.alloc(T, 4)&lt;/code> . 우리가 이 제네릭 타입을 사용하고 싶다면, 우리는 다음과 같이 인스턴스를 만들 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> List(&lt;span style="color:#66d9ef">u32&lt;/span>).init(allocator);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>코드가 컴파일되면, 컴파일러는 &lt;code>T&lt;/code> 를 찾아 &lt;code>u32&lt;/code> 로 대체하여 새로운 타입을 만듭니다. 우리가 &lt;code>List(u32)&lt;/code> 를 다시 사용하면, 컴파일러는 이전에 만든 타입을 재사용할 것입니다. 만약 우리가 &lt;code>List(bool)&lt;/code> 또는 &lt;code>List(User)&lt;/code> 와 같은 새로운 값으로 &lt;code>T&lt;/code> 를 지정한다면, 새로운 타입이 만들어질 것입니다.&lt;/p>
&lt;p>제네릭 &lt;code>List&lt;/code> 를 완성하기 위해 우리는 &lt;code>i64&lt;/code> 를 &lt;code>T&lt;/code> 로 대체하고 나머지 &lt;code>IntList&lt;/code> 코드를 복사하여 붙여넣기 할 수 있습니다. 여기 완전히 동작하는 예제가 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Allocator &lt;span style="color:#f92672">=&lt;/span> std.mem.Allocator;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> List(&lt;span style="color:#66d9ef">u32&lt;/span>).init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> list.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>..&lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> list.add(@intCast(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{list.items[&lt;span style="color:#ae81ff">0&lt;/span>..list.pos]});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> List(&lt;span style="color:#66d9ef">comptime&lt;/span> T&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span>) &lt;span style="color:#66d9ef">type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items&lt;span style="color:#f92672">:&lt;/span> []T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator&lt;span style="color:#f92672">:&lt;/span> Allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator) &lt;span style="color:#f92672">!&lt;/span>List(T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .pos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .allocator &lt;span style="color:#f92672">=&lt;/span> allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .items &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.alloc(T, &lt;span style="color:#ae81ff">4&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> deinit(self&lt;span style="color:#f92672">:&lt;/span> List(T)) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.allocator.free(self.items);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> add(self&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>List(T), value&lt;span style="color:#f92672">:&lt;/span> T) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> pos &lt;span style="color:#f92672">=&lt;/span> self.pos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> self.items.len;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pos &lt;span style="color:#f92672">==&lt;/span> len) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// we&amp;#39;ve run out of space
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// create a new slice that&amp;#39;s twice as large
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> larger &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> self.allocator.alloc(T, len &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// copy the items we previously added to our new space
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> @memcpy(larger[&lt;span style="color:#ae81ff">0&lt;/span>..len], self.items);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.allocator.free(self.items);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.items &lt;span style="color:#f92672">=&lt;/span> larger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.items[pos] &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.pos &lt;span style="color:#f92672">=&lt;/span> pos &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리의 &lt;code>init&lt;/code> 함수는 &lt;code>List(T)&lt;/code> 를 반환하고, &lt;code>deinit&lt;/code> 과 &lt;code>add&lt;/code> 함수는 &lt;code>List(T)&lt;/code> 와 &lt;code>*List(T)&lt;/code> 를 가져옵니다. 우리의 간단한 클래스에서는 괜찮지만, 큰 데이터 구조의 경우 전체 제네릭 이름을 작성하는 것은 약간 지루해질 수 있습니다. 특히 여러 개의 타입 파라미터(예: 키와 값에 대한 별도의 &lt;code>type&lt;/code> 을 사용하는 해시 맵)가 있는 경우입니다. &lt;code>@This()&lt;/code> 내장 함수는 호출된 위치에서 가장 안쪽의 &lt;code>type&lt;/code> 을 반환합니다. 아마도 우리의 &lt;code>List(T)&lt;/code> 는 다음과 같이 작성될 것입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> List(&lt;span style="color:#66d9ef">comptime&lt;/span> T&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span>) &lt;span style="color:#66d9ef">type&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items&lt;span style="color:#f92672">:&lt;/span> []T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator&lt;span style="color:#f92672">:&lt;/span> Allocator,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Added
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> Self &lt;span style="color:#f92672">=&lt;/span> @This();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> init(allocator&lt;span style="color:#f92672">:&lt;/span> Allocator) &lt;span style="color:#f92672">!&lt;/span>Self {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... same code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> deinit(self&lt;span style="color:#f92672">:&lt;/span> Self) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// .. same code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> add(self&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Self, value&lt;span style="color:#f92672">:&lt;/span> T) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// .. same code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Self&lt;/code> 는 특별한 이름이 아니며, 그냥 변수에 불과하며, 그 값은 &lt;code>type&lt;/code> 이기 때문에 PascalCase 입니다. 우리는 이전에 &lt;code>List(T)&lt;/code> 를 사용했던 곳에 &lt;code>Self&lt;/code> 를 사용할 수 있습니다.&lt;/p>
&lt;hr>
&lt;p>여러 타입 파라미터와 더 복잡한 알고리즘을 사용하여 더 복잡한 예제를 만들 수 있습니다. 하지만 결국 핵심 제네릭 코드는 위의 간단한 예제와 다를 것이 없습니다. 다음 파트에서는 표준 라이브러리의 &lt;code>ArrayList(T)&lt;/code> 와 &lt;code>StringHashMap(V)&lt;/code> 를 살펴볼 때 다시 제네릭을 다룰 것입니다.&lt;/p>
&lt;h2 id="zig-로-코딩하기">Zig 로 코딩하기&lt;/h2>
&lt;p>이제 언어의 많은 부분을 다루었으므로, 우리는 몇 가지 주제를 다시 살펴보고 Zig 를 사용하는 몇 가지 실용적인 측면을 살펴볼 것입니다. 이를 통해, 우리는 표준 라이브러리의 더 많은 부분을 소개하고 덜 중요한 코드 스니펫을 소개해 보겠습니다.&lt;/p>
&lt;h3 id="댕글링-포인터dangling-pointers-1">댕글링 포인터Dangling Pointers&lt;/h3>
&lt;p>우리는 댕글링 포인터의 더 많은 예제를 살펴보는 것으로 시작하겠습니다. 이것에 집중하는게 이상하게 보일 수 있지만, 가비지 컬렉션 언어에서 오신 분이라면, 이것이 여러분이 직면하게 될 가장 큰 도전일 것입니다.&lt;/p>
&lt;p>다음 출력이 무엇인지 파악할 수 있나요?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> lookup &lt;span style="color:#f92672">=&lt;/span> std.StringHashMap(User).init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> lookup.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> goku &lt;span style="color:#f92672">=&lt;/span> User{.power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> lookup.put(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>, goku);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> entry &lt;span style="color:#f92672">=&lt;/span> lookup.getPtr(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>).&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// returns an optional, .? would panic if &amp;#34;Goku&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// wasn&amp;#39;t in our hashmap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> entry &lt;span style="color:#f92672">=&lt;/span> lookup.getPtr(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>).&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#39;s power is: {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{entry.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// returns true/false depending on if the item was removed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> lookup.remove(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#39;s power is: {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{entry.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드를 실행했을 때, 다음 결과를 얻었습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>Goku&amp;#39;s power is: 9001
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Goku&amp;#39;s power is: -1431655766
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 키 타입이 &lt;code>[]const u8&lt;/code> 로 설정된 &lt;code>std.AutoHashMap&lt;/code> 의 특수화된 버전인 &lt;code>std.StringHashMap&lt;/code> 를 소개합니다. 100% 확신할 수 없더라도, 이런 결과는 &lt;code>lookup&lt;/code> 에서 &lt;code>entry&lt;/code> 를 &lt;code>remove&lt;/code> 한 후 두 번째 출력이 발생한다는 것과 관련이 있다는 것을 추측할 수 있습니다. &lt;code>remove&lt;/code> 호출을 주석 처리하면 출력이 정상적입니다.&lt;/p>
&lt;p>위 코드를 이해하는 데 있어 핵심은 데이터/메모리가 어디에 있는지 또는 누가 소유하는지를 알고 있어야 한다는 것입니다. Zig 인자는 값으로 전달되며, 즉, 값의 &amp;ldquo;얕은&amp;rdquo; 복사본을 전달합니다. 우리의 &lt;code>lookup&lt;/code> 에있는 &lt;code>User&lt;/code> 는 &lt;code>goku&lt;/code> 에 의해 참조되는 메모리와 같지 않습니다. 위의 코드에는 각각 고유한 소유자가 있는 두 개의 사용자가 있습니다. &lt;code>goku&lt;/code> 는 &lt;code>main&lt;/code> 에 의해 소유되며, 그 복사본은 &lt;code>lookup&lt;/code> 에 의해 소유됩니다.&lt;/p>
&lt;p>&lt;code>getPtr&lt;/code> 메서드는 맵의 값에 대한 포인터를 반환합니다. 우리의 경우, &lt;code>*User&lt;/code> 를 반환합니다. 여기에 문제가 있습니다. &lt;code>remove&lt;/code> 는 &lt;code>entry&lt;/code> 포인터를 무효화합니다. 이 예제에서 &lt;code>getPtr&lt;/code> 와 &lt;code>remove&lt;/code> 의 근접성으로 인해 문제가 다소 분명하게 만듭니다. 하지만 &lt;code>remove&lt;/code> 가 어딘가에 있는 항목에 대한 참조를 보유하고 있다는 것을 모르고 &lt;code>remove&lt;/code> 를 호출하는 코드를 상상하는 것은 어렵지 않습니다.&lt;/p>
&lt;blockquote>
&lt;p>이 예제를 작성할 당시 저는 어떤 일이 일어날지 확신할 수 없었습니다. &lt;code>remove&lt;/code> 가 내부 플래그를 설정하여 실제 제거를 다음 이벤트까지 지연시키는 방법으로 구현할 수도 있었습니다. 그렇게 되면 위의 간단한 경우에는 &amp;ldquo;작동&amp;quot;할 수도 있지만, 더 복잡한 사용 사례에서는 실패할 수도 있습니다. 그건 디버깅하기가 무서울 정도로 어려울 것 같습니다.&lt;/p>
&lt;/blockquote>
&lt;p>Besides not calling &lt;code>remove&lt;/code>, we can fix this a few different ways. The first is that we could use &lt;code>get&lt;/code> instead of &lt;code>getPtr&lt;/code>. This would return a &lt;code>User&lt;/code> instead of a &lt;code>*User&lt;/code> and thus would return copy of the value in &lt;code>lookup&lt;/code>. We&amp;rsquo;d then have three &lt;code>Users&lt;/code>.&lt;/p>
&lt;p>&lt;code>remove&lt;/code> 를 호출하지 않는 것 외에도, 우리는 몇 가지 다른 방법으로 이 문제를 해결할 수 있습니다. 첫 번째는 &lt;code>getPtr&lt;/code> 대신 &lt;code>get&lt;/code> 을 사용하는 것입니다. 이것은 &lt;code>*User&lt;/code> 대신 &lt;code>User&lt;/code> 를 반환하므로 &lt;code>lookup&lt;/code> 에있는 값의 복사본을 반환합니다. 그러면 세 &lt;code>User&lt;/code> 가 생깁니다.&lt;/p>
&lt;ol>
&lt;li>함수에 묶인 원래의 &lt;code>goku&lt;/code> 입니다.&lt;/li>
&lt;li>&lt;code>lookup&lt;/code> 에 있는 복사본입니다. 이는 lookup 에 귀속되었습니다.&lt;/li>
&lt;li>함수에 귀속된 우리의 복사본, &lt;code>entry&lt;/code> 의 복사본입니다.&lt;/li>
&lt;/ol>
&lt;p>&lt;code>entry&lt;/code> 가 이제 사용자의 독립적인 복사본이므로, &lt;code>lookup&lt;/code> 에서 제거되어도 무효화되지 않습니다.&lt;/p>
&lt;p>또다른 옵션은 &lt;code>lookup&lt;/code> 의 타입을 &lt;code>StringHashMap(User)&lt;/code> 에서 &lt;code>StringHashMap(*const User)&lt;/code> 로 변경하는 것입니다. 이 코드는 작동합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// User -&amp;gt; *const User
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> lookup &lt;span style="color:#f92672">=&lt;/span> std.StringHashMap(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> User).init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> lookup.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> goku &lt;span style="color:#f92672">=&lt;/span> User{.power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9001&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// goku -&amp;gt; &amp;amp;goku
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> lookup.put(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>goku);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// getPtr -&amp;gt; get
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> entry &lt;span style="color:#f92672">=&lt;/span> lookup.get(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>).&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#39;s power is: {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{entry.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&lt;/span> lookup.remove(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;Goku&amp;#39;s power is: {d}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{entry.power});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드는 몇 가지 미묘한 점이 있습니다. 우선, 우리는 이제 하나의 &lt;code>User&lt;/code>, &lt;code>goku&lt;/code> 를 가지고 있습니다. &lt;code>lookup&lt;/code> 과 &lt;code>entry&lt;/code> 의 값은 모두 &lt;code>goku&lt;/code> 의 참조입니다. &lt;code>remove&lt;/code> 를 호출하면 &lt;code>lookup&lt;/code> 에서 값이 제거되지만, 그 값은 &lt;code>user&lt;/code> 자체가 아니라 &lt;code>user&lt;/code> 의 주소입니다. 우리가 &lt;code>getPtr&lt;/code> 을 사용했다면, 우리는 &lt;code>remove&lt;/code> 때문에 잘못된 &lt;code>**User&lt;/code> 를 얻을 것입니다. 두 가지 솔루션 모두 &lt;code>getPtr&lt;/code> 대신 &lt;code>get&lt;/code> 을 사용해야 했지만, 이 경우에는 &lt;code>User&lt;/code> 전체가 아니라 주소만 복사합니다. 큰 객체의 경우, 그것은 상당한 차이가 될 수 있습니다.&lt;/p>
&lt;p>With everything in a single function and a small value like &lt;code>User&lt;/code>, this still feels like an artificially created problem. We need an example that legitimately makes data ownership an immediate concern.&lt;/p>
&lt;p>모든 것이 단일 함수에 있고 &lt;code>User&lt;/code> 와 같은 작은 값이 있는 경우에도, 이것은 여전히 인위적으로 만들어진 문제 같습니다. 우리는 데이터 소유권을 즉시 고려해야 하는 합당한 예제가 필요합니다.&lt;/p>
&lt;h3 id="소유권ownership">소유권Ownership&lt;/h3>
&lt;p>저는 해시 맵을 좋아합니다. 왜냐하면 모두가 알고 있고 모두가 사용하기 때문입니다. 또한 해시 맵에는 여러 가지 다른 사용 사례가 있으며, 대부분의 경우 직접 경험해 보셨을 것입니다. 해시 맵은 조회 기간이 짧은 수명으로 사용될 수 있지만, 종종 오래 지속되어 똑같이 긴 수명의 값이 필요합니다.&lt;/p>
&lt;p>이 코드는 터미널에 입력한 이름으로 &lt;code>lookup&lt;/code> 을 채웁니다. 빈 이름은 프롬프트 루프를 중지합니다. 마지막으로 &amp;ldquo;Leto&amp;rdquo; 가 제공된 이름 중 하나인지 여부를 감지합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> builtin &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;builtin&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> lookup &lt;span style="color:#f92672">=&lt;/span> std.StringHashMap(User).init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> lookup.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// stdin is an std.io.Reader
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// the opposite of an std.io.Writer, which we already saw
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> stdin &lt;span style="color:#f92672">=&lt;/span> std.io.getStdIn().reader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// stdout is an std.io.Writer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> stdout &lt;span style="color:#f92672">=&lt;/span> std.io.getStdOut().writer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> i&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> (i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> buf&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">30&lt;/span>]&lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> stdout.print(&lt;span style="color:#e6db74">&amp;#34;Please enter a name: &amp;#34;&lt;/span>, .{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">try&lt;/span> stdin.readUntilDelimiterOrEof(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">&amp;#39;\n&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">|&lt;/span>line&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> line;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (builtin.os.tag &lt;span style="color:#f92672">==&lt;/span> .windows) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// In Windows lines are terminated by \r\n.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// We need to strip out the \r
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> std.mem.trimRight(&lt;span style="color:#66d9ef">u8&lt;/span>, name, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\r&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (name.len &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> lookup.put(name, .{.power &lt;span style="color:#f92672">=&lt;/span> i});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> has_leto &lt;span style="color:#f92672">=&lt;/span> lookup.contains(&lt;span style="color:#e6db74">&amp;#34;Leto&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{has_leto});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 대소문자를 구분하지만, 아무리 완벽하게 &amp;ldquo;Leto&amp;rdquo; 를 입력하해도 &lt;code>contains&lt;/code> 는 항상 &lt;code>false&lt;/code> 를 반환합니다. &lt;code>lookup&lt;/code> 을 반복하고 키와 값을 덤프하여 이를 디버깅해 보겠습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Place this code after the while loop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> lookup.iterator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (it.next()) &lt;span style="color:#f92672">|&lt;/span>kv&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s} == {any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{kv.key_ptr.&lt;span style="color:#f92672">*&lt;/span>, kv.value_ptr.&lt;span style="color:#f92672">*&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 반복자 패턴은 Zig 에서 흔하며, &lt;code>while&lt;/code> 과 옵션 타입 간의 시너지에 의존합니다. 우리의 반복자 항목은 키와 값에 대한 포인터를 반환하므로, 실제 값을 주소가 아닌 &lt;code>.*&lt;/code> 로 역참조하여 액세스합니다. 출력은 입력한 내용에 따라 다릅니다. 저는 다음과 같은 결과를 얻었습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>Please enter a name: Paul
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please enter a name: Teg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please enter a name: Leto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please enter a name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>�� == learning.User{ .power = 1 }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>��� == learning.User{ .power = 0 }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>��� == learning.User{ .power = 2 }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>값은 괜찮아 보이지만 키는 그렇지 않습니다. 무슨 일이 일어나고 있는지 모르겠다면, 아마도 제 잘못입니다. 앞서 제가 의도적으로 여러분의 주의를 돌렸습니다. 해시 맵은 종종 오래 지속되어 수명이 긴 값이 필요하다고 말씀드렸습니다. 사실은 수명이 긴 키뿐만 아니라 수명이 긴 값도 필요하다는 것입니다! &lt;code>buf&lt;/code> 는 &lt;code>while&lt;/code> 루프 내에서 정의되었습니다. &lt;code>put&lt;/code> 을 호출할 때, 우리는 해시 맵에 훨씬 더 짧은 수명을 가진 키를 제공합니다. &lt;code>buf&lt;/code> 를 &lt;code>while&lt;/code> 루프 바깥으로 이동하면 수명 문제가 해결됩니다. 하지만 그 버퍼는 각 반복에서 재사용됩니다. 하지만 기본 키 데이터를 변경하고 있기 때문에 여전히 작동하지 않습니다.&lt;/p>
&lt;p>위 코드의 경우, 오직 하나의 해결책만 있습니다: &lt;code>lookup&lt;/code> 은 키의 소유권을 가져야 합니다. 한 줄을 추가하고 다른 한 줄을 변경해야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// replace the existing lookup.put with these two lines
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> owned_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.dupe(&lt;span style="color:#66d9ef">u8&lt;/span>, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// name -&amp;gt; owned_name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">try&lt;/span> lookup.put(owned_name, .{.power &lt;span style="color:#f92672">=&lt;/span> i});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>dupe&lt;/code> 는 우리가 이전에 본 적이 없는 &lt;code>std.mem.Allocator&lt;/code> 의 메서드입니다. 주어진 값의 복제본을 할당합니다. 이제 코드가 작동합니다. 왜냐하면 키가 이제 힙에 있고 &lt;code>lookup&lt;/code> 보다 오래 지속되기 때문입니다. 사실, 우리는 문자열의 수명을 너무 오래 연장했습니다: 우리는 메모리 누수를 발생시켰습니다.&lt;/p>
&lt;p>우리가 &lt;code>lookup.deinit&lt;/code> 을 호출할 때 키와 값이 우리를 위해 해제될 것이라고 생각할 수 있습니다. 하지만 &lt;code>StringHashMap&lt;/code> 이 사용할 수 있는 만능 해결책은 없습니다. 첫째, 키는 문자열 리터럴일 수 있으며, 해제할 수 없습니다. 둘째, 다른 메모리 할당자로 키를 생성했을 수 있습니다. 마지막으로, 좀 더 나아가지만, 키가 해시 맵에 의해 소유되지 않아도 되는 경우가 있을 수 있습니다.&lt;/p>
&lt;p>유일한 해결책은 우리가 직접 키를 해제하는 것입니다. 이 시점에서는 아마도 우리 자신의 &lt;code>UserLookup&lt;/code> 타입을 만들고 &lt;code>deinit&lt;/code> 함수에서 이 정리 로직을 캡슐화하는 것이 좋을 것입니다. 우리는 당분간 지저분한 상태를 유지하겠습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// replace the existing:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// defer lookup.deinit();
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// with:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">defer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> lookup.keyIterator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (it.next()) &lt;span style="color:#f92672">|&lt;/span>key&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator.free(key.&lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lookup.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 &lt;code>defer&lt;/code> 로직은, 블록을 사용한 첫 번째 로직입니다. 각 키를 해제한 다음 &lt;code>lookup&lt;/code> 을 초기화합니다. 우리는 &lt;code>keyIterator&lt;/code> 를 사용하여 키를 조회합니다. 반복자 값은 해시 맵의 키 항목인 &lt;code>*[]const u8&lt;/code> 의 포인터입니다. 우리는 실제 값을 해제하고 싶은데, 그것은 우리가 &lt;code>dupe&lt;/code> 로 할당한 값이기 때문에, &lt;code>.*&lt;/code> 를 사용하여 값을 역참조합니다.&lt;/p>
&lt;p>자, 이제 댕글링 포인터와 메모리 관리에 대한 이야기는 끝났습니다. 우리가 지금까지 설명한 내용이 여전히 불분명하거나 너무 추상적일 수 있습니다. 해결해야 할 실제 문제가 있을 때 다시 살펴보는 것도 괜찮습니다. 하지만 사소한 것이 아닌 것을 작성할 계획이라면 반드시 숙지해야 할 사항입니다. 여러분이 준비되었다고 생각되면, 프롬프트 루프 예제를 가져와서 스스로 연습해 보기를 권합니다. 우리가 해야 했던 모든 메모리 관리를 캡슐화하는 &lt;code>UserLookup&lt;/code> 타입을 도입해 보세요. 키 대신 &lt;code>*User&lt;/code> 를 사용하여 힙에 사용자를 생성하고 키와 같이 해제해 보세요. &lt;code>std.testing.allocator&lt;/code> 를 사용하여 메모리 누수가 없는지 확인하는 테스트를 작성해 보세요.&lt;/p>
&lt;h3 id="배열-리스트arraylist">배열 리스트ArrayList&lt;/h3>
&lt;p>당신은 아마 우리의 &lt;code>IntList&lt;/code> 와 우리가 만든 제네릭 대안을 잊어버릴 수 있다는 것을 기쁘게 생각할 것입니다. Zig 에는 적절한 동적 배열 구현인 &lt;code>std.ArrayList(T)&lt;/code> 가 있습니다.&lt;/p>
&lt;p>이는 꽤나 표준적인 내용이지만, 그렇게 자주 필요하고 사용되는 데이터 구조이기 때문에 실제로 동작하는 것을 보는 것은 가치가 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> builtin &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;builtin&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> Allocator &lt;span style="color:#f92672">=&lt;/span> std.mem.Allocator;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> std.ArrayList(User).init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (arr.items) &lt;span style="color:#f92672">|&lt;/span>user&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.deinit(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// stdin is an std.io.Reader
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// the opposite of an std.io.Writer, which we already saw
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> stdin &lt;span style="color:#f92672">=&lt;/span> std.io.getStdIn().reader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// stdout is an std.io.Writer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> stdout &lt;span style="color:#f92672">=&lt;/span> std.io.getStdOut().writer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> i&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> (i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> buf&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">30&lt;/span>]&lt;span style="color:#66d9ef">u8&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> stdout.print(&lt;span style="color:#e6db74">&amp;#34;Please enter a name: &amp;#34;&lt;/span>, .{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">try&lt;/span> stdin.readUntilDelimiterOrEof(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">&amp;#39;\n&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">|&lt;/span>line&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> line;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (builtin.os.tag &lt;span style="color:#f92672">==&lt;/span> .windows) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// In Windows lines are terminated by \r\n.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// We need to strip out the \r
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> std.mem.trimRight(&lt;span style="color:#66d9ef">u8&lt;/span>, name, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\r&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (name.len &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> owned_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> allocator.dupe(&lt;span style="color:#66d9ef">u8&lt;/span>, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> arr.append(.{.name &lt;span style="color:#f92672">=&lt;/span> owned_name, .power &lt;span style="color:#f92672">=&lt;/span> i});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> has_leto &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (arr.items) &lt;span style="color:#f92672">|&lt;/span>user&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (std.mem.eql(&lt;span style="color:#66d9ef">u8&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Leto&amp;#34;&lt;/span>, user.name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> has_leto &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{any}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{has_leto});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> deinit(self&lt;span style="color:#f92672">:&lt;/span> User, allocator&lt;span style="color:#f92672">:&lt;/span> Allocator) &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allocator.free(self.name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위는 우리의 해시 맵 코드를 재현한 것이지만, &lt;code>ArrayList(User)&lt;/code> 를 사용합니다. 모든 수명 및 메모리 관리 규칙이 적용됩니다. 여전히 이름의 &lt;code>dupe&lt;/code> 를 만들고, &lt;code>ArrayList&lt;/code> 를 &lt;code>deinit&lt;/code> 을 하기 전에 각 이름을 해제하고 있다는 것을 알아두세요.&lt;/p>
&lt;p>이제 Zig 에는 속성이나 비공개 필드가 없다는 것을 지적하기 좋은 시간이 왔습니다. 값들을 통해 반복자를 돌리기 위해 &lt;code>arr.items&lt;/code> 에 액세스하는 것을 볼 수 있습니다. 속성이 없는 이유는 놀람의 원인을 제거하기 위해서입니다. Zig 에서는 필드 액세스처럼 보이면, 필드 액세스입니다. 개인적으로, 비공개 필드가 없는 것은 실수였다고 생각하지만, 우리는 분명히 이것을 해결할 수 있습니다. 저는 &amp;ldquo;내부적으로만 사용&amp;quot;을 나타내기 위해 필드 앞에 밑줄을 붙이는 것으로 넘어갔습니다.&lt;/p>
&lt;p>왜냐하면 문자열 &amp;ldquo;type&amp;rdquo; 은 &lt;code>[]u8&lt;/code> 또는 &lt;code>[]const u8&lt;/code> 이기 때문에, 문자열 빌더에 적합한 타입은 &lt;code>ArrayList(u8)&lt;/code> 입니다. .NET 의 &lt;code>StringBuilder&lt;/code> 나 Go 의 &lt;code>strings.Builder&lt;/code> 와 같습니다. 사실, 아마도 당신은 함수가 &lt;code>Writer&lt;/code> 를 취하고 문자열이 필요할 때마다 이것을 사용할 것입니다. 우리는 이전에 &lt;code>std.json.stringify&lt;/code> 를 사용하여 stdout 에 JSON 을 출력하는 예제를 보았습니다. 다음은 &lt;code>ArrayList(u8)&lt;/code> 을 사용하여 변수에 출력하는 방법입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> out &lt;span style="color:#f92672">=&lt;/span> std.ArrayList(&lt;span style="color:#66d9ef">u8&lt;/span>).init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> out.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> std.json.stringify(.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .this_is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;an anonymous struct&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .above &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .last_param &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;are options&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, .{.whitespace &lt;span style="color:#f92672">=&lt;/span> .indent_2}, out.writer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{out.items});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="애니타입anytype">애니타입Anytype&lt;/h3>
&lt;p>파트1 에서, 우리는 &lt;code>anytype&lt;/code> 에 대해 간단히 얘기했습니다. 이것은 컴파일 타임의 덕 타이핑의 형태입니다. 다음은 간단한 로거입니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> Logger &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> level&lt;span style="color:#f92672">:&lt;/span> Level,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;#34;error&amp;#34; is reserved, names inside an @&amp;#34;...&amp;#34; are always
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// treated as identifiers
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> Level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> debug,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#e6db74">&amp;#34;error&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fatal,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> info(logger&lt;span style="color:#f92672">:&lt;/span> Logger, msg&lt;span style="color:#f92672">:&lt;/span> []&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>, out&lt;span style="color:#f92672">:&lt;/span> anytype) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (@intFromEnum(logger.level) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> @intFromEnum(Level.info)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> out.writeAll(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>info&lt;/code> 함수의 &lt;code>out&lt;/code> 매개 변수는 &lt;code>anytype&lt;/code> 입니다. 이는 &lt;code>Logger&lt;/code> 가 &lt;code>writeAll&lt;/code> 가지면서 &lt;code>[]const u8&lt;/code> 을 받아들이고 &lt;code>!void&lt;/code> 를 반환하는 모든 구조체에 메시지를 기록할 수 있다는 것을 의미합니다. 이것은 런타임 기능이 아닙니다. 타입 체크는 컴파일 타임에 발생하며, 사용된 각 타입에 대해 올바른 타입의 함수가 생성됩니다. 우리가 필요한 모든 함수를 가지고 있지 않은 타입으로 &lt;code>info&lt;/code> 를 호출하려고 하면 (이 경우에는 &lt;code>writeAll&lt;/code> 만), 컴파일 타임 오류가 발생합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> Logger{.level &lt;span style="color:#f92672">=&lt;/span> .info};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> l.info(&lt;span style="color:#e6db74">&amp;#34;sever started&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Giving us: &lt;em>no field or member function named &amp;lsquo;writeAll&amp;rsquo; in &amp;lsquo;bool&amp;rsquo;&lt;/em>. Using the &lt;code>writer&lt;/code> of an &lt;code>ArrayList(u8)&lt;/code> works:
위 결과는 &lt;em>&amp;lsquo;bool&amp;rsquo; 에 &amp;lsquo;writeAll&amp;rsquo; 이라는 필드 또는 멤버 함수가 없습니다.&lt;/em> 입니다. &lt;code>ArrayList(u8)&lt;/code> 의 &lt;code>writer&lt;/code> 를 사용하면 작동합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> main() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gpa &lt;span style="color:#f92672">=&lt;/span> std.heap.GeneralPurposeAllocator(.{}){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> allocator &lt;span style="color:#f92672">=&lt;/span> gpa.allocator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> Logger{.level &lt;span style="color:#f92672">=&lt;/span> .info};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> std.ArrayList(&lt;span style="color:#66d9ef">u8&lt;/span>).init(allocator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> arr.deinit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> l.info(&lt;span style="color:#e6db74">&amp;#34;sever started&amp;#34;&lt;/span>, arr.writer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std.debug.print(&lt;span style="color:#e6db74">&amp;#34;{s}&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, .{arr.items});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>anytype&lt;/code> 의 가장 큰 단점은 문서화입니다. 우리가 몇 번 사용한 &lt;code>std.json.stringify&lt;/code> 함수의 시그니처는 다음과 같습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// I **hate** multi-line function definitions
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// But I&amp;#39;ll make an exception for a guide which
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// you might be reading on a small screen.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> stringify(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value&lt;span style="color:#f92672">:&lt;/span> anytype,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options&lt;span style="color:#f92672">:&lt;/span> StringifyOptions,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_stream&lt;span style="color:#f92672">:&lt;/span> anytype
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) @TypeOf(out_stream).Error&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>첫 번째 매개 변수인 &lt;code>value: anytype&lt;/code> 은 명백합니다. 직렬화 할 값이며, 어떤 것이든 될 수 있습니다 (실제로 Zig의 JSON 직렬화기가 직렬화할 수 없는 것이 몇 가지 있습니다). &lt;code>out_stream&lt;/code> 이 JSON을 작성할 _위치_라는 것은 짐작할 수 있지만, 어떤 메서드를 구현해야 하는지는 여러분도 저와 마찬가지로 추측할 수 있습니다. 이를 알아낼 수 있는 유일한 방법은 소스 코드를 읽거나 더미 값을 전달하고 컴파일러 오류를 문서로 사용하는 것입니다. 이 문제는 더 나은 자동 문서 생성기를 사용하면 개선될 수 있는 부분입니다. 하지만 Zig에 인터페이스가 있었으면 좋겠다는 생각은 이번이 처음이 아닙니다.&lt;/p>
&lt;h3 id="typeof">@TypeOf&lt;/h3>
&lt;p>이전 파트에서, 우리는 다양한 변수의 타입을 검사하는 데 &lt;code>@TypeOf&lt;/code> 를 사용했습니다. 우리의 사용법을 보면, 여러분은 문자열로 타입의 이름을 반환한다고 생각할 수 있습니다. 그러나 PascalCase 함수이므로, 더 나은 답을 해야 합니다: &lt;code>type&lt;/code> 을 반환합니다.&lt;/p>
&lt;p>제가 가장 좋아하는 &lt;code>anytype&lt;/code> 사용법 중 하나는 테스트 헬퍼를 작성하기 위해 &lt;code>@TypeOf&lt;/code> 와 &lt;code>@hasField&lt;/code> 내장 함수를 사용하는 것입니다. 우리가 본 &lt;code>User&lt;/code> 타입 중 하나는 매우 간단했지만, 여러분은 많은 필드를 가진 더 복잡한 구조를 상상해야 합니다. 우리의 많은 테스트에서는 &lt;code>User&lt;/code> 가 필요하지만, 테스트와 관련된 필드만 지정하고 싶습니다. &lt;code>userFactory&lt;/code> 를 만들어 보겠습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> userFactory(data&lt;span style="color:#f92672">:&lt;/span> anytype) User {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> T &lt;span style="color:#f92672">=&lt;/span> @TypeOf(data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (@hasField(T, &lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>)) data.id &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .power &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (@hasField(T, &lt;span style="color:#e6db74">&amp;#34;power&amp;#34;&lt;/span>)) data.power &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .active &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (@hasField(T, &lt;span style="color:#e6db74">&amp;#34;active&amp;#34;&lt;/span>)) data.active &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (@hasField(T, &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)) data.name &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> User &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> power&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> active&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#f92672">:&lt;/span> [] &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>기본 사용자는 &lt;code>userFactory(.{})&lt;/code> 를 호출하여 생성할 수 있으며, &lt;code>userFactory(.{.id = 100, .active = false})&lt;/code> 와 같이 특정 필드를 재정의할 수도 있습니다. 작은 패턴이지만, 저는 이것을 정말 좋아합니다. 이는 메타 프로그래밍의 세계로 가는 좋은 첫걸음이기도 합니다.&lt;/p>
&lt;p>일반적으로 &lt;code>@TypeOf&lt;/code> 는 &lt;code>@typeInfo&lt;/code> 와 함께 사용됩니다. 이는 &lt;code>std.builtin.Type&lt;/code> 을 반환하는데, 이는 타입을 완전히 설명하는 강력한 태그 유니온입니다. &lt;code>std.json.stringify&lt;/code> 함수는 &lt;code>value&lt;/code> 에 대해 이를 재귀적으로 사용하여 직렬화하는 방법을 알아냅니다.&lt;/p>
&lt;h3 id="빌드하기zig-build">빌드하기Zig Build&lt;/h3>
&lt;p>이 가이드 전체를 읽으면서 여러 종속 요소와 다양한 타깃이 있는 복잡한 프로젝트 설정에 대한 통찰력을 기대했다면 실망할 것입니다. Zig는 강력한 빌드 시스템을 갖추고 있기 때문에 libsodium과 같이 Zig를 사용하지 않는 프로젝트도 점점 더 많이 Zig를 사용하고 있습니다. 하지만 안타깝게도 이러한 강력한 기능은 단순한 요구 사항의 경우 사용하거나 이해하기 쉽지 않다는 것을 의미합니다.&lt;/p>
&lt;blockquote>
&lt;p>사실 저는 Zig의 빌드 시스템을 설명할 만큼 잘 이해하지 못합니다.&lt;/p>
&lt;/blockquote>
&lt;p>그래도, 우리는 최소한 간단한 개요를 얻을 수 있습니다. Zig 코드를 실행하기 위해 &lt;code>zig run learning.zig&lt;/code> 를 사용했습니다. 한 번은 &lt;code>zig test learning.zig&lt;/code> 를 사용하여 테스트를 실행했습니다. &lt;code>run&lt;/code> 과 &lt;code>test&lt;/code> 명령은 단순 학습용으로는 좋지만, 더 복잡한 것에는 &lt;code>build&lt;/code> 명령이 필요합니다. &lt;code>build&lt;/code> 명령은 특수한 &lt;code>build&lt;/code> 진입점을 가진 &lt;code>build.zig&lt;/code> 파일에 의존합니다. 여기에 기본 골격이 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// build.zig
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> build(b&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>std.Build) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>모든 빌드에는 기본 &amp;ldquo;install&amp;rdquo; 단계가 있습니다. 이제 &lt;code>zig build install&lt;/code> 로 실행할 수 있지만, 파일이 거의 비어 있기 때문에 의미있는 아티팩트를 얻을 수 없습니다. 빌드를 위해 프로그램의 진입점을 알려줘야 합니다. &lt;code>learning.zig&lt;/code> 파일입니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> build(b&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>std.Build) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> b.standardTargetOptions(.{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> optimize &lt;span style="color:#f92672">=&lt;/span> b.standardOptimizeOption(.{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// setup executable
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> exe &lt;span style="color:#f92672">=&lt;/span> b.addExecutable(.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;learning&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .target &lt;span style="color:#f92672">=&lt;/span> target,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .optimize &lt;span style="color:#f92672">=&lt;/span> optimize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .root_source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;learning.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b.installArtifact(exe);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now if you run &lt;code>zig build install&lt;/code>, you&amp;rsquo;ll get a binary at &lt;code>./zig-out/bin/learning&lt;/code>. Using the standard targets and optimizations allows us to override the default as command line arguments. For example to build a size-optimized version of our program for Windows, we&amp;rsquo;d do:
이제 &lt;code>zig build install&lt;/code> 을 실행하면 &lt;code>./zig-out/bin/learning&lt;/code> 에 바이너리가 생성됩니다. 명령줄 인수로 표준 타겟과 최적화 옵션을 사용하면 기본값을 재정의할 수 있습니다. 예를 들어 Windows 용 크기 최적화 버전을 빌드하려면 다음과 같이 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>zig build install &lt;span style="color:#f92672">-&lt;/span>Doptimize&lt;span style="color:#f92672">=&lt;/span>ReleaseSmall &lt;span style="color:#f92672">-&lt;/span>Dtarget&lt;span style="color:#f92672">=&lt;/span>x86_64&lt;span style="color:#f92672">-&lt;/span>windows&lt;span style="color:#f92672">-&lt;/span>gnu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실행 파일에는 기본 &amp;ldquo;install&amp;rdquo; 외에 &amp;ldquo;run&amp;quot;과 &amp;ldquo;test&amp;rdquo; 두 가지 단계가 더 있습니다. 라이브러리에는 하나의 &amp;ldquo;test&amp;rdquo; 단계가 있을 수 있습니다. 기본 인수가 없는 &lt;code>run&lt;/code> 을 위해 빌드의 끝에 네 줄을 추가해야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// add after: b.installArtifact(exe);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> run_cmd &lt;span style="color:#f92672">=&lt;/span> b.addRunArtifact(exe);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>run_cmd.step.dependOn(b.getInstallStep());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> run_step &lt;span style="color:#f92672">=&lt;/span> b.step(&lt;span style="color:#e6db74">&amp;#34;run&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Start learning!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>run_step.dependOn(&lt;span style="color:#f92672">&amp;amp;&lt;/span>run_cmd.step);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 하면 두 번의 &lt;code>dependOn&lt;/code> 호출을 통해 두 개의 종속성이 생성됩니다. 첫 번째는 새로운 실행 명령을 내장된 설치 단계에 연결합니다. 두 번째는 &amp;ldquo;run&amp;rdquo; 단계를 새로 만든 &amp;ldquo;run&amp;rdquo; 명령에 연결합니다. 왜 실행 명령과 실행 단계가 모두 필요한지 궁금할 수 있습니다. 저는 이 분리가 더 복잡한 설정을 지원하기 위해서라고 생각합니다: 여러 명령에 의존하는 단계 또는 여러 단계에서 사용되는 명령. &lt;code>zig build --help&lt;/code> 를 실행하고 맨 위로 스크롤하면 새로운 &amp;ldquo;run&amp;rdquo; 단계가 표시됩니다. 이제 &lt;code>zig build run&lt;/code> 을 실행하여 프로그램을 실행할 수 있습니다.&lt;/p>
&lt;p>&amp;ldquo;테스트&amp;rdquo; 단계를 추가하려면 방금 추가한 실행 코드의 대부분을 복제하지만, &lt;code>b.addExecutable&lt;/code> 대신 &lt;code>b.addTest&lt;/code> 로 시작해야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> tests &lt;span style="color:#f92672">=&lt;/span> b.addTest(.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .target &lt;span style="color:#f92672">=&lt;/span> target,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .optimize &lt;span style="color:#f92672">=&lt;/span> optimize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .root_source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;learning.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> test_cmd &lt;span style="color:#f92672">=&lt;/span> b.addRunArtifact(tests);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test_cmd.step.dependOn(b.getInstallStep());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> test_step &lt;span style="color:#f92672">=&lt;/span> b.step(&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Run the tests&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test_step.dependOn(&lt;span style="color:#f92672">&amp;amp;&lt;/span>test_cmd.step);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 단계에 &amp;ldquo;test&amp;rdquo; 라는 이름을 지정했습니다. &lt;code>zig build --help&lt;/code> 를 실행하면 이제 &amp;ldquo;test&amp;rdquo; 라는 다른 사용 가능한 단계가 표시됩니다. 테스트가 없으므로 이것이 작동하는지 여부를 알기 어렵습니다. &lt;code>learning.zig&lt;/code> 에 다음을 추가합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">test&lt;/span> &lt;span style="color:#e6db74">&amp;#34;dummy build test&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> std.testing.expectEqual(&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 &lt;code>zig build test&lt;/code> 를 실행하면 테스트 실패가 발생합니다. 테스트를 수정하고 &lt;code>zig build test&lt;/code> 를 다시 실행하면 출력이 없습니다. 기본적으로 Zig의 테스트 실행기는 실패할 때만 출력합니다. 저처럼 pass 또는 fail 에 대해 항상 요약을 원한다면 &lt;code>zig build test --summary all&lt;/code> 을 사용하세요.&lt;/p>
&lt;p>이것은 시작하고 실행하는 데 필요한 최소한의 구성입니다. 하지만 빌드가 필요한 경우 Zig가 처리할 수 있으니 안심하세요. 마지막으로, Zig가 잘 문서화된 build.zig 파일을 생성하도록 프로젝트 루트에서 &lt;code>zig init-exe&lt;/code> 또는 &lt;code>zig init-lib&lt;/code> 을 사용할 수 있으며, 아마도 그렇게 해야 할 것입니다.&lt;/p>
&lt;h3 id="서드파티-라이브러리third-party-dependencies">서드파티 라이브러리Third Party Dependencies&lt;/h3>
&lt;p>Zig의 기본 제공 패키지 관리자는 비교적 새롭기 때문에 여러 가지 거친 부분이 있습니다. 개선의 여지가 있지만 지금도 충분히 사용할 수 있습니다. 우리가 살펴봐야 할 부분은 패키지를 만드는 것과 패키지를 사용하는 두 가지입니다. 전체 과정을 살펴보겠습니다.&lt;/p>
&lt;p>먼저 &lt;code>calc&lt;/code> 라는 이름의 새 폴더를 만들고 세 개의 파일을 만듭니다. 첫 번째 파일은 &lt;code>add.zig&lt;/code> 이며, 내용은 다음과 같습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Oh, a hidden lesson, look at the type of b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// and the return type!!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> add(a&lt;span style="color:#f92672">:&lt;/span> anytype, b&lt;span style="color:#f92672">:&lt;/span> @TypeOf(a)) @TypeOf(a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> testing &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>).testing;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">test&lt;/span> &lt;span style="color:#e6db74">&amp;#34;add&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> testing.expectEqual(@as(&lt;span style="color:#66d9ef">i32&lt;/span>, &lt;span style="color:#ae81ff">32&lt;/span>), add(&lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>뭔가 이상해보이지만, 두 값을 더하는 것만으로도 완전한 패키지를 만들 수 있습니다. 다음으로 여전히 애매한 &lt;code>calc.zig&lt;/code> 를 추가합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> add &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;add.zig&amp;#34;&lt;/span>).add;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">test&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// By default, only tests in the specified file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// are included. This magic line of code will
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// cause a reference to all nested containers
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// to be tested.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>).testing.refAllDecls(@This());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>두 파일을 나누어 &lt;code>calc.zig&lt;/code> 와 &lt;code>add.zig&lt;/code> 를 통해 &lt;code>zig build&lt;/code> 가 프로젝트 파일을 자동으로 빌드하고 패키징할 수 있음을 증명합니다. 마지막으로 &lt;code>build.zig&lt;/code> 를 추가하면 됩니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> build(b&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">*&lt;/span>std.Build) &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> target &lt;span style="color:#f92672">=&lt;/span> b.standardTargetOptions(.{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> optimize &lt;span style="color:#f92672">=&lt;/span> b.standardOptimizeOption(.{});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> tests &lt;span style="color:#f92672">=&lt;/span> b.addTest(.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .target &lt;span style="color:#f92672">=&lt;/span> target,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .optimize &lt;span style="color:#f92672">=&lt;/span> optimize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .root_source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;calc.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> test_cmd &lt;span style="color:#f92672">=&lt;/span> b.addRunArtifact(tests);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test_cmd.step.dependOn(b.getInstallStep());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> test_step &lt;span style="color:#f92672">=&lt;/span> b.step(&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Run the tests&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test_step.dependOn(&lt;span style="color:#f92672">&amp;amp;&lt;/span>test_cmd.step);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이것은 이전 섹션에서 본 내용을 반복한 것 입니다. 이제 &lt;code>zig build test --summary all&lt;/code> 을 실행할 수 있습니다.&lt;/p>
&lt;p>학습 프로젝트와 이전에 만든 &lt;code>build.zig&lt;/code> 로 돌아갑니다. 먼저 로컬 &lt;code>calc&lt;/code> 를 종속성으로 추가합니다. 세 가지 추가가 필요합니다. 먼저 &lt;code>calc.zig&lt;/code> 를 가리키는 모듈을 만듭니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// You can put this near the top of the build
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// function, before the call to addExecutable.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> calc_module &lt;span style="color:#f92672">=&lt;/span> b.addModule(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>, .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;PATH_TO_CALC_PROJECT/calc.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>아마 &lt;code>calc.zig&lt;/code> 의 경로를 조정해야 할 것입니다. 이제 이 모듈을 기존의 &lt;code>exe&lt;/code> 와 &lt;code>tests&lt;/code> 변수에 추가해야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> exe &lt;span style="color:#f92672">=&lt;/span> b.addExecutable(.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;learning&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .target &lt;span style="color:#f92672">=&lt;/span> target,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .optimize &lt;span style="color:#f92672">=&lt;/span> optimize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .root_source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;learning.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// add this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>exe.addModule(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>, calc_module);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b.installArtifact(exe);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> tests &lt;span style="color:#f92672">=&lt;/span> b.addTest(.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .target &lt;span style="color:#f92672">=&lt;/span> target,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .optimize &lt;span style="color:#f92672">=&lt;/span> optimize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .root_source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;learning.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// add this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>tests.addModule(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>, calc_module);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 프로젝트에서 &lt;code>@import(&amp;quot;calc&amp;quot;)&lt;/code> 를 사용할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> calc &lt;span style="color:#f92672">=&lt;/span> @import(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>calc.add(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>원격에 있는 종속성을 추가하는 것은 좀 더 많은 노력이 필요합니다. 먼저, &lt;code>calc&lt;/code> 프로젝트로 돌아가서 모듈을 정의해야 합니다. 프로젝트 자체가 모듈이라고 생각할 수 있지만, 프로젝트는 여러 모듈을 노출할 수 있기 때문에 명시적으로 만들어야 합니다. 우리는 동일한 &lt;code>addModule&lt;/code> 을 사용하지만 반환 값을 버립니다. 다른 프로젝트에서 가져올 수 있는 모듈을 정의하는 데 &lt;code>addModule&lt;/code> 을 호출하는 것만으로 충분합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>_ &lt;span style="color:#f92672">=&lt;/span> b.addModule(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>, .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;calc.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>라이브러리에서 변경해야 할 유일한 부분입니다. 이것은 원격 종속성을 가지는 연습이기 때문에, 이 &lt;code>calc&lt;/code> 프로젝트를 GitHub에 푸시하여 학습 프로젝트에 가져올 수 있습니다. 원격 파일은 &lt;a href="https://github.com/karlseguin/calc.zig">https://github.com/karlseguin/calc.zig&lt;/a> 에 있습니다.&lt;/p>
&lt;p>학습 프로젝트로 돌아가, 새 파일 &lt;code>build.zig.zon&lt;/code> 을 생성합니다. &amp;ldquo;ZON&amp;rdquo; 은 Zig Object Notation 의 약자로, Zig 데이터를 사람이 읽을 수 있는 형식으로 표현하고, 그 사람이 읽을 수 있는 형식을 Zig 코드로 변환할 수 있습니다. &lt;code>build.zig.zon&lt;/code> 의 내용은 다음과 같습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>.{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;learning&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .paths &lt;span style="color:#f92672">=&lt;/span> .{&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .dependencies &lt;span style="color:#f92672">=&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .calc &lt;span style="color:#f92672">=&lt;/span> .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://github.com/karlseguin/calc.zig/archive/e43c576da88474f6fc6d971876ea27effe5f7572.tar.gz&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .hash &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;12ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 파일에는 두 가지 의심스러운 값이 있는데, 첫 번째는 &lt;code>url&lt;/code> 내의 &lt;code>e43c576da88474f6fc6d971876ea27effe5f7572&lt;/code> 입니다. 이것은 단순히 git 커밋 해시입니다. 두 번째는 &lt;code>hash&lt;/code> 의 값입니다. 알기 쉬운 좋은 방법이 없기 때문에 일단 더미 값을 사용합니다.&lt;/p>
&lt;p>이 종속성을 사용하려면 &lt;code>build.zig&lt;/code> 에 한 가지 변경을 해야 합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zig" data-lang="zig">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// replace this:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> calc_module &lt;span style="color:#f92672">=&lt;/span> b.addModule(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>, .{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .source_file &lt;span style="color:#f92672">=&lt;/span> .{ .path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;calc/calc.zig&amp;#34;&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// with this:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> calc_dep &lt;span style="color:#f92672">=&lt;/span> b.dependency(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>, .{.target &lt;span style="color:#f92672">=&lt;/span> target,.optimize &lt;span style="color:#f92672">=&lt;/span> optimize});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> calc_module &lt;span style="color:#f92672">=&lt;/span> calc_dep.module(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>build.zig.zon&lt;/code> 에서 종속성 패키지의 이름을 &lt;code>calc&lt;/code> 로 지정했고, 여기서 로드하는 종속성도 &lt;code>calc&lt;/code> 입니다. 이 종속성에서 &lt;code>calc&lt;/code> 모듈을 가져오는데, 이 모듈은 &lt;code>calc&lt;/code> 의 &lt;code>build.zig&lt;/code> 에서 모듈의 이름을 지정한 것입니다.&lt;/p>
&lt;p>이제 &lt;code>zig build test&lt;/code> 를 실행하면 오류가 발생합니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>error: hash mismatch:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>expected:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>found:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>122053da05e0c9348d91218ef015c8307749ef39f8e90c208a186e5f444e818672d4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>올바른 해시를 복사해서 &lt;code>build.zig.zon&lt;/code> 에 다시 붙여넣고 &lt;code>zig build test&lt;/code> 를 다시 실행해 보세요. 이제 모든 것이 작동해야 합니다.&lt;/p>
&lt;p>많은 작업이 있었지만 잘 진행되었기를 바랍니다. 보통 대부분 다른 프로젝트에서 복사하여 붙여넣을 수 있으며, 한 번 세팅하면, 계속 사용할 수 있습니다.&lt;/p>
&lt;p>A word of warning, I&amp;rsquo;ve found Zig&amp;rsquo;s caching of dependencies to be on the aggressive side. If you try to update a dependency but Zig doesn&amp;rsquo;t seem to detect the change&amp;hellip;well, I nuke the project&amp;rsquo;s &lt;code>zig-cache&lt;/code> folder as well as &lt;code>~/.cache/zig&lt;/code>.&lt;/p>
&lt;p>경고의 말씀을 드린다면, 저는 Zig의 종속성 캐싱이 과도하다고 생각합니다. 종속성을 업데이트하려고 하지만 Zig가 변경 사항을 감지하지 못하는 경우&amp;hellip; 저는 프로젝트의 &lt;code>zig-cache&lt;/code> 폴더와 &lt;code>~/.cache/zig&lt;/code> 를 날려 버립니다.&lt;/p>
&lt;hr>
&lt;p>우리는 몇 가지 핵심 데이터 구조를 탐색하고 이전 부분의 큰 덩어리를 하나로 모으는 등 많은 부분을 다뤘습니다. 코드가 조금 더 복잡해졌고, 특정 구문에 덜 집중하고 실제 코드처럼 보이게 되었습니다. 저는 이렇게 복잡해졌음에도 불구하고 코드가 대부분 이해된다는 가능성에 흥분했습니다. 그렇지 않더라도 포기하지 마세요. 예제를 하나 골라 분해하고, 출력문을 추가하고, 몇 가지 테스트를 작성해 보세요. 코드를 직접 만져보고 자신만의 코드를 만든 다음 다시 돌아와서 이해가 되지 않는 부분을 다시 읽어보세요.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>일부 독자들은 저를 다양한 &amp;ldquo;The Little $TECH Book&amp;quot;의 저자로 알고 있으며, 왜 &amp;ldquo;The Little Zig Book&amp;quot;이라고 부르지 않는지 궁금해할 것입니다. 사실 Zig가 &amp;ldquo;The Little&amp;rdquo; 형식에 맞는지 잘 모르겠습니다. Zig의 복잡성과 학습 곡선은 사용자의 배경과 경험에 따라 크게 달라질 수 있다는 점이 문제입니다. 숙련된 C 또는 C++ 프로그래머라면 언어에 대한 간결한 요약만으로도 충분하겠지만, 그렇지 않다면 &lt;a href="https://ziglang.org/documentation/master/">Zig 언어 레퍼런스&lt;/a>에 의존하게 될 것입니다.&lt;/p>
&lt;p>이 가이드에서 많은 내용을 다루었지만, 아직 다루지 않은 내용이 많이 있습니다. 그렇다고 해서 낙담하거나 부담스러워하지 마세요. 모든 언어는 다층적이기 때문에 이제 여러분은 숙달을 시작하고 시작할 수 있는 기초와 참고 자료를 얻게 되었습니다. 솔직히 제가 다루지 않은 부분은 설명할 만큼 잘 이해하지 못합니다. 그렇다고 해서 인기 있는 http 서버 라이브러리와 같은 의미 있는 것들을 Zig에서 사용하거나 구축하는 것을 막지는 못했습니다.&lt;/p>
&lt;p>완전히 건너뛰었던 한 가지를 강조하고 싶습니다. 이미 알고 계신 내용일 수도 있지만, Zig는 특히 C 코드와 잘 작동합니다. 생태계가 아직 초기 단계이고 표준 라이브러리가 적기 때문에 C 라이브러리를 사용하는 것이 최선의 선택인 경우가 있을 수 있습니다. 예를 들어, Zig의 표준 라이브러리에는 정규식 모듈이 없는 경우 C 라이브러리를 사용하는 것이 합리적인 선택일 수 있습니다. 저는 SQLite와 DuckDB용 Zig 라이브러리를 작성해 본 적이 있는데, 아주 간단했습니다. 이 가이드의 모든 내용을 대부분 따랐다면 아무런 문제가 없을 것입니다.&lt;/p>
&lt;p>이 자료가 도움이 되었기를 바라며 즐거운 프로그래밍이 되기를 바랍니다.&lt;/p>
&lt;h3 id="감사의-말thanks">감사의 말Thanks&lt;/h3>
&lt;p>이 시리즈에 수정 및 제안을 해주신 모든 분들께 감사드립니다. 특히, 철저한 편집을 제공해주신 &lt;a href="https://github.com/gonzus">Gonzalo Diethelm&lt;/a>에게 감사드립니다.&lt;/p></content></item><item><title>Write Deadly Simple Compiler Part 3</title><link>https://faultnote.github.io/posts/write-simple-compiler-3/</link><pubDate>Sat, 07 Jan 2023 20:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/write-simple-compiler-3/</guid><description>Phil 의 &amp;lsquo;Writing a lisp compiler from scratch in JavaScript&amp;rsquo; 첫 포스트의 세 번째 파트인데 분량이 많아 새 포스트를 열었다. 지난 포스트에 이어서&amp;hellip; Phil 의 가이드에 마지막 부분은 파싱된 배열</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://notes.eatonphil.com">Phil&lt;/a> 의 &amp;lsquo;Writing a lisp compiler from scratch in JavaScript&amp;rsquo; 첫 포스트의 세 번째 파트인데 분량이 많아 새 포스트를 열었다.&lt;/p>
&lt;/blockquote>
&lt;p>지난 포스트에 이어서&amp;hellip;&lt;/p>
&lt;p>Phil 의 가이드에 마지막 부분은 파싱된 배열을 어셈블리로 변환하는 컴파일 과정을 담고 있다.
그리고 어셈블리를 어셈블! 하는 것으로 첫 포스트를 마치고 있다.&lt;/p>
&lt;h2 id="테스트-코드-러너">테스트 코드 러너&lt;/h2>
&lt;p>주어진 구문을 파싱하고 컴파일 하는 간단한 스크립트를 하나 만들어 보자. 보통 script runner 같은 이름이 사용된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#a6e22e">compile&lt;/span>, &lt;span style="color:#a6e22e">parse&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;./lib&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(+ 3 (+ 1 2)&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> [&lt;span style="color:#a6e22e">parsed&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">program&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">assmbled&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">compile&lt;/span>(&lt;span style="color:#a6e22e">parsed&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;---------------------------------------------------&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">dir&lt;/span>(&lt;span style="color:#a6e22e">parsed&lt;/span>, { &lt;span style="color:#a6e22e">colors&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#a6e22e">depth&lt;/span>: &lt;span style="color:#66d9ef">5&lt;/span>, &lt;span style="color:#a6e22e">showHidden&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;---------------------------------------------------&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">assmbled&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 스크립트를 실행하면 아래와 같은 결과를 얻을 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>---------------------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, 3, &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, 1, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---------------------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .global _main_
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ADD RDI, RSI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOV RAX, RDI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_main_:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUSH RDI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUSH RSI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOV RDI, &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUSH RDI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUSH RSI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOV RDI, &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOV RSI, &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CALL plus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POP RSI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POP RDI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOV RSI, RAX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CALL plus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POP RSI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POP RDI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOV RDI, RAX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MOV RAX, 0x2000001
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SYSCALL
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>파싱된 AST 의 첫 원소가 우리가 사용할 결과이다. macOS 에서 컴파일하기 위해 추가한 코드는 저장소를 살펴 보도록 한다.&lt;/p>
&lt;p>대략 개요는 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">ExitCode&lt;/span>: &lt;span style="color:#66d9ef">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">string&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">darwin&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0x2000001&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;60&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 진짜 어셈블 해 실행 파일(바이너리)를 만들어 보자.&lt;/p>
&lt;h2 id="실행-코드-생성">실행 코드 생성&lt;/h2>
&lt;p>테스트 코드 러너를 Phil 의 문서와 같이 &lt;code>ulisp&lt;/code> 이란 파일로 만들어 실행 가능하게 하고 &lt;code>gcc&lt;/code> 명령도 함께 실행되도록 하면 이 전체 동작을 포장할 수 있을 것이다.&lt;/p>
&lt;p>&lt;code>ulisp&lt;/code> 파일은 실행 권한을 부여하여 &lt;code>node&lt;/code> 가 있으면 스스로 실행 가능하도록 하고 &lt;code>./tmp&lt;/code> 폴더에서 컴파일하고 어셈블하고 실행 파일을 만드는, 소위 툴체인 형식을 가지도록 해보자.&lt;/p>
&lt;p>소스를 지정하고 실행 파일을 만들어 내는 절차를 좀 그럴 듯 하게 가져가 보려 했지만 어짜피 한 줄의 S-Expression 구문을 컴파일하는 것이 전부인 관계로 그냥 아래와 같은 형식으로 명령을 실행하도록 하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ulisp.js &lt;span style="color:#e6db74">&amp;#39;(+ 3 (+ 2 1))&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>이 과정을 겪으며 알게된 사실인데 우리 프로그램의 엔트리 포인트로 사용하는 &lt;code>_main_&lt;/code> 은 잘못된 식별자였다. 정상 동작을 위해 &lt;code>_main&lt;/code> 으로 변경하였다.&lt;/p>
&lt;/blockquote>
&lt;p>어셈블리를 컴파일하기 위해 &lt;code>gcc&lt;/code> 를 사용하고 있다. gcc 는 gnu compiler collection 의 약자로 다양한 코드를 컴파일 할 수 있다. 어셈블리 컴파일(어셈블)하기 위해 아래와 같은 명령을 사용한다.&lt;/p>
&lt;p>&lt;code>gcc 옵션 -o 출력파일이름 소스파일이름&lt;/code>&lt;/p>
&lt;p>ulisp.js 의 전체 코드는 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/usr/bin/env node
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#a6e22e">writeFileSync&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;fs&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#a6e22e">execSync&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;child_process&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#a6e22e">parse&lt;/span>, &lt;span style="color:#a6e22e">compile&lt;/span> } &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;./lib&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">CC&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;gcc&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">SOURCE&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;program.S&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#a6e22e">args&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">script&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">script&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;no source&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">compile&lt;/span>(&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">script&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">writeFileSync&lt;/span>(&lt;span style="color:#a6e22e">SOURCE&lt;/span>, &lt;span style="color:#a6e22e">program&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">execSync&lt;/span>(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">CC&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> -mstackrealign -masm=intel -o program &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">SOURCE&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;done; \nrun ./program and echo $? for output&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#a6e22e">process&lt;/span>.&lt;span style="color:#a6e22e">argv&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실행 플래그를 주는 방법은 &lt;code>chmod +x ulisp.js&lt;/code> 이다. 마지막 로그를 보면 알겠지만 우리 프로그램은 그냥 종료할 뿐이고 화면에 출력하는 시스템 콜은 없다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./ulisp.js &lt;span style="color:#e6db74">&amp;#39;(+ 3 (+ 2 1))&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>run ./program and echo $? &lt;span style="color:#66d9ef">for&lt;/span> output
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ file program &lt;span style="color:#75715e"># or use hexyl to see hex binary&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>program: Mach-O 64-bit executable x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./program
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ echo $?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 첫 포스트가 마무리 되었다. 이어지는 내용은 좀 더 그럴듯한 프로그램을 위해 함수를 선언하고 이를 사용하는 프로그램 코드를 컴파일하는 과정을 담고 있다.&lt;/p>
&lt;h2 id="서브-루틴">서브 루틴&lt;/h2>
&lt;p>보통 함수나 프로시져를 서브루틴의 일부로 본다. 서브루틴은 반복되는 코드를 재사용하기 위한 방법으로 반환하는 값이 있으면 보통 함수, 반환하는 값이 없는 경우는 프로시져로 불렸는데 지금은 크게 구분하여 사용하지 않는 편이다. 코드 반복이나 재사용을 위한 가장 중요한 역할을 한다. 이하 일반적으로 널리 사용되는 함수라는 표현을 사용하겠다.&lt;/p>
&lt;blockquote>
&lt;p>서브루틴은 코루틴과 함께 코드 흐름을 나타낸다.&lt;/p>
&lt;/blockquote>
&lt;p>함수를 구성함에 있어 미리 알아두어야 할 것이 있다.&lt;/p>
&lt;ol>
&lt;li>값을 전달하는 방법은 이전에 살펴본 것과 같이 스택을 사용한다.&lt;/li>
&lt;li>함수 수신자와 함수 호출자 사이의 규칙과 함수가 사용하는 변수(식별자)에 대한 생존 범위(Life-time)를 관리하고 정의해야 한다.&lt;/li>
&lt;/ol>
&lt;p>함수 정의 구문은 아래와 같은 표현을 사용하기로 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#a6e22e">def&lt;/span> main ()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (+ &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 우리가 만드는 프로그래밍 언어는 &lt;code>main&lt;/code> 함수를 사용하기로 약속하여 프로그램의 엔트리포인트entrypoint 라고 불리는 개념을 구현하기로 한다.&lt;/p>
&lt;p>우리가 만든 S-expression 파서는 이 새로운 구문을 잘 파싱한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(def main () (+ 1 2))&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>runner.js&lt;/code> 파일에 있는 프로그램 코드를 수정하여 파싱해 보자.&lt;/p>
&lt;p>Phil 의 본문에 있는 node repl 에서 실행하는 방법도 유용하니 경험해 보도록 하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Welcome to Node.js v19.3.0.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type &lt;span style="color:#e6db74">&amp;#34;.help&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> more information.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; const &lt;span style="color:#f92672">{&lt;/span> parse &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">=&lt;/span> require&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;./lib/parser&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>undefined
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; JSON.stringify&lt;span style="color:#f92672">(&lt;/span>parse&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;(def main () (+ 1 2))&amp;#39;&lt;/span>&lt;span style="color:#f92672">))&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;[[[&amp;#34;def&amp;#34;,&amp;#34;main&amp;#34;,[0],[&amp;#34;+&amp;#34;,1,2]]],&amp;#34;&amp;#34;]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>타입 정보가 다른게 있는지 &amp;ldquo;main&amp;rdquo; 뒤에 &lt;code>[0]&lt;/code> 있는데 나중에 다시 점검해 보기로 한다.&lt;/p>
&lt;p>파싱은 일단 되니 이 결과를 컴파일하는 코드를 보강해 보도록 한다.&lt;/p>
&lt;p>우선 &lt;code>def&lt;/code> 는 사용자가 정의하는 키워드가 아니고 이 언어 시스템의 고유한 키워드이다. 여기에서는 &amp;ldquo;primitive&amp;rdquo; 라고 부르고 있다.&lt;/p>
&lt;p>이렇게 원시 함수를 모아두는 객체를 하나 만들어 둔다. 그리고 compile fn call 함수에서 원시primitive 함수를 따로 처리하는 기능을 추가할 것이다.&lt;/p>
&lt;p>그 전에 인자가 없는 깡통 함수를 선언하고 있는 def main () 코드가 정상적으로 파싱 되도록 parser 를 수정해 보자.&lt;/p>
&lt;p>문제는 여는 괄호가 블록을 시작하는 것도 있지만 인자를 선언하는 영역의 시작으로도 사용된다는 점이다. 우리의 기본 코드는 인자가 없는 상태로 제공되고 있고 이는 빈 expression 으로 반환되어야 한다.&lt;/p>
&lt;p>Phil 의 저장소에 있는 코드를 참고하여 파서를 수정하자.&lt;/p>
&lt;p>괄호를 닫는 과정에 저장된 토큰이 없는 경우에 대한 예외 처리를 추가해야 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// check for parameter section in function declaration
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">currentToken&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">getToken&lt;/span>(&lt;span style="color:#a6e22e">currentToken&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>아직 어셈블리로 컴파일은 되지 않지만 파서의 테스트 케이스는 통과하게 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">it&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;should parse def main function expression&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">source&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(def main () (+ 1 2))&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">expected&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [[[&lt;span style="color:#e6db74">&amp;#39;def&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span>, [], [&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>]]], &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">source&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">expect&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>).&lt;span style="color:#a6e22e">toEqual&lt;/span>(&lt;span style="color:#a6e22e">expected&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>다음 포스트에 코드를 생성하며 함수 정의definition와 호출/피호출을 나타낼 때 자주 사용되는 caller/callee 를 통해 함수 호출 규칙을 살펴 보고, 식별자의 유효 범위를 제한하는 scope 에 대해 알아보기로 하자.&lt;/p></content></item><item><title>Write Deadly Simple Compiler Part 2</title><link>https://faultnote.github.io/posts/write-simple-compiler-2/</link><pubDate>Sun, 27 Nov 2022 22:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/write-simple-compiler-2/</guid><description>Phil 의 &amp;lsquo;Writing a lisp compiler from scratch in JavaScript&amp;rsquo; 첫 포스트의 두 번째 파트인데 분량이 많아 새 포스트를 열었다. 지난 포스트에 이어서&amp;hellip; Phil 의 가이드는 S-expression 을 배열 데이터로 만들고</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://notes.eatonphil.com">Phil&lt;/a> 의 &amp;lsquo;Writing a lisp compiler from scratch in JavaScript&amp;rsquo; 첫 포스트의 두 번째 파트인데 분량이 많아 새 포스트를 열었다.&lt;/p>
&lt;/blockquote>
&lt;p>지난 포스트에 이어서&amp;hellip;&lt;/p>
&lt;p>Phil 의 가이드는 S-expression 을 배열 데이터로 만들고 이를 어셈블리 코드(텍스트)로 기록하도록 하고 있다. 그후 어셈블러를 사용하여 실행 가능한 바이너리 파일을 만든다.&lt;/p>
&lt;p>어셈블리는 보통의 사람이 읽을 수 있는 가장 낮은 수준의 프로그래밍 언어로 CPU 의 실제 명령과 1:1 로 대응된다. 그래서 생성된 바이너리 코드는 어셈블리로 쉽게 변환 가능하다.&lt;/p>
&lt;p>어셈블리는 선형으로 구성된다. 비교와 반복을 통해 procedual 하게 코드가 실행된다. 함수가 호출될 때 특정 레지스터에 인자를 담아두고 함수가 종료되면 특정 레지스터에 반환 값이 담긴 후 다음 명령으로 되돌아가기 위해 약속된 레지스터를 참조한다.&lt;/p>
&lt;p>규칙만 잘 알면 단순하고 읽기 쉽다&amp;hellip;🤯 어쨋든, 우리의 프로그램들은 이 과정이 매우 빠르게 반복되는 것 뿐이다.&lt;/p>
&lt;blockquote>
&lt;p>각 CPU 제조사 마다 CPU 를 위한 명령어(OpCode) 세트가 있고 우리는 이걸 ISA, Instruction Set Architecture 라고 부른다.&lt;/p>
&lt;/blockquote>
&lt;p>이 포스트에서는 x86_64 기준, &lt;code>RDI&lt;/code>, &lt;code>RSI&lt;/code>, &lt;code>RDX&lt;/code> 레지스터에 인자를 담고, &lt;code>RAX&lt;/code> 레지서터에 반환 값을 담기로 한다. 함수 호출시 값을 담는 주체도 함수를 호출하는 쪽으로 하자.&lt;/p>
&lt;p>어셈블리 프로그램은 section 으로 구분되어 있다. &lt;code>text&lt;/code> 영역에는 읽기만 가능한 프로그램의 코드, 명령들이 있고 CPU 는 이 명령들을 실행하며 다음으로 이동한다. 이동 과정에 CALL, RET, JMP 등 다음 명령어의 위치를 변경하는 명령을 만나 이동하기도 하고 복귀하기도 한다.&lt;/p>
&lt;p>그리고 중요한 부분으로 보통, 프로그램의 시작 위치를 정의하는 부분인 &lt;code>.global main&lt;/code> 도 필요하다.
main 은 goto 를 위한 흔한 라벨이다. main 이라는 라벨이 사용될 수 있으니 우리 프로그램의 시작은 &lt;code>_main_&lt;/code> 을 사용하도록 하겠다.&lt;/p>
&lt;p>각 어셈블리 코드를 생성하는 emit 이라는 함수를 중심으로 우리가 가진 AST 데이터를 어셈블리 코드로 변환해 보자.&lt;/p>
&lt;h2 id="코드-생성">코드 생성&lt;/h2>
&lt;p>emit 함수가 생성하는 결과는 소스 코드가 된다. 들여쓰기를 위해 depth 와 기록할 code 를 인자로 받자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">makeIndent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">length&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">indentSpace&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">indentSpace&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\t&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">indentSpace&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#a6e22e">indentDepth&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>, &lt;span style="color:#a6e22e">code&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">print&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">dump&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">makeIndent&lt;/span>(&lt;span style="color:#a6e22e">indentDepth&lt;/span>)&lt;span style="color:#e6db74">}${&lt;/span>&lt;span style="color:#a6e22e">code&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">print&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">dump&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">dump&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#e6db74">n`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>정상 동작을 확인하기 위한 단순한 테스트 파일도 추가해 본다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">emit&lt;/span> } &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#39;./compiler&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">describe&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Emit tab spaces&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">it&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;should return tabbed spaces with text&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">expected&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\t\thello&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;hello&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">expect&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>).&lt;span style="color:#a6e22e">toEqual&lt;/span>(&lt;span style="color:#a6e22e">expected&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이어서 함수 인자argument를 처리하는 코드와 함수를 호출하고 결과를 저장하는 코드를 생성하는 compile arguement, compile function(label) call 함수를 구성해 보자.&lt;/p>
&lt;p>우리가 가진 AST 구조를 생각해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>연산자는 어셈블리로 구성된 함수가 되고 숫자는 레지스터에 할당될 값들이 된다. 함수는 함수 라벨로 표기하여 CPU 명령 처리기가 Jump 할 수 있도록 하고 각 숫자는 리터럴이 된다.&lt;/p>
&lt;p>어셈블리 코드는 아래와 같은 형식으로 시작하고 시스템 콜을 통해 종료된다. (예시는 요즘 macOS 기준)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">.global&lt;/span> &lt;span style="color:#66d9ef">_main_&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">.text&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 프로그램 코드...
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 프로그램 코드...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MOV&lt;/span> &lt;span style="color:#66d9ef">RDI&lt;/span>, &lt;span style="color:#66d9ef">RAX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MOV&lt;/span> &lt;span style="color:#66d9ef">RAX&lt;/span>, &lt;span style="color:#ae81ff">0x2000001&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SYSCALL&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>우리의 샘플 AST 는 두 번의 &lt;code>ADD&lt;/code> 연산을 하게 될 예정이고 이 함수는 &lt;code>plus:&lt;/code> 라는 라벨을 달고 재사용할 것이다.&lt;/p>
&lt;p>어셈블리 수준에서 함수 호출 기능은 아래와 같은 형식으로 구성될 수 있다.&lt;/p>
&lt;ol>
&lt;li>연산에 사용될 인자를 레지스터에 저장하기 위해 레지스터의 이전 값을 저장 → 각 레지스터를 스택에 저장 → 호출하는 함수 인자에 갯수 만큼만 스택에 올리면 된다.&lt;/li>
&lt;li>우리 수준에서, 최대 3개까지 사용 가능한 인자들을 레지스터에 저장 (순서대로)&lt;/li>
&lt;li>함수 호출 → 더하기 기능을 하는 프로시져로 이동 → 코드 실행 후 RET 명령으로 복귀&lt;/li>
&lt;li>스택에 저장된 레지스터 값을 복원 (저장한 역순으로)&lt;/li>
&lt;li>결과 값이 저장된 레지스터에서 값을 확인&lt;/li>
&lt;/ol>
&lt;p>Phil 의 코드를 참고로 좀 더 진행해 보자.&lt;/p>
&lt;p>파라미터를 위한 3개의 레지스터를 준비하고, 어셈블리 내장 함수를 감싼 plus 함수 라벨도 준비해 두었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">OpCode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Register&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">RDI&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;RDI&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">RSI&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;RSI&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">RDX&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;RDX&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">RAX&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;RAX&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">ArgRegisters&lt;/span>: &lt;span style="color:#66d9ef">Register&lt;/span>[] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#a6e22e">Register&lt;/span>.&lt;span style="color:#a6e22e">RDI&lt;/span>, &lt;span style="color:#a6e22e">Register&lt;/span>.&lt;span style="color:#a6e22e">RSI&lt;/span>, &lt;span style="color:#a6e22e">Register&lt;/span>.&lt;span style="color:#a6e22e">RDX&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">BuiltinFunctions&lt;/span>: &lt;span style="color:#66d9ef">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">OpCode&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;plus&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>함수 호출 생성하기 위한 compileFnCall 함수를 작성해 보자. 위에서 안내한 pseudo 코드를 옮기면 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">compileFnCall&lt;/span>(&lt;span style="color:#a6e22e">functionLabel&lt;/span>: &lt;span style="color:#66d9ef">OpCode&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">Literal&lt;/span>[], &lt;span style="color:#a6e22e">destination?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">dump&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dump&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>.&lt;span style="color:#a6e22e">reduce&lt;/span>((&lt;span style="color:#a6e22e">acc&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">acc&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">`PUSH &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">ArgRegisters&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dump&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>.&lt;span style="color:#a6e22e">reduce&lt;/span>((&lt;span style="color:#a6e22e">acc&lt;/span>, &lt;span style="color:#a6e22e">arg&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">acc&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">compileArgument&lt;/span>(&lt;span style="color:#a6e22e">arg&lt;/span>, &lt;span style="color:#a6e22e">ArgRegisters&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dump&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">`CALL &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">BuiltinFunctions&lt;/span>[&lt;span style="color:#a6e22e">functionLabel&lt;/span>] &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">functionLabel&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dump&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>.&lt;span style="color:#a6e22e">reduceRight&lt;/span>((&lt;span style="color:#a6e22e">acc&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">acc&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">`POP &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">ArgRegisters&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">destination&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dump&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">`MOV &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">destination&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">, &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">Register&lt;/span>.&lt;span style="color:#a6e22e">RDX&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">dump&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>스택에 올린 기존 레지스터 값들은 역순으로 복원하기 위해 reduceRight 를 사용했다.&lt;/p>
&lt;p>다시 한 번 우리의 AST 를 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>인자 보관용으로 사용할 레지스터를 스택에 올려 두었다면 AST 의 첫 번째 인자를 OpCode 로 할당하고 이어지는 인자를 OpCode 의 인자가 될 리터럴로 간주하여 레지스터에 올려두어야 한다.&lt;/p>
&lt;p>이 과정에서 이어지는 인자가 배열인 경우는 또 다른 함수 호출이 예상되기 때문에 또 다시 OpCode 가 호출되는 재귀 함수 구성을 가지게 된다.&lt;/p>
&lt;p>그래서 인자를 compile 하는 함수는 인자가 배열일 경우를 구분하여 어샘블리 코드를 emit 하도록 하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">compileArgument&lt;/span>(&lt;span style="color:#a6e22e">arg&lt;/span>: &lt;span style="color:#66d9ef">Literal&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Literal&lt;/span>[], &lt;span style="color:#a6e22e">destination&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Array.&lt;span style="color:#a6e22e">isArray&lt;/span>(&lt;span style="color:#a6e22e">arg&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> [&lt;span style="color:#a6e22e">opcode&lt;/span>, ...&lt;span style="color:#a6e22e">rest&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">arg&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">compileFnCall&lt;/span>(&lt;span style="color:#a6e22e">opcode&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">OpCode&lt;/span>, &lt;span style="color:#a6e22e">rest&lt;/span>, &lt;span style="color:#a6e22e">destination&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">`MOV &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">destination&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">, &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">arg&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>배열이 아닌 일반 리터럴이라면 대상 레지스터에 값을 지정하는 것으로 충분하다.&lt;/p>
&lt;p>이제 테스트 코드를 추가하고 AST 를 받아 어셈블리로 컴파일하는 코드를 작성하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">describe&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Emit compiled code for arguments with destication&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">it&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;should return single move statement&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">expected&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;\tMOV RDI, 1\n&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">compileArgument&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;RDI&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">expect&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>).&lt;span style="color:#a6e22e">toEqual&lt;/span>(&lt;span style="color:#a6e22e">expected&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">it&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;should call compileCall function when got array of arguments&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">expected&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#e6db74">tPUSH RDI
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> // ...`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">compileArgument&lt;/span>([&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>], &lt;span style="color:#e6db74">&amp;#39;RSI&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">expect&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>).&lt;span style="color:#a6e22e">toEqual&lt;/span>(&lt;span style="color:#a6e22e">expected&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">describe&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Emit compiled code for function call with opcode and arguments&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">it&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;should return basic assembly code&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">expected&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#e6db74">tPUSH RDI
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> // ...`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">compileFnCall&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">OpCode&lt;/span>, [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">expect&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>).&lt;span style="color:#a6e22e">toEqual&lt;/span>(&lt;span style="color:#a6e22e">expected&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 어셈블리 본문을 완성해 보자. 먼저 prefix, postfix 용 함수를 추가하자. prefix 쪽에 plus 라벨을 가진 ADD 함수를 작성해 두었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">emitPrefix() {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;.global _main_&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;.text&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;plus:&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;ADD RDI, RSI&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;MOV RAX, RDI&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;RET&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;_main_:&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">emitPostfix() {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;MOV RDI, RAX&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Set exit arg in macOS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;MOV RAX, 0x2000001&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Set syscall number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;SYSCALL&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 모든 작업을 완성시킬 compile 함수는 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">compile&lt;/span>(&lt;span style="color:#a6e22e">ast&lt;/span>: &lt;span style="color:#66d9ef">Literal&lt;/span>[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> [&lt;span style="color:#a6e22e">opcode&lt;/span>, ...&lt;span style="color:#a6e22e">rest&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ast&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emitPrefix&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">compileFnCall&lt;/span>(&lt;span style="color:#a6e22e">opcode&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">OpCode&lt;/span>, &lt;span style="color:#a6e22e">rest&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">emitPostfix&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>각 emit 함수가 반환하는 값을 모아서 처리하는 구문은 생략되었으니 저장소의 소스코드를 참고;
&lt;a href="https://github.com/soomtong/simple-lisp-compiler">https://github.com/soomtong/simple-lisp-compiler&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>사용된 테스트 코드를 살펴 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">describe&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Emit basic AST into assembly code&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">it&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;should emit a assembly code!&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">expected&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`// skipped whitespace
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> .global _main_
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> .text
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">plus:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ADD RDI, RSI
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> MOV RAX, RDI
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> RET
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">_main_:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> PUSH RDI
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> // ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> MOV RAX, 0x2000001
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> SYSCALL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">compile&lt;/span>([&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>]]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">expect&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>).&lt;span style="color:#a6e22e">toEqual&lt;/span>(&lt;span style="color:#a6e22e">expected&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>자동으로 스택이 관리되는 것이 이해되면 다음 파트로 이동해 보자.&lt;/p></content></item><item><title>Write Deadly Simple Compiler Part 1</title><link>https://faultnote.github.io/posts/write-simple-compiler-1/</link><pubDate>Sat, 19 Nov 2022 22:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/write-simple-compiler-1/</guid><description>내가 처음으로 구독한 개인 메일인 Phil 의 웹 페이지에 있는 2018년 말 포스트인 &amp;lsquo;Writing a lisp compiler from scratch in JavaScript&amp;rsquo; 를 학습하며 기록한 글이다. 우선 Node 환경에서 구동되는 Lisp 컴파일러를</description><content>&lt;blockquote>
&lt;p>내가 처음으로 구독한 개인 메일인 &lt;a href="https://notes.eatonphil.com">Phil&lt;/a> 의 웹 페이지에 있는 2018년 말 포스트인 &amp;lsquo;Writing a lisp compiler from scratch in JavaScript&amp;rsquo; 를 학습하며 기록한 글이다.&lt;/p>
&lt;/blockquote>
&lt;p>우선 Node 환경에서 구동되는 Lisp 컴파일러를 구현하는 투토리얼을 따라가 보도록 한다. 본문은 여기에 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html">https://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>시리즈의 목표는 아래와 같은 코드를 계산하는 프로그램을 만드는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scheme" data-lang="scheme">&lt;span style="display:flex;">&lt;span>(+ &lt;span style="color:#ae81ff">1&lt;/span> (+ (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 과정에서 &amp;lsquo;파싱&amp;rsquo;, &amp;lsquo;코드 생성&amp;rsquo;, &amp;lsquo;어셈블리 기본&amp;rsquo;, &amp;lsquo;시스템 콜&amp;rsquo; 에 대한 내용을 다루지만 &amp;lsquo;함수 정의&amp;rsquo;, &amp;lsquo;비 심볼/비 산술 데이터 타입&amp;rsquo;, &amp;lsquo;3개 이상의 인자 전달&amp;rsquo;, &amp;lsquo;예외 처리&amp;rsquo;, &amp;lsquo;에러 핸들링&amp;rsquo; 등은 다루지 않는다.&lt;/p>
&lt;h2 id="파싱">파싱&lt;/h2>
&lt;p>이 강의는 보통 lisp 계열의 프로그래밍 언어에서 사용되는 S-expression 문법을 처리하는 컴파일러를 만드는 것이다. S-expression(Symbolic expression)은 구조적인 데이터를 표현하는 방법 중 하나로 이 문법은 비교적 파싱하기 쉽기 때문에 각종 구문 트리를 표현하는 언어로 선택되곤 한다. 그래서 많은 파서들의 추상화 단계로 S-expression 을 사용한다. 이 내용에 대해서는 다른 포스트로 정리할 예정이다.&lt;/p>
&lt;p>그리고, 우리의 프로그램은 기능이 제한적이기 때문에 렉싱lexing과 파싱parsing 단계를 나누지 않고 진행한다.&lt;/p>
&lt;p>렉서와 파서를 통해 컴파일러를 만드는 것은 다음 기회에 살펴보자. 또는 파서와 렉서를 만들어 보는 시간을 가지는 것도 좋겠다.&lt;/p>
&lt;blockquote>
&lt;p>언어 문법을 디자인하고 파싱하고 렉싱하는 유명한 소프트웨어들이 있다. 해당 언어를 위한 파서를 만들어주는 프로그램도 있다. lex, yacc, bison, menhir, peg, antlr, lalrpop 등 본격적으로 언어를 만든다면 이런 툴을 사용하지 않을까?
&lt;a href="https://en.wikipedia.org/wiki/Comparison_of_parser_generators">https://en.wikipedia.org/wiki/Comparison_of_parser_generators&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>파서는 &lt;code>구문 추상 트리abstract syntax tree&lt;/code> 를 만들어 낸다. 트리 구조는 중첩된 배열로 표현된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> (&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>)) &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>처음 이 과제를 자바스크립트가 아닌 다른/새로운 언어를 공부하면서 연습해 보면서 구현하려 했다. 하지만, 디자인도 안나왔는데 테스트 코드를 작성하는 것처럼 어색한게 진도가 나가지 않았다. 익숙한 언어로 먼저 진행해 보자.&lt;/p>
&lt;ol>
&lt;li>TypeScript&lt;/li>
&lt;li>Grain&lt;/li>
&lt;li>Zig&lt;/li>
&lt;/ol>
&lt;p>정도 경험해 보면 어떨까 싶다.&lt;/p>
&lt;p>먼저 parse 함수를 만들자. parse 함수는 아래의 형태를 가질 것이다. 타입 정보는 과정이 진행되면서 개선해 간다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">program&lt;/span>: &lt;span style="color:#66d9ef">unknown&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">unknown&lt;/span>[] &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span>: &lt;span style="color:#66d9ef">unknown&lt;/span>[] &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// todo:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>소스 코드를 program 으로 받아 어떤 처리를 하여 AST(abstract syntax tree)를 얻어낸다. parse 함수는 처리가 성공하면 반환되는 결과의 두 번째 요소에 빈 문자열을 전달하는 것으로 규칙을 삼았다.&lt;/p>
&lt;blockquote>
&lt;p>그래도 왜 반환이 [tokens, &amp;lsquo;&amp;rsquo;] 인지 아직 모르겠다. 그냥 타입을 이렇게 작성한 거라면 나중에 바꾸도록 하자.&lt;/p>
&lt;/blockquote>
&lt;p>공백이나 괄호를 만날 때까지 문자열을 더해 토큰을 만들어 추가하는 코드로 개선해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">program&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">unknown&lt;/span>[] &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>)[] &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (&lt;span style="color:#a6e22e">char&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// todo:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// todo:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(Number.isFinite(&lt;span style="color:#a6e22e">currentToken&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> Number(&lt;span style="color:#a6e22e">currentToken&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>계산을 위해 숫자인 경우는 연산 가능한 타입으로 변경해 주고 있다.&lt;/p>
&lt;p>그 다음은 괄호를 만나게 되는 경우를 처리하자.&lt;/p>
&lt;p>괄호를 열면 또 다시 파싱할 문자열이 들어있다. 즉, 재귀 가능한 구조라는 것이다. 여는 괄호 코드를 구현하기 전에 닫는 괄호를 먼저 구성하자.&lt;/p>
&lt;p>단어를 읽다가 닫는 괄호를 만나면 여기까지 토큰을 저장하고 재귀 호출한 parse 함수에게 현재까지 모아둔 토큰과 이어서 처리해야할 남은 문자열을 반환한다.&lt;/p>
&lt;p>남은 문자열 반환을 위해 substring 이 필요해 for of 대신 forEach 를 사용하기로 했다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">program&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">unknown&lt;/span>[] &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>)[] &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">forEach&lt;/span>((&lt;span style="color:#a6e22e">char&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (&lt;span style="color:#a6e22e">char&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// todo:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(Number.isFinite(&lt;span style="color:#a6e22e">currentToken&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> Number(&lt;span style="color:#a6e22e">currentToken&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이제 여는 괄호의 코드를 구성하자. 재귀 호출이 시작되는 구간이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">program&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>[] &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>)[] &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Array.&lt;span style="color:#66d9ef">from&lt;/span>(&lt;span style="color:#a6e22e">program&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>((&lt;span style="color:#a6e22e">char&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (&lt;span style="color:#a6e22e">char&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> [&lt;span style="color:#a6e22e">parsedToken&lt;/span>, &lt;span style="color:#a6e22e">rest&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">parsedToken&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(Number.isFinite(&lt;span style="color:#a6e22e">currentToken&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> Number(&lt;span style="color:#a6e22e">currentToken&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>정상적으로 종료되는 경우 반환은 파싱된 토큰 뭉치와 빈 문자열인게 납득이 된다. 더 이상 파싱할 문자열이 없을 때에 해당되는 것이다.&lt;/p>
&lt;p>대강 이 쯤 되니 spec 파일을 만들 수 있을 것 같다. 테스트 케이스를 만들고 타입 정보를 제대로 구성해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">parse&lt;/span> } &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#39;./parser&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">describe&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Parse s-expression&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">it&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;should parse basic expression&amp;#39;&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">source&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(+ 3 (+ 1 2)&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">expected&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [[[&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>]]], &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">source&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">expect&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>).&lt;span style="color:#a6e22e">toEqual&lt;/span>(&lt;span style="color:#a6e22e">expected&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>따로 분리한 타입 정보는 우선 이 정도로 구성되었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Token&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Token&lt;/span>[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ParsedTokens&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#a6e22e">Token&lt;/span>, &lt;span style="color:#a6e22e">Program&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>제대로 동작하지 않는 첫 파서는 아래와 같다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> { &lt;span style="color:#a6e22e">Program&lt;/span>, &lt;span style="color:#a6e22e">Token&lt;/span>, &lt;span style="color:#a6e22e">ParsedTokens&lt;/span> } &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#39;./parser.type&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">program&lt;/span>: &lt;span style="color:#66d9ef">Program&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">ParsedTokens&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">tokens&lt;/span>: &lt;span style="color:#66d9ef">Token&lt;/span>[] &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span>: &lt;span style="color:#66d9ef">Token&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// eslint-disable-next-line @typescript-eslint/ban-ts-comment
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// @ts-ignore
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Array.&lt;span style="color:#66d9ef">from&lt;/span>(&lt;span style="color:#a6e22e">program&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>((&lt;span style="color:#a6e22e">char&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">index&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (&lt;span style="color:#a6e22e">char&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> [&lt;span style="color:#a6e22e">parsedToken&lt;/span>, &lt;span style="color:#a6e22e">rest&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">parsedToken&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// reset rest and index?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(Number.isNaN(Number(&lt;span style="color:#a6e22e">currentToken&lt;/span>)) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span> : &lt;span style="color:#66d9ef">Number&lt;/span>(&lt;span style="color:#a6e22e">currentToken&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(Number.isNaN(Number(&lt;span style="color:#a6e22e">currentToken&lt;/span>)) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">currentToken&lt;/span> : &lt;span style="color:#66d9ef">Number&lt;/span>(&lt;span style="color:#a6e22e">currentToken&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>재귀 함수를 통해 처리된 다음 프로그램이 또 다시 파싱되어 배열이 필요 이상 중첩되는 결과를 만나게 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>console.dir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, 3, &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, 1, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">]&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, 1, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>, 1, &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>재귀 함수를 통해 반환 된 나머지 프로그램 코드에 대해 다시 tokenize 를 할 필요가 없기 때문에 재귀 함수를 통해 처리된 토크을 제외한 나머지 프로그램만 이전 parse 단계를 가지도록 프로그램 문자열을 추려 낼 필요가 있게 되어 forEach 를 전통적인 인덱스를 가지는 for 문으로 변경해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>파서는 문자열 커서를 앞으로 뒤로 이동하며 토큰을 생성해 내는데 재귀 함수를 통해 처리한 내용은 건너 뛰어야 하는 기능이 필요한 것이다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">getToken&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">source&lt;/span>: &lt;span style="color:#66d9ef">Program&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Token&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> (Number.isNaN(Number(&lt;span style="color:#a6e22e">source&lt;/span>)) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">source&lt;/span> : &lt;span style="color:#66d9ef">Number&lt;/span>(&lt;span style="color:#a6e22e">source&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">charAt&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (&lt;span style="color:#a6e22e">char&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> [&lt;span style="color:#a6e22e">parsedToken&lt;/span>, &lt;span style="color:#a6e22e">restProgram&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">parsedToken&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// reset program with skipped by recursive and index to 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">restProgram&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">getToken&lt;/span>(&lt;span style="color:#a6e22e">currentToken&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">tokens&lt;/span>, &lt;span style="color:#a6e22e">program&lt;/span>.&lt;span style="color:#a6e22e">substring&lt;/span>(&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tokens&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">getToken&lt;/span>(&lt;span style="color:#a6e22e">currentToken&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentToken&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">char&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>파싱 함수 반복문을 Phil 의 코드에 맞게 수정하고 &lt;code>npm t&lt;/code> 를 통해 테스트를 성공시켰다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&amp;gt; simple-compiler@0.1.0 test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; jest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PASS src/parser.spec.ts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Parse s-expression
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ✓ should parse basic expression &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> ms&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Test Suites: &lt;span style="color:#ae81ff">1&lt;/span> passed, &lt;span style="color:#ae81ff">1&lt;/span> total
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tests: &lt;span style="color:#ae81ff">1&lt;/span> passed, &lt;span style="color:#ae81ff">1&lt;/span> total
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Snapshots: &lt;span style="color:#ae81ff">0&lt;/span> total
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time: 1.161 s, estimated &lt;span style="color:#ae81ff">2&lt;/span> s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Ran all test suites.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이어 파싱된 데이터를 어셈블리로 변환하는 단계로 넘어가자.&lt;/p>
&lt;p>어셈블리를 바이너리로 변환하는 것은 gcc 나 llvm 의 도움을 받는다.&lt;/p></content></item><item><title>마이크로서비스 도입 이렇게 한다</title><link>https://faultnote.github.io/posts/monolith-to-microservices/</link><pubDate>Mon, 03 Oct 2022 00:00:00 +0000</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/monolith-to-microservices/</guid><description>마이크로서비스 이렇게 한다 책 소개 샘 뉴먼의 두 번째 마이크로서비스 책인데, 첫 책은 마이크로서비스의 개념, 필요성과 적용 패턴 등이 소개되었을 것 같고 몇 년 후 나온</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
마이크로서비스 이렇게 한다
&lt;/h2>
&lt;/div>
&lt;div id="outline-container-headline-2" class="outline-2">
&lt;h2 id="headline-2">
책 소개
&lt;/h2>
&lt;div id="outline-text-headline-2" class="outline-text-2">
&lt;p>
샘 뉴먼의 두 번째 마이크로서비스 책인데, 첫 책은 마이크로서비스의 개념, 필요성과 적용 패턴 등이 소개되었을 것 같고 몇 년 후 나온 이 책은 좀 더 실용적인 부분에 집중하여 소개하고 있을 것 같다.
역자는 박재호 님, 케누님과 유튜브 채널을 운영하고 계시는 그분 맞다.&lt;/p>
&lt;p>
마이크로서비스는 &amp;#39;마이크로&amp;#39; &amp;#39;서비스&amp;#39; 라고 쓰지 않고 &amp;#39;마이크로서비스&amp;#39; 라고 쓴다. 이 부분도 주의할 부분.&lt;/p>
&lt;blockquote>
&lt;p>소프트웨어 엔지니어링에 관련된 용어들이 많이 그렇지만 해당 단어의 의미를 일반적인 의미로 해석하면 안 된다. 흔하게 사용되는 용어더라도 이들은 고유 명사로 이해하고 원래 의미를 파악해야 한다. 이게 번역의 어려움이기도 한데 &amp;#39;Prodcudual Programming&amp;#39; 을 절차적 프로그래밍이라고 이해하면 안 된다는 것이다. 프로시줠 프로그래밍의 의미를 알아야 한다.&lt;/p>
&lt;/blockquote>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-2">
&lt;h2 id="headline-3">
1장: 더도 덜도 아닌 마이크로서비스
&lt;/h2>
&lt;div id="outline-text-headline-3" class="outline-text-2">
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
정의
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;p>
마이크로서비스는 비즈니스 도메인 중심으로 모델링 된 독립적인 서비스를 배포하는 것에 대한 주제를 다룬다. 즉, 배포에 대한 이야기 이다.
마이크로가 중요한 단어이긴 하지만 얼마나 마이크로 하냐는 그다음 문제인 것이다. 배포가 핵심이다.&lt;/p>
&lt;p>
그러면 배포 단위가 주요 주제일 텐데 하나로 배포하면 그게 모노리스;
이어서 미루어보면 모델링에 대한 내용이 중요하다는 느낌을 준다.&lt;/p>
&lt;p>
상호 간의 통신은 네트워크로 통신한다.&lt;/p>
&lt;p>
서비스 경계는 마이크로서비스의 가장 핫한 주제 중 하나; 보고 들은 경험적으로 보면 완전 케이스 바이 케이스.&lt;/p>
&lt;div id="outline-container-headline-5" class="outline-4">
&lt;h4 id="headline-5">
독립 배포 가능성
&lt;/h4>
&lt;div id="outline-text-headline-5" class="outline-text-4">
&lt;p>
독립 배포가 가능하려면 서비스 간 결합도가 낮아야 한다. 아니 없어야 한다. 결합도가 없어야 한다는 건 다른 서비스를 변경하지 않고 특정 서비스를 변경할 수 있어야 한다. 변경이란 것은 배포한다는 것을 말 함.&lt;/p>
&lt;p>
경계를 지정하는 것에 대한 고민이 벌써 깊어진다. 데이터베이스에 대한 공유는 당연한 주제라 책 후반부에 따로 언급하고 있을 것이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-4">
&lt;h4 id="headline-6">
비즈니스 도메인 모델링
&lt;/h4>
&lt;div id="outline-text-headline-6" class="outline-text-4">
&lt;p>
책에서는 CD를 판매하는 대규모 다국적 기업에 대한 예를 들고 있다. UI 개발과 백엔드 개발, 그리고 데이터베이스 운영 팀이 상호 협력한다. 전형적인 3 tier 구성이다.&lt;/p>
&lt;p>
그리고 콘웨이의 법칙을 들어 이 구성을 설명하고 있다.&lt;/p>
&lt;p>
대안으로 나온 아키텍처는 도메인 속성이 추가되었다. 기존 요구사항이 고객을 중심으로 펼쳐진다.
좋다. 그렇지만 이 구성은 좀 더 넓은 개발자의 역량을 요구한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-4">
&lt;h4 id="headline-7">
데이터 소유권
&lt;/h4>
&lt;div id="outline-text-headline-7" class="outline-text-4">
&lt;p>
공유 자원이 없을 수는 없을 것이다. 단지 어떻게 공유하고 숨길 것인가에 대한 경계가 필요하다.
모놀리스 데이터베이스를 분리하는 과정은 4장에서 따로 다룬다.&lt;/p>
&lt;p>
아무튼, 이렇게 인터페이스를 잘 정의하는 게 중요하고도 어렵다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-4">
&lt;h4 id="headline-8">
장점
&lt;/h4>
&lt;div id="outline-text-headline-8" class="outline-text-4">
&lt;p>
독립 배포가 가능한 곳에서 오는 모든 것들이 장점이다.
하지만 공짜 점심은 없다는 점이다. 트레이드-오프를 위해 어떤 목표를 가지고 있는지 스스로 파악해야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-9" class="outline-4">
&lt;h4 id="headline-9">
단점
&lt;/h4>
&lt;div id="outline-text-headline-9" class="outline-text-4">
&lt;p>
지금은 웹 서비스가 대세지만 예전, 지금도 일부 레거시 시스템들은 커다란 단일 컴퓨터에 서비스를 배포하고 서버를 운영한다. 그러면서 분산 시스템이 연구되고 도입되었는데 분산 시스템은 네트워킹을 바탕으로 설계되어 있다. 지금은 아주 빠른 네트워크 시스템이 구성되고 있지만 여전히 내부 시스템의 속도와는 비교할 수 없는 병목이 된다. 이는 트랜잭션과 안정성을 포기하게 만들고 더 많은 고민을 하게 한다.&lt;/p>
&lt;p>
하지만 현시점에서도 모놀리스 시스템도 멀티 티어이고 이들은 네트워크를 통해 연결되어 있다. 마이크로서비스의 단점이라고 보기 힘들다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-10" class="outline-4">
&lt;h4 id="headline-10">
기타 주제
&lt;/h4>
&lt;div id="outline-text-headline-10" class="outline-text-4">
&lt;p>
UI 문제, 마이크로서비스를 구축하기 위한 기술들, 마이크로서비스 구성의 규모 등도 주요한 주제이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-11" class="outline-4">
&lt;h4 id="headline-11">
소유권 문제
&lt;/h4>
&lt;div id="outline-text-headline-11" class="outline-text-4">
&lt;p>
IT와 비즈니스 오너의 간극 등으로 작은 배포, 작은 PO 형태가 이상적이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-12" class="outline-3">
&lt;h3 id="headline-12">
모놀리스 검토
&lt;/h3>
&lt;div id="outline-text-headline-12" class="outline-text-3">
&lt;p>
마이크로서비스 이전을 하기 위해 모놀리스 형태도 이해해야 한다.
단일 프로세스(프로그램/프로세스 그 프로세스이다), 분산 모놀리스, 외부 블랙박스 시스템이 모놀리스 시스템으로 간주된다.&lt;/p>
&lt;div id="outline-container-headline-13" class="outline-4">
&lt;h4 id="headline-13">
단일 프로세스 모놀리스
&lt;/h4>
&lt;div id="outline-text-headline-13" class="outline-text-4">
&lt;p>
단일 코드로 구성되고 단일 프로세스로 묶어 배포된다. 서비스 규모에 따라 인스턴스는 여러 벌 뜨지만 코드는 하나이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-14" class="outline-4">
&lt;h4 id="headline-14">
분산 모놀리스
&lt;/h4>
&lt;div id="outline-text-headline-14" class="outline-text-4">
&lt;p>
여러 서비스로 구성되어 있지만 함께 배포되어야 하는 시스템이다. 결합도가 높은 아키텍처 때문에 아직 남아 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-15" class="outline-4">
&lt;h4 id="headline-15">
블랙박스 시스템
&lt;/h4>
&lt;div id="outline-text-headline-15" class="outline-text-4">
&lt;p>
일부 마이그레이션을 통해 분리되긴 했지만 더 이상 유지보수가 되지 않고 화석처럼 남아 사용되고 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-16" class="outline-4">
&lt;h4 id="headline-16">
모놀리스의 문제
&lt;/h4>
&lt;div id="outline-text-headline-16" class="outline-text-4">
&lt;p>
소유권과 경계가 복잡하고 배포 경합이 있어 서비스 운영/배포에 병목이 생긴다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-17" class="outline-4">
&lt;h4 id="headline-17">
모놀리스의 장점
&lt;/h4>
&lt;div id="outline-text-headline-17" class="outline-text-4">
&lt;p>
당연히 장점도 많다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-18" class="outline-3">
&lt;h3 id="headline-18">
결합도와 응집력
&lt;/h3>
&lt;div id="outline-text-headline-18" class="outline-text-3">
&lt;p>
응집도가 높고 결합도가 낮을 때 안정적이다. 코드와 배포 관점에서 둘은 반대로 움직이는 경향이 강하다.&lt;/p>
&lt;div id="outline-container-headline-19" class="outline-4">
&lt;h4 id="headline-19">
응집력
&lt;/h4>
&lt;div id="outline-text-headline-19" class="outline-text-4">
&lt;p>
함께 바뀌고 함께 머무는 코드&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-20" class="outline-4">
&lt;h4 id="headline-20">
결합도
&lt;/h4>
&lt;div id="outline-text-headline-20" class="outline-text-4">
&lt;p>
결합도가 높을수록 함께 변경해야 하는 내용도 많아진다. 다양한 케이스와 해법이 필요.&lt;/p>
&lt;p>
우선 자주 변경되는 것 - 코드나 데이터 - 과 정적인 코드와 분리한다.
추천 서비스에서 보인 예처럼 추천 서비스가 주문 서비스에 강하게 결합될 필요는 없다.
API를 통해 접근하고 사용한다. 또는 적당한 공개 데이터베이스(주로 View로 구성)를 통해 제공된다.&lt;/p>
&lt;p>
이런 패턴은 3,4장에서 더 자세히 다룬다.&lt;/p>
&lt;p>
네트워크를 통한 호출이 일어나기 때문에 동기/비동기 문제가 있다. 이를 시간적 결합도가 존재한다고 말한다.&lt;/p>
&lt;p>
여러 모듈로 구성된 단일 프로세스의 경우 한 모듈이 수정되면 전체 모듈이 다시 배포되어야 한다. 이를 배포 결합도라고 한다.
배포는 늘 위험하다. 이 위험을 줄이는 방법은 변경할 필요가 있는 사항만 배포하는 것이다. 말은 쉽다.&lt;/p>
&lt;p>
배포 결합도를 줄이기 위해 Erlang 같은 솔루션을 고려해 볼 수도 있다.&lt;/p>
&lt;p>
마지막으로 배송 서비스 같은 도메인에서 자주 볼 수 있는 주문과 재고 관련 정보를 처리하는 과정에 발생하는 도메인 결합도를 볼 수 있다. 주문과 재고에는 고객의 신용 카드 정보가 필요 없다.&lt;/p>
&lt;p>
도메인 결합도를 줄이려는 경우 이벤트 주도 시스템이나 pub/sub 패턴 같은 게 도움이 된다. 도메인 주도 설계 과정에서 자세히 알아 본다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-21" class="outline-3">
&lt;h3 id="headline-21">
도메인 주도 설계
&lt;/h3>
&lt;div id="outline-text-headline-21" class="outline-text-3">
&lt;p>
도메인 주도 설계는 마이크로서비스 모델링에 적당한 해결을 제시해 준다.
에릭 에반스의 도메인 주도 설계 내용 중 마이크로서비스 아키텍처에 관한 사항만 알아보자.&lt;/p>
&lt;div id="outline-container-headline-22" class="outline-4">
&lt;h4 id="headline-22">
집계aggregation
&lt;/h4>
&lt;div id="outline-text-headline-22" class="outline-text-4">
&lt;p>
집계 대상이 되는 데이터는 상태를 가진다. 시각에 따라 다른 상태일 수 있다. 따라서 라이프사이클이 있다. 상태 머신으로 표현된다.
외부 시스템으로 인해 상태가 변경될 수 있는데 이를 통제하는 것은 복잡한 일이다. 또, 하나의 집계는 다른 집계 상태와 연관이 된다면 더 복잡해진다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-23" class="outline-4">
&lt;h4 id="headline-23">
경계 컨텍스트
&lt;/h4>
&lt;div id="outline-text-headline-23" class="outline-text-4">
&lt;p>
어디까지 숨기고 어디를 공개할 것인다. 명시적인 책임관계를 기준으로 잡으면 되고, 역시 케바케.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-24" class="outline-4">
&lt;h4 id="headline-24">
마이크로서비스 서비스 경계 매핑
&lt;/h4>
&lt;div id="outline-text-headline-24" class="outline-text-4">
&lt;p>
어그리게이션 단위와 바운디드 컨텍스트 모두 서비스 단위가 될 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-25" class="outline-2">
&lt;h2 id="headline-25">
2장: 마이그레이션 계획하기
&lt;/h2>
&lt;div id="outline-text-headline-25" class="outline-text-2">
&lt;div id="outline-container-headline-26" class="outline-3">
&lt;h3 id="headline-26">
마이크로서비스의 목표 이해
&lt;/h3>
&lt;div id="outline-text-headline-26" class="outline-text-3">
&lt;p>
마이크로서비스는 목표가 아니다.
아키텍처 선택은 의도적 결정이어야 하고 기존 아키텍처로 이룰 수 없는 무언가를 달성하기 위한 전략이어야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-27" class="outline-3">
&lt;h3 id="headline-27">
왜 마이크로서비스를 선택하는가?
&lt;/h3>
&lt;div id="outline-text-headline-27" class="outline-text-3">
&lt;div id="outline-container-headline-28" class="outline-4">
&lt;h4 id="headline-28">
팀의 자율성
&lt;/h4>
&lt;div id="outline-text-headline-28" class="outline-text-4">
&lt;p>
제대로 동작한다는 가정 하에 작은 규모로 구성하고 코드 소유권을 잘 배분하는 것도 좋은 방법이다.
중요한 건, 자율성이 높아지면 남이 도와주길 기다리지 않고 티켓 발행 같은 일을 처리할 필요가 없어진다는 점이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-29" class="outline-4">
&lt;h4 id="headline-29">
출시 시간 단축
&lt;/h4>
&lt;div id="outline-text-headline-29" class="outline-text-4">
&lt;p>
요구사항을 반영하고 배포하는데 필요한 태스크를 병렬 수행하거나 자동화하는 구간을 늘리는 방법이 필요하다. 이런 작업들을 반복하다보면 마이크로서비스가 필요한 시점이 온다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-30" class="outline-4">
&lt;h4 id="headline-30">
고-부하를 다루기
&lt;/h4>
&lt;div id="outline-text-headline-30" class="outline-text-4">
&lt;p>
SaaS 제품을 제공하는 많은 인프라 회사들이 마이크로서비스 아키텍처를 구성해 운영하는 이유이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-31" class="outline-4">
&lt;h4 id="headline-31">
견고하게
&lt;/h4>
&lt;div id="outline-text-headline-31" class="outline-text-4">
&lt;p>
멀티 테넌트는 장애 포인트가 더 많다. 리사일런스 엔지니어링도 주요 과제이다. 넷플릭스의 카오스 엔지니어링 같은 시도도 좋다.&lt;/p>
&lt;p>
마이크로서비스가 아니어도 로드 밸런싱이나 멀티 리전 인스턴스 배포 등으로 견고성을 향상할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-32" class="outline-4">
&lt;h4 id="headline-32">
개발자 수를 늘이기
&lt;/h4>
&lt;div id="outline-text-headline-32" class="outline-text-4">
&lt;p>
맨먼스와 무관하게 마이크로서비스 구축/운영은 더 많은 개발자를 필요로 한다. 다만 마이크로서비스 아키텍처는 개발자 수에 비례해 배포 속도도 개선된다. 물론 팀 간 서비스 소유권이 제대로 조정되고 작업이 분할되어야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-33" class="outline-4">
&lt;h4 id="headline-33">
신기술 수용
&lt;/h4>
&lt;div id="outline-text-headline-33" class="outline-text-4">
&lt;p>
마이크로서비스 아키텍처는 모놀리스에 비해 신기술을 안정적으로 시도할 수 있는 유용성을 제공한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-34" class="outline-3">
&lt;h3 id="headline-34">
마이크로서비스가 나쁜 선택이 되는 경우
&lt;/h3>
&lt;div id="outline-text-headline-34" class="outline-text-3">
&lt;div id="outline-container-headline-35" class="outline-4">
&lt;h4 id="headline-35">
불분명한 도메인
&lt;/h4>
&lt;div id="outline-text-headline-35" class="outline-text-4">
&lt;p>
경계 컨텍스트를 잘못 잡은 경우 마이크로서비스의 도메인이 불분명해진다. SnapCI 의 사례에서도 기존 코드 기반을 마이크로서비스로 분해하는 방식이 여러 면에서 추천된다.&lt;/p>
&lt;p>
그리고 도메인 파악이 미진하면 시스템 분해 보다 도메인 모델링을 먼저 수행해 봐야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-36" class="outline-4">
&lt;h4 id="headline-36">
스타트업
&lt;/h4>
&lt;div id="outline-text-headline-36" class="outline-text-4">
&lt;p>
하지마라, 지금 하지마라. 가 적용되는 상황이다. 넷플릭스, 에어비엔비 등 많은 회사들이 사업이 무르익은 후 마이크로서비스 아키텍처를 도입했다.&lt;/p>
&lt;p>
분명한 경계를 중심으로 분할하고 나머지는 모놀리스로 개발하는 게 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-37" class="outline-4">
&lt;h4 id="headline-37">
고객 설치형/관리형 소프트웨어
&lt;/h4>
&lt;div id="outline-text-headline-37" class="outline-text-4">
&lt;p>
그냥 도커 파일 하나로 끝나는게 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-38" class="outline-4">
&lt;h4 id="headline-38">
좋은 이유를 찾지 못함
&lt;/h4>
&lt;div id="outline-text-headline-38" class="outline-text-4">
&lt;p>
명확한 목표나 비전이 없으면 할 필요 없다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-39" class="outline-3">
&lt;h3 id="headline-39">
균형 조정
&lt;/h3>
&lt;div id="outline-text-headline-39" class="outline-text-3">
&lt;p>
팀의 자율성을 높이기 위해 새로운 프로그래밍 언어를 사용하기 위해 마이크로서비스를 도입하는 것은 우선순위가 혼동되고 있다는 것이다. 보통 기존 모놀리스를 수평으로 확장하는 것이 더 낫다.&lt;/p>
&lt;div id="outline-container-headline-40" class="outline-4">
&lt;h4 id="headline-40">
공감대 형성
&lt;/h4>
&lt;div id="outline-text-headline-40" class="outline-text-4">
&lt;p>
작업자 뿐 아니라 관여자들도 모두 이 여정에 동의해야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-41" class="outline-4">
&lt;h4 id="headline-41">
조직 변화 구현
&lt;/h4>
&lt;div id="outline-text-headline-41" class="outline-text-4">
&lt;p>
코터의 8단계 조직 변화를 위한 과정&lt;/p>
&lt;p>
위기감 조성 → 혁신 추진체 구성 → 비전과 전략 수립 → 변화 비전 전달 → 광범위한 조치를 위한 직원의 자율권 강화 → 단기적인 성과 창출 → 이익 통합과 더 많은 변화 추구 → 혁신 문화의 정립 → 위기감 조성(반복)&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-42" class="outline-4">
&lt;h4 id="headline-42">
점진적 마이그레이션
&lt;/h4>
&lt;div id="outline-text-headline-42" class="outline-text-4">
&lt;p>
작은 부분부터 메인 비즈니스에서 먼 곳부터 시작하자.&lt;/p>
&lt;div id="outline-container-headline-43" class="outline-5">
&lt;h5 id="headline-43">
운영환경
&lt;/h5>
&lt;div id="outline-text-headline-43" class="outline-text-5">
&lt;p>
운영환경에 온전히 정착하기까지 완성된 것이 아니다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-44" class="outline-4">
&lt;h4 id="headline-44">
변화에 드는 비용
&lt;/h4>
&lt;div id="outline-text-headline-44" class="outline-text-4">
&lt;p>
실수에 따른 추가 비용을 효과적으로 완화하기 위해 점진적 변화를 선택한다. 즉, 애자일해야 하는 것이다.&lt;/p>
&lt;div id="outline-container-headline-45" class="outline-5">
&lt;h5 id="headline-45">
가역적 결정과 비가역적 결정
&lt;/h5>
&lt;div id="outline-text-headline-45" class="outline-text-5">
&lt;p>
비가역적 결정은 정말 심사숙고해야 한다. 아마존 베조스가 1종 의사결정이라 부르는 이 비가역적 선택은 신중하게 천천히 이루어져야 한다. 반면 2종 의사결정은 판단력이 뛰어난 개인이나 소그룹이 신속하게 내리고 수행하는 게 좋다.&lt;/p>
&lt;p>
호스팅 회사 변경, 공개된 API 변경 등은 되돌리기 힘들다. 프로그래밍 언어 변경, 데이터베이스 시스템 변경 등은 상대적으로 해 볼 만 하다. 새로운 오픈소스 라이브러리 선택 등은 되돌리기 쉬운 편이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-46" class="outline-5">
&lt;h5 id="headline-46">
실험해 볼만한 곳
&lt;/h5>
&lt;div id="outline-text-headline-46" class="outline-text-5">
&lt;p>
적당한 곳에서 실패를 예상하고 시도해 보는 것을 추천&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-47" class="outline-4">
&lt;h4 id="headline-47">
목표 설정
&lt;/h4>
&lt;div id="outline-text-headline-47" class="outline-text-4">
&lt;p>
도메인 주도 설계가 수반되어야 한다&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-48" class="outline-4">
&lt;h4 id="headline-48">
도메인 주도 설계
&lt;/h4>
&lt;div id="outline-text-headline-48" class="outline-text-4">
&lt;p>
도메인 모델을 정의하면서 서비스 분해의 우선순위를 정한다. 화이트보드에 그림을 그려보면서 경계 컨텍스트 확인해 보자.&lt;/p>
&lt;div id="outline-container-headline-49" class="outline-5">
&lt;h5 id="headline-49">
작업 범위 파악
&lt;/h5>
&lt;div id="outline-text-headline-49" class="outline-text-5">
&lt;p>
전체 시스템의 상세한 도메인 모델을 파악하려 하지 말고 분해를 시작할 위치에 대해 적당한 결정을 내릴 정도의 정보를 바탕으로 진행해 보자. 너무 강박에 쫓기지 말자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-50" class="outline-5">
&lt;h5 id="headline-50">
이벤트 스토밍
&lt;/h5>
&lt;div id="outline-text-headline-50" class="outline-text-5">
&lt;p>
기술 전문가와 비전문가가 함께 참여해 도메인 모델을 정의하는 협업 방식이다.&lt;/p>
&lt;p>
현실적으로 비전문가가 도메인 모델을 온전히 이해하고 있다고 기대하기는 어렵다. 모델에 대한 공통된 이해가 필요하다는 점만 기억하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-51" class="outline-5">
&lt;h5 id="headline-51">
우선순위 지정을 위한 도메인 모델 사용
&lt;/h5>
&lt;div id="outline-text-headline-51" class="outline-text-5">
&lt;p>
종속성이 적은 도메인 모델이 좋은 출발점이다. 문제는 모놀리스 시스템의 코드가 도메인 별로 구분되지 않은 경우도 있다는 것인데… 마이그레이션에 드는 작업 시간 뿐 아니라 난이도를 판별할 수 있는 시각이 필요하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-52" class="outline-4">
&lt;h4 id="headline-52">
결합된 모델
&lt;/h4>
&lt;div id="outline-text-headline-52" class="outline-text-4">
&lt;p>
분해가 쉽고 분해로 인해 얻는 이익이 높은 두 축으로 후보들을 구분하여 추출 대상을 결정한다.
모든 소프트웨어 개발이 그렇듯 막상 해 보니 어려운 것도 있고 생각보다 쉬운 것도 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-53" class="outline-4">
&lt;h4 id="headline-53">
팀 재구성하기
&lt;/h4>
&lt;div id="outline-text-headline-53" class="outline-text-4">
&lt;div id="outline-container-headline-54" class="outline-5">
&lt;h5 id="headline-54">
변화하는 구조
&lt;/h5>
&lt;div id="outline-text-headline-54" class="outline-text-5">
&lt;p>
지금은 데브옵스의 시대를 지나고 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-55" class="outline-5">
&lt;h5 id="headline-55">
만병통치약은 없다
&lt;/h5>
&lt;div id="outline-text-headline-55" class="outline-text-5">
&lt;p>
다른 조직의 설계도를 무작정 복사해 사용하는 것은 위험하다. 스포티파이의 스쿼드, 챕터, 길드 개념이 늘어났지만 깊은 고민 없이 따라 하고 있다. 답보다 질문을 베껴야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-56" class="outline-5">
&lt;h5 id="headline-56">
변화 일으키기
&lt;/h5>
&lt;div id="outline-text-headline-56" class="outline-text-5">
&lt;p>
배포와 관련된 활동과 책임을 명시적으로 나열하는 일부터 시작하자. 이 활동을 기존 조직 구조에 분담시킨다. 이렇게 두면, 클라이언트와 백엔드 그리고 운영 조직이 구분된다. 이어서 팀을 통합하는 과정이 일어난다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-57" class="outline-5">
&lt;h5 id="headline-57">
전문 기술 변경하기
&lt;/h5>
&lt;div id="outline-text-headline-57" class="outline-text-5">
&lt;p>
스스로의 기술을 평가하고 원하는 요구사항을 만족시키기 위해 어떤 지원이 필요한지 확인해야 한다. 물론 모두 최고 수준까지 도달해야 하는 것은 아니다. 스스로 필요한 목표를 달성하기 위해 멘토링을 제공하기 위한 것이다.
이 내용은 비공개로 유지해야 한다. 상위 매니저는 팀 구성과 운영을 위해 기술 지도를 그리고 내부 교육과 투자를 정당화할 수 있어야 한다. 부족한 부분은 외부에서 제공받는 것도 고려할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-58" class="outline-4">
&lt;h4 id="headline-58">
전환 상태 확인
&lt;/h4>
&lt;div id="outline-text-headline-58" class="outline-text-4">
&lt;p>
마이크로서비스 아키텍처로 마이그레이션이 잘 이루어지고 있는지 검증해야 한다.&lt;/p>
&lt;div id="outline-container-headline-59" class="outline-5">
&lt;h5 id="headline-59">
정기 점검 사항
&lt;/h5>
&lt;div id="outline-text-headline-59" class="outline-text-5">
&lt;p>
진로 변경이나 점검을 위한 회고가 필요하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-60" class="outline-5">
&lt;h5 id="headline-60">
정량적인 측정
&lt;/h5>
&lt;div id="outline-text-headline-60" class="outline-text-5">
&lt;p>
출시 시기를 단축하는 목적이라면 배포 주기, 배포 횟수, 실패율 등의 지표를 활용할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-61" class="outline-5">
&lt;h5 id="headline-61">
정성적인 측정
&lt;/h5>
&lt;div id="outline-text-headline-61" class="outline-text-5">
&lt;p>
개발하는 과정에 참여한 사람들의 피드백을 받아보자. 업무를 즐긴다면 좋다. 그렇지 않다면 조치가 필요할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-62" class="outline-5">
&lt;h5 id="headline-62">
매몰 비용
&lt;/h5>
&lt;div id="outline-text-headline-62" class="outline-text-5">
&lt;p>
문제가 존재한다는 것을 무시하지 말아야 한다.
언제든지 변화가 가능해, 언제든지 실패할 수 있어 를 열어두어야 한다.&lt;/p>
&lt;p>
각 단계를 작게 만들자. 방향을 바꾸기 더 쉬워진다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-63" class="outline-5">
&lt;h5 id="headline-63">
새로운 방식을 받아들이자
&lt;/h5>
&lt;div id="outline-text-headline-63" class="outline-text-5">
&lt;p>
매번 산 넘어 산을 마주하게 될 것이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-64" class="outline-2">
&lt;h2 id="headline-64">
3장: 모놀리스 분할
&lt;/h2>
&lt;div id="outline-text-headline-64" class="outline-text-2">
&lt;div id="outline-container-headline-65" class="outline-3">
&lt;h3 id="headline-65">
모놀리스를 그대로 두는 옵션
&lt;/h3>
&lt;div id="outline-text-headline-65" class="outline-text-3">
&lt;p>
모놀리스를 쉽게 뜯어내기 어려운 경우가 늘 있다. 코드가 없는 경우도 있고, 너무 많은 변경 비용이 발생하게 되어 엄두를 못 내는 경우도 있다.&lt;/p>
&lt;div id="outline-container-headline-66" class="outline-4">
&lt;h4 id="headline-66">
잘라내기, 복사하기 또는 재구현
&lt;/h4>
&lt;div id="outline-text-headline-66" class="outline-text-4">
&lt;p>
복사하기가 좋은 선택지가 되는 경우가 많다. 마이그레이션이 완료되면 제거해도 된다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-67" class="outline-4">
&lt;h4 id="headline-67">
모놀리스 리팩토링
&lt;/h4>
&lt;div id="outline-text-headline-67" class="outline-text-4">
&lt;p>
코드를 봉합하는 기법이 있다. 변경 코드 주위를 봉합하고 변경이 이루어진 후 교체한다. 경계를 안전하게 다루는 기법이 &amp;#39;레거시 코드 활용 전략 - 마이클 페더스&amp;#39;에서 소개되고 있다.&lt;/p>
&lt;p>
모듈식 모놀리스로 일단 변경하기만 해도 마이크로서비스 마이그레이션의 목적 일부를 달성하기도 한다.
언제나 모두 점진적 재작성을 수행할 수 있는 상황은 아니다. 분리된 모듈의 기능을 새롭게 구현하는 경우도 많다. 하지만 새로 작성하는게 몇 개월씩 걸린다면 추천하지 않는다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-68" class="outline-3">
&lt;h3 id="headline-68">
마이그레이션 패턴
&lt;/h3>
&lt;div id="outline-text-headline-68" class="outline-text-3">
&lt;p>
기존 시스템을 마이그레이션 하면서 사용할 수 있는 교살자 무화과 패턴을 소개한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-69" class="outline-3">
&lt;h3 id="headline-69">
교살자 무화과 애플리케이션
&lt;/h3>
&lt;div id="outline-text-headline-69" class="outline-text-3">
&lt;p>
무화과나무는 숙주 나무의 위쪽 가지에 씨를 뿌려 숙주 나무를 감싼다. 숙주는 무화과나무의 지지대가 되다 썩어 죽고 스스로 생존하는 무화과 나무가 남게 된다.&lt;/p>
&lt;div id="outline-container-headline-70" class="outline-4">
&lt;h4 id="headline-70">
작동 원리
&lt;/h4>
&lt;div id="outline-text-headline-70" class="outline-text-4">
&lt;p>
기존 모놀리스로 호출되는 요청을 새로 작성한 마이크로서비스로 리디렉션 하는 기법이다.&lt;/p>
&lt;p>
분리된 마이크로서비스와 기존 모놀리스를 병행 실행 같은 패턴을 사용해 의도대로 동작하고 있는지 확신할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-71" class="outline-4">
&lt;h4 id="headline-71">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-71" class="outline-text-4">
&lt;p>
기존 시스템을 건드리거나 변경하지 않고 새 아키텍처로 대응할 수 있다. 특정 기능을 재 구현하는 대신 모놀리스에서 API 만 먼저 분리하는 과정도 좋은 옵션이다. HTTP redirect 는 이런 기능을 위해 명시적으로 디자인된 인터페이스이다. RPC 유형의 프로토콜보다 좋은 점이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-72" class="outline-4">
&lt;h4 id="headline-72">
리버스 프락시 적용
&lt;/h4>
&lt;div id="outline-text-headline-72" class="outline-text-4">
&lt;p>
우선 모놀리스와 통신하는 클라이언트 사이에 프락시를 추가한다. 추가된 네트워크 Hop에 대한 영향도가 있는지 파악해 두어야 한다. 모니터링도 필요하다.&lt;/p>
&lt;p>
새로 구성하는 마이크로서비스는 처음에는 501을 반환한다. 점진적 기능이 구현되고 점진적 릴리즈가 이루어진다.
프락시를 통해 새로 준비된 기능으로 마이그레이션을 완료하는 시나리오이다.&lt;/p>
&lt;p>
기능 토클 옵션을 두고 리디렉션을 하거나 말거나 할 수 있다. 이보다 카나리아 릴리즈 패턴이나 완전 병행 실행 패턴을 통해 점진적 개선을 두는 것도 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-73" class="outline-4">
&lt;h4 id="headline-73">
데이터
&lt;/h4>
&lt;div id="outline-text-headline-73" class="outline-text-4">
&lt;p>
영속성 데이터에 대해서는 4장에 자세히 살펴본다. 지금 단계에서는 모놀리스와 마이크로서비스가 하나의 데이터베이스를 공유한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-74" class="outline-4">
&lt;h4 id="headline-74">
프락시 옵션
&lt;/h4>
&lt;div id="outline-text-headline-74" class="outline-text-4">
&lt;p>
보통 추천되는 솔루션은 Nginx 이다. 각 요청의 매개변수를 제대로 지원하기 위해 프락시 옵션을 점검해야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-75" class="outline-4">
&lt;h4 id="headline-75">
프로토콜 변경
&lt;/h4>
&lt;div id="outline-text-headline-75" class="outline-text-4">
&lt;p>
현재 SOAP 기반 HTTP 인터페이스를 사용하지만 새 마이크로서비스는 gRPC를 지원할 수 있다. 이 방법은 별로 추천되지 않는다. 프락시 자체이 복잡성이 증가하기 때문이다.&lt;/p>
&lt;p>
배포 프로세스가 느려지게 만들지 말자. 파이프는 멍청하게 엔드포인트는 똑똑하게 유지해야 한다. 차라리 새 마이크로서비스에 새 프로토콜을 지원하는 편이 좋다. 그 이상을 원하면 서비스 메시를 도입할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-76" class="outline-4">
&lt;h4 id="headline-76">
FTP 프로토콜을 마이그레이션 사례
&lt;/h4>
&lt;div id="outline-text-headline-76" class="outline-text-4">
&lt;p>
고객 관점에서 큰 변화가 없도록 유지하기 위한 방법이 필요했다. 기존 모놀리스의 FTP 를 가로채고 새로 만들어진 REST HTTP 서비스로 대체했다. 추후 고객에게 REST API 를 제공하여 병행 실행을 완성한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-77" class="outline-4">
&lt;h4 id="headline-77">
메시지 가로채기 사례
&lt;/h4>
&lt;div id="outline-text-headline-77" class="outline-text-4">
&lt;p>
큐에 담긴 이벤트 메시지 일부를 가로채는 작업도 유용하다. 콘텐트 기반 라우터를 도입하는 것인데 이는 똑똑한 파이프가 된다. 유용하긴 하지만 복잡해진다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-78" class="outline-4">
&lt;h4 id="headline-78">
그 외 다양한 프로토콜 대응
&lt;/h4>
&lt;div id="outline-text-headline-78" class="outline-text-4">
&lt;p>
모놀리스의 인바운드 호출을 가로채는 방법으로 대응할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-79" class="outline-4">
&lt;h4 id="headline-79">
다른 예
&lt;/h4>
&lt;div id="outline-text-headline-79" class="outline-text-4">
&lt;p>
마이크로서비스로 이전하는 것이 아니더라도 교살자 무화과 패턴은 자주 사용되었다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-80" class="outline-3">
&lt;h3 id="headline-80">
기능을 마이그레이션 하는 동안 동작 방식 변경하기
&lt;/h3>
&lt;div id="outline-text-headline-80" class="outline-text-3">
&lt;p>
마이그레이션 하면서 기능이 추가/변경되는 경우는 어떻게 될까? 숨겨진 버그가 나타나면 문제가 커진다. 묘책은 없지만 마이그레이션이 완료될 때까지 변경을 허용하지 않는 편이 수월하다. 그래서 마이그레이션에 사용되는 시간이 오래 걸리지 않아야 한다. 변경사항을 복원하는 능력도 고려해야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-81" class="outline-3">
&lt;h3 id="headline-81">
UI 컴포지션 패턴
&lt;/h3>
&lt;div id="outline-text-headline-81" class="outline-text-3">
&lt;p>
온라인 가디언에서 기존 CMS로 부터 새로운 UI를 출시하기로 했다. 전환 과정은 특정분야를 목표로 진행하였다.
심지어 세부 분야에서도 마이그레이션을 더 작은 단위로 쪼개기 위해 노력했다.&lt;/p>
&lt;div id="outline-container-headline-82" class="outline-4">
&lt;h4 id="headline-82">
페이지 단위
&lt;/h4>
&lt;div id="outline-text-headline-82" class="outline-text-4">
&lt;p>
이전 페이지 링크가 새 페이지로 redirect 되면서 새로운 UI/UX 를 제공했다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-83" class="outline-4">
&lt;h4 id="headline-83">
위젯 단위
&lt;/h4>
&lt;div id="outline-text-headline-83" class="outline-text-4">
&lt;p>
Edge Side Include 는 아파치 웹 서버에서 제공하는 기능으로 특정 영역을 새 서비스의 콘텐츠로 채웠다. 요즘은 브라우저 기술이 훌륭하기 때문에 서버 위젯을 사용할 필요는 없다.&lt;/p>
&lt;p>
모놀리스 콘텐츠 오케스트레이션 서비스를 위젯 단위로 분리해 마이그레이션 할 수 있다.&lt;/p>
&lt;p>
모바일 애플리케이션은 하나의 모놀리스이다. 마찬가지로 컴포넌트 단위 UI 도 모두 경계 콘텍스트에 적용할 수 있기 때문에 모바일 앱 배포 없이 UI 를 변경할 수 있는 기술을 통해 서버 코드 변경 만으로 제어된다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-84" class="outline-4">
&lt;h4 id="headline-84">
마이크로 프론트엔드
&lt;/h4>
&lt;div id="outline-text-headline-84" class="outline-text-4">
&lt;p>
단일 페이지 애플리케이션의 시대이다. 위젯 기반 컴포지션의 형태가 될 수밖에 없다.&lt;/p>
&lt;p>
웹 컴포넌트의 적용이 더딘 것이 원인인지 마이크로 프론트엔드라는 이름으로 그리고 아일랜드 아키텍처라는 이름으로 컴포넌트 지향 소프트웨어가 자리잡고 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-85" class="outline-4">
&lt;h4 id="headline-85">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-85" class="outline-text-4">
&lt;p>
사용하고 있는 SPA 기술에 따라 다르다. UI 컴포지션 기법은 뒤에서 다룬다.
서버 위젯은 더더욱 사용되지 않고 있는 추세 같다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-86" class="outline-3">
&lt;h3 id="headline-86">
추상화에 의한 분기 패턴
&lt;/h3>
&lt;div id="outline-text-headline-86" class="outline-text-3">
&lt;p>
기존 코드 베이스를 변경하는 과정은 쉽지 않은 상황으로 가득하다. 추상화 분기 패턴으로 기존 코드를 변경하면서 구현된 코드가 안전하게 동일 버전의 코드에서 공존하고 배포 중단도 최소화할 수 있는 방법을 제공한다.&lt;/p>
&lt;div id="outline-container-headline-87" class="outline-4">
&lt;h4 id="headline-87">
작동 원리
&lt;/h4>
&lt;div id="outline-text-headline-87" class="outline-text-4">
&lt;p>
대체할 기능을 위한 추상화를 만들고 이 인터페이스를 사용하도록 기존 클라이언트를 변경한다. 기능을 대체하기 위해 마이크로서비스를 구현한다. 새로운 구현을 사용하도록 추상화를 전환하자. 기존 구현을 제거한다. 마지막으로 추상화도 제거할 수 있다.&lt;/p>
&lt;p>
기존 구현을 제거할 때 잠시 병행 사용을 위해 제공되던 기능 플래그 구현도 제거하는 편이 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-88" class="outline-4">
&lt;h4 id="headline-88">
대체 메커니즘을 위한 분기 자동화
&lt;/h4>
&lt;div id="outline-text-headline-88" class="outline-text-4">
&lt;p>
기존 기능을 완벽히 마이그레이션 하기 위해 추상화 인터페이스 아래 검증 스위치를 둔다. 1차 구현을 먼저 호출하고 실패하는 경우 2차 구현을 호출하도록 준비한다. 1차 구현은 새 마이크로서비스를 사용하는 것이고 2차 구현은 기존 모놀리스의 기능을 호출하는 것이다.&lt;/p>
&lt;p>
복잡성이 추가되는 건 사실이다. 병행 실행 패턴에서 좀 더 자세히 알아본다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-89" class="outline-4">
&lt;h4 id="headline-89">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-89" class="outline-text-4">
&lt;p>
기존 코드베이스를 변경하는데 시간은 걸리지만 기존 코드를 작업하는 동료를 방해하지 않으려는 상황에 유리하다. 피처 브랜치를 오래 관리하는 것보다 추상화에 의한 분기가 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-90" class="outline-3">
&lt;h3 id="headline-90">
병행 실행 패턴
&lt;/h3>
&lt;div id="outline-text-headline-90" class="outline-text-3">
&lt;p>
교살자 무화과 패턴과 추상화에 의한 분기 패턴은 동일한 기능에 대한 기존 구현과 새로운 구현이 동시에 공존할 수 있게 해 준다. 단, 이 기능은 둘 중 하나를 사용하는 패턴으로 기존 구현으로 쉽게 돌아가는 것에 목적이 있다.&lt;/p>
&lt;p>
병행 실행 패턴은 두 구현 중 하나를 사용하는 대신 둘을 모두 호출해서 사용한다. 동일한 결과를 반환하는지 확인할 수 있다. 사용되는 결과는 둘 중 하나를 사용하는데 신뢰할 수 있을 시점까지 기존 구현을 기준으로 간주한다. 결과를 반환하지 않고 저장하는 경우는 저장된 데이터를 비교해 사용한다.&lt;/p>
&lt;div id="outline-container-headline-91" class="outline-4">
&lt;h4 id="headline-91">
신용파생 상품 가격 비교의 사례
&lt;/h4>
&lt;div id="outline-text-headline-91" class="outline-text-4">
&lt;p>
시스템 이전 전과 후 상태에 대한 검증이 반드시 필요한 부분이다 병행 실행 패턴이 아니면 검증하기 어려웠을 것이다. 기존 가격 정책 시스템은 새 가격 정책 시스템과 함께 사용되는 동안 배치 작업을 통해 계산 결과를 비교하는 기간을 가졌다. 한 달 후 새 시스템으로 전환을 완료하고 기존 시스템을 폐기했다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-92" class="outline-4">
&lt;h4 id="headline-92">
홈게이트 목록의 사례
&lt;/h4>
&lt;div id="outline-text-headline-92" class="outline-text-4">
&lt;p>
항공기 같은 제어 시스템의 경우도 자동 항법 장치가 제공하는 제어와 조종사가 수동으로 제어하는 기능을 모두 내장하고 있다. 병행 실행은 의외로 많은 곳에서 제공되고 있는 패턴이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-93" class="outline-4">
&lt;h4 id="headline-93">
검증
&lt;/h4>
&lt;div id="outline-text-headline-93" class="outline-text-4">
&lt;p>
함수 호출이 아니라 네트워크 호출로 변경되는 경우 레이턴시 문제나 네트워크 장애 등으로 기능이 실패되는 경우가 있다. 이에 대한 보장도 필요하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-94" class="outline-4">
&lt;h4 id="headline-94">
스파이
&lt;/h4>
&lt;div id="outline-text-headline-94" class="outline-text-4">
&lt;p>
테스트에 사용하는 스파이를 적용하는 것도 좋다. 이벤트를 받는 서비스를 마이그레이션 하는 경우 두 번 이상의 이벤트를 받게 될텐데 새로 구현되는 서비스는 스파이를 통해 이벤트를 받고 기록을 남겨 검증에 사용할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-95" class="outline-4">
&lt;h4 id="headline-95">
깃헙 사이언티스트
&lt;/h4>
&lt;div id="outline-text-headline-95" class="outline-text-4">
&lt;p>
깃헙이 만들어 제공하는 Ruby 구현체 말고 다양한 패키지가 공개되어 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-96" class="outline-4">
&lt;h4 id="headline-96">
어둠의 출시와 카나리아 릴리즈
&lt;/h4>
&lt;div id="outline-text-headline-96" class="outline-text-4">
&lt;p>
카나리아 릴리즈는 사용자 중 일부만 새 기능을 안내하고 대부분 기존 구현을 사용하게 하는 패턴이다. 반면 병행 실행은 두 기능을 모두 호출한다. 구글 크롬 브라우저 등이 사용하고 있다.&lt;/p>
&lt;p>
반면 어둠의 출시는 새 기능을 배포하긴 하지만 외부에 노출되지 않기 때문에 사용자는 아직 사용할 수 없다. 마이크로소프트 윈도우즈의 새로운 버전 배포에 자주 사용하고 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-97" class="outline-4">
&lt;h4 id="headline-97">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-97" class="outline-text-4">
&lt;p>
이 구현은 변경되는 기능이 매우 크리티컬 한 경우 자주 사용된다. 구현 과정의 장/단점을 꼼꼼히 따질 필요가 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-98" class="outline-3">
&lt;h3 id="headline-98">
협업자 데코레이터 패턴
&lt;/h3>
&lt;div id="outline-text-headline-98" class="outline-text-3">
&lt;p>
디자인 패턴의 데코레이터 패턴에 착안된 방법이다.&lt;/p>
&lt;div id="outline-container-headline-99" class="outline-4">
&lt;h4 id="headline-99">
멤버십 프로그램 사례
&lt;/h4>
&lt;div id="outline-text-headline-99" class="outline-text-4">
&lt;p>
기존 주문 기능에 맴버쉽 포인트를 추가하는 대신 프락시를 통해 호출을 가로채고 고객에게 제공할 포인트를 결정해 제공한다. 주문은 기존 주문 프로세스를 사용한다.&lt;/p>
&lt;p>
교살자 무화과 패턴의 프락시보다 똑똑한 프락시를 구현해야 한다. 이 프락시는 자체적인 마이크로서비스가 될 정도가 되기도 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-100" class="outline-4">
&lt;h4 id="headline-100">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-100" class="outline-text-4">
&lt;p>
협업자 데코레이터 패턴은 단순할수록 좋다. 모놀리스에 사용되는 요청과 응답 정보에 프락시가 필요한 정보가 있는 상황에 적당하다. 새 기능 추가는 신중하게 고려해야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-101" class="outline-3">
&lt;h3 id="headline-101">
변경 데이터 캡처 패턴
&lt;/h3>
&lt;div id="outline-text-headline-101" class="outline-text-3">
&lt;p>
모놀리스로 인바운드 호출을 가로채는 대신 데이터 저장소에 변경된 데이터를 사용하는 패턴이다.&lt;/p>
&lt;div id="outline-container-headline-102" class="outline-4">
&lt;h4 id="headline-102">
멤버십 카드 발급 사례
&lt;/h4>
&lt;div id="outline-text-headline-102" class="outline-text-4">
&lt;p>
협업자 데코레이터를 사용해 요청과 응답에 수정을 가하는 대신 모놀리스 데이터베이스의 변경 정보에 이벤트를 생성해 추가 기능을 구현한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-103" class="outline-4">
&lt;h4 id="headline-103">
변경 데이터 캡처 구현
&lt;/h4>
&lt;div id="outline-text-headline-103" class="outline-text-4">
&lt;p>
데이터베이스의 트리거를 사용할 수 있다. 트리거는 다른 프로시저처럼 데이터베이스 시스템 내에 설치/작성되어야 한다는 단점이 있다. 오라클 같은 데이터베이스 시스템의 경우 외부 코드를 호출하는 기능이 잘 정의되어 있기도 하다.&lt;/p>
&lt;p>
보통 트랜잭션 로그를 사용한다. Mysql의 경우 binlog라고 불리는 트랜잭션 로그가 있다.&lt;/p>
&lt;p>
또는, 별도의 프로그램을 개발하여 diff를 파악하고 처리하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-104" class="outline-4">
&lt;h4 id="headline-104">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-104" class="outline-text-4">
&lt;p>
코드베이스 변경이 불가능한 경우, 데이터를 복제할 필요가 있는 경우 유용한 패턴이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-105" class="outline-2">
&lt;h2 id="headline-105">
4장: 데이터베이스 분해
&lt;/h2>
&lt;div id="outline-text-headline-105" class="outline-text-2">
&lt;p>
마이크로서비스 아키텍처 이관의 가장 큰 난제는 데이터를 어떻게 분리해야 하는 것이다.&lt;/p>
&lt;div id="outline-container-headline-106" class="outline-3">
&lt;h3 id="headline-106">
공유 데이터베이스 패턴
&lt;/h3>
&lt;div id="outline-text-headline-106" class="outline-text-3">
&lt;p>
결합도는 도메인 결합도, 시간적 결합도, 구현의 결합도로 구분할 수 있는데 데이터베이스 공유는 구현 결합도에 속하며 가장 큰 비중을 차지한다.&lt;/p>
&lt;p>
공유 데이터베이스를 기반으로 여러 서비스로 분리하는 어려움은 뷰를 통해 완화할 수 있지만 완벽한 해법은 아니다.&lt;/p>
&lt;p>
마이크로서비스는 하나의 상태 머신이 되어야 한다. 상태를 변경하는 주체가 자신 말고 다른 곳에서 이루어진다면 올바른 마이크로서비스가 아니다.&lt;/p>
&lt;div id="outline-container-headline-107" class="outline-4">
&lt;h4 id="headline-107">
패턴 다루기
&lt;/h4>
&lt;div id="outline-text-headline-107" class="outline-text-4">
&lt;p>
각 마이크로서비스 스스로 데이터를 소유할 수 있도록 데이터베이스를 분리하는 방식이 항상 선호된다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-108" class="outline-4">
&lt;h4 id="headline-108">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-108" class="outline-text-4">
&lt;p>
읽기 전용 정적 참조 데이터를 고려하는 경우는 공유 데이터베이스라도 괜찮다. 외부에 공개되는 것을 전제로 한 데이터베이스도 이 패턴을 적용해도 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-109" class="outline-3">
&lt;h3 id="headline-109">
그렇지만 안된다
&lt;/h3>
&lt;div id="outline-text-headline-109" class="outline-text-3">
&lt;p>
작업 시간이 오래 걸리거나 시스템의 민감한 부분을 변경해야 하는 경우 스키마를 나누는 것은 정말 위험하다. 다른 방법을 알아보자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-110" class="outline-3">
&lt;h3 id="headline-110">
데이터베이스 뷰 패턴
&lt;/h3>
&lt;div id="outline-text-headline-110" class="outline-text-3">
&lt;p>
데이터베이스 뷰를 통해 결합도 관련 문제를 완화할 수 있다. 접근해서는 안 되는 정보를 은닉할 수 있는 점도 좋다.&lt;/p>
&lt;div id="outline-container-headline-111" class="outline-4">
&lt;h4 id="headline-111">
공개된 계약으로서 데이터베이스
&lt;/h4>
&lt;div id="outline-text-headline-111" class="outline-text-4">
&lt;p>
3장 사례에서 본 대로 공개된 데이터베이스는 쉽게 바꿀 수 없다. 스키마를 변경 불가능한 경우가 존재한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-112" class="outline-4">
&lt;h4 id="headline-112">
표현할 뷰 제공
&lt;/h4>
&lt;div id="outline-text-headline-112" class="outline-text-4">
&lt;p>
읽기만 제공하는 클라이언트를 위해 원본 스키마를 대체하는 전용 스키마 뷰를 호스팅 하면 원본 스키마를 변경할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-113" class="outline-4">
&lt;h4 id="headline-113">
한계
&lt;/h4>
&lt;div id="outline-text-headline-113" class="outline-text-4">
&lt;p>
모든 데이터베이스 시스템이 뷰를 제공하지 않는다. 뷰 엔진이 메인 데이터베이스 안에 있어야 하는 제약이 있는 경우도 있다. 즉, 물리적인 배포 결합도가 여전히 남아 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-114" class="outline-4">
&lt;h4 id="headline-114">
소유권
&lt;/h4>
&lt;div id="outline-text-headline-114" class="outline-text-4">
&lt;p>
뷰의 소유권이 애매한 것도 문제다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-115" class="outline-4">
&lt;h4 id="headline-115">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-115" class="outline-text-4">
&lt;p>
기존 모놀리스 스키마를 분해하는 것이 실용적이지 못할 때 뷰를 고려해 보면 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-116" class="outline-3">
&lt;h3 id="headline-116">
데이터베이스 래핑 서비스 패턴
&lt;/h3>
&lt;div id="outline-text-headline-116" class="outline-text-3">
&lt;p>
다루기 너무 복잡한 경우 혼란을 숨기는 편이 좋다. 데이터베이스에 접근하는 서비스를 감싸 데이터베이스 종속성을 서비스 종속성으로 이동시키는 패턴이다.&lt;/p>
&lt;div id="outline-container-headline-117" class="outline-4">
&lt;h4 id="headline-117">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-117" class="outline-text-4">
&lt;p>
스키마 분리가 힘든 경우 좋은 방법이다. 관리 가능한 인터페이스가 구성되면 스텁을 추가하는 것처럼 테스트하기에도 용이해진다.&lt;/p>
&lt;p>
점진적 개선의 목표에 잘 어울리는 패턴이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-118" class="outline-3">
&lt;h3 id="headline-118">
서비스 as 데이터베이스 인터페이스 패턴
&lt;/h3>
&lt;div id="outline-text-headline-118" class="outline-text-3">
&lt;p>
읽기 전용의 새로운 데이터베이스를 추가한다. 이 데이터베이스는 기존 데이터베이스의 변경사항을 가져와 반영된다. 기존 데이터베이스에 접근을 옮기는 것이다. 새 데이터가 지연되는 문제와 신선하지 않은, stale 상태의 데이터를 보고 있어야 하는 경우도 있다.&lt;/p>
&lt;div id="outline-container-headline-119" class="outline-4">
&lt;h4 id="headline-119">
매핑 엔진 구현
&lt;/h4>
&lt;div id="outline-text-headline-119" class="outline-text-4">
&lt;p>
트랜잭션 로그를 사용하는 변경 데이터 캡처 시스템이 좋은 옵션이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-120" class="outline-4">
&lt;h4 id="headline-120">
뷰와 비교
&lt;/h4>
&lt;div id="outline-text-headline-120" class="outline-text-4">
&lt;p>
DaaS 패턴은 데이터베이스 뷰 패턴보다 훨씬 정교하다. 데이터베이스 시스템의 종류에 관계없이 구성할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-121" class="outline-4">
&lt;h4 id="headline-121">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-121" class="outline-text-4">
&lt;p>
공개된 데이터베이스는 읽기 전용이다. 여기에서 더 발전된다면 데이터 웨어하우스 구축이 필요한 수준이 된다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-122" class="outline-3">
&lt;h3 id="headline-122">
소유권 양도
&lt;/h3>
&lt;div id="outline-text-headline-122" class="outline-text-3">
&lt;p>
모놀리스에서 서비스를 분리할 때 어떤 데이터는 서비스와 함께 이동하지만 어떤 데이터는 원래 위치에 있어야 한다.&lt;/p>
&lt;div id="outline-container-headline-123" class="outline-4">
&lt;h4 id="headline-123">
집계를 외부에 공개하는 모놀리스 패턴
&lt;/h4>
&lt;div id="outline-text-headline-123" class="outline-text-4">
&lt;p>
모놀리스에 외부로 공개되는 인터페이스를 추가하고 이를 마이크로서비스가 사용하도록 한다.
외부에 API를 공개하는 과정에 바운디드 컨텍스트를 발견할 수 있을 것이다. 아직 자신만의 데이터베이스를 소유하지 않더라도 이들은 새로운 마이크로서비스로 분해된다.&lt;/p>
&lt;p>
뷰를 제공하는 것보다 유연하게 대응할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-124" class="outline-4">
&lt;h4 id="headline-124">
데이터 소유권 변경 패턴
&lt;/h4>
&lt;div id="outline-text-headline-124" class="outline-text-4">
&lt;p>
모놀리스와 새 마이크로서비스가 같은 데이터베이스를 공유하는 과정이 지나면 모놀리스는 새로운 마이크로서비스로 종단점을 옮기는 작업을 수행한다.&lt;/p>
&lt;p>
데이터 소유권이 모놀리스에서 마이크로서비스로 옮겨진 것이다.
모놀리스에 스키마를 직접 조회해야 한다면 뷰를 제공하는 것도 괜찮다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-125" class="outline-3">
&lt;h3 id="headline-125">
데이터 동기화
&lt;/h3>
&lt;div id="outline-text-headline-125" class="outline-text-3">
&lt;p>
교살자 무화과 패턴 등은 새로운 서비스와 기존 서비스로 스위칭할 수 있는 기능이 제공된다. 하지만 데이터베이스가 분리된 상태라면 어떨까? 공유 데이터베이스를 유지해야 하는 기간이 필요하다.&lt;/p>
&lt;p>
코드와 데이터를 동시에 마이그레이션하는 빅뱅 전환은 가능하면 피하도록 하자.
스키마 변경이 있었다면 어떻게 할까?&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-126" class="outline-3">
&lt;h3 id="headline-126">
애플리케이션에서 데이터 동기화
&lt;/h3>
&lt;div id="outline-text-headline-126" class="outline-text-3">
&lt;p>
덴마크 시민 의료 기록 통합 뷰를 저장하는 프로젝트의 예에서 데이터베이스 이관 경험을 보자.&lt;/p>
&lt;div id="outline-container-headline-127" class="outline-4">
&lt;h4 id="headline-127">
대량 데이터 동기화
&lt;/h4>
&lt;div id="outline-text-headline-127" class="outline-text-4">
&lt;p>
특정 기간의 스냅샵을 기준으로 대량 동기화한다. 변경사항을 반영하는 캡처 프로세스를 추가하고 데이터베이스를 동기화 시킨다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-128" class="outline-4">
&lt;h4 id="headline-128">
이전 스키마를 읽고 쓰기
&lt;/h4>
&lt;div id="outline-text-headline-128" class="outline-text-4">
&lt;p>
새 애플리케이션에서 두 데이터베이스를 동기화한다. 기존 스키마는 읽고 쓰기를 진행하며 새 데이터베이스에는 쓰기만 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-129" class="outline-4">
&lt;h4 id="headline-129">
새 스키마에서 읽고 쓰기
&lt;/h4>
&lt;div id="outline-text-headline-129" class="outline-text-4">
&lt;p>
기존 데이터베이스는 쓰기만 하고 새 시스템에서 읽기와 쓰기를 수행한다.&lt;/p>
&lt;p>
아직 기존 데이터베이스에도 데이터가 동기화되기 때문에 기존 모놀리스로 변경도 여전히 가능하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-130" class="outline-4">
&lt;h4 id="headline-130">
유용한 사례
&lt;/h4>
&lt;div id="outline-text-headline-130" class="outline-text-4">
&lt;p>
애플리케이션 코드를 분할하기 전에 스키마를 분할하려는 경우 매우 유용하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-131" class="outline-4">
&lt;h4 id="headline-131">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-131" class="outline-text-4">
&lt;p>
데이터를 동기화하는 과정이 복잡히지지만 모놀리스와 마이크로서비스 양쪽에서 데이터에 접근하는 경우 유용한 패턴이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-132" class="outline-3">
&lt;h3 id="headline-132">
예광탄 기록 패턴
&lt;/h3>
&lt;div id="outline-text-headline-132" class="outline-text-3">
&lt;p>
스키마 전체를 이관하거나 동기화하는 것 대신 두 종류 이상의 진실의 원천을 사용하는 것을 전체하고 필요한 데이터 집합을 새로운 진실의 원천으로 사용하는 패턴이다.&lt;/p>
&lt;div id="outline-container-headline-133" class="outline-4">
&lt;h4 id="headline-133">
데이터 동기화
&lt;/h4>
&lt;div id="outline-text-headline-133" class="outline-text-4">
&lt;p>
우선 한쪽으로만 쓰기가 일어나고 작성된 데이터는 다른 곳으로 동기화시키는 방법이 있다. 또는 양쪽에 모두 쓰기가 수행된다. 아니면 아무 쪽에나 쓰고 동기화 시키는 방법도 있다.&lt;/p>
&lt;p>
모든 경우에 지연이 발생하지만 일관성을 얻을 수 있다. 각자의 사정에 적당한지 파악해야 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-134" class="outline-4">
&lt;h4 id="headline-134">
스퀘어 주문 처리 사례
&lt;/h4>
&lt;div id="outline-text-headline-134" class="outline-text-4">
&lt;p>
새로운 서비스를 만들고 백그라운드 워커 프로세스도 데이터베이스에 직접 접근하는 대신 공개된 API 만 사용하도록 변경했다.&lt;/p>
&lt;p>
데이터 동기화는 각 서비스에서 필요한 데이터만 동기화하였고 지연이 존재한다고 가정하였다.&lt;/p>
&lt;p>
업스트림 컨슈머가 이벤트 기반의 시스템을 사용한다면 기존 시스템과 새로 만들어진 시스템에서 이벤트를 수신하여 각 데이터를 처리하고 동기화하는 과정을 추가할 수 있다. 이렇게 구성이 완료되면 컨슈머 서비스 마이그레이션은 상대적으로 수월하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-135" class="outline-4">
&lt;h4 id="headline-135">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-135" class="outline-text-4">
&lt;p>
동기화 구현은 대부분 마이그레이션에 필요한 작업이다. 이벤트 기반 시스템을 사용 중이거나 데이터 캡처 파이프라인이 있다면 좀 더 쉽게 구현 할 수 있다.&lt;/p>
&lt;p>
두 데이터베이스 시스템 간의 데이터 불일치가 어느 정도까지 허용되는지가 중요한 결정 사항이 될 것이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-136" class="outline-3">
&lt;h3 id="headline-136">
데이터베이스 분리
&lt;/h3>
&lt;div id="outline-text-headline-136" class="outline-text-3">
&lt;p>
우선 논리적 분리가 가능하다면 물리적 분리에 도전해야 한다. 잠재적 단일 장애 지점을 회피해야 한다. 물론 스케일 아웃의 이점도 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-137" class="outline-3">
&lt;h3 id="headline-137">
데이터베이스 먼저, 코드 먼저 분할할까?
&lt;/h3>
&lt;div id="outline-text-headline-137" class="outline-text-3">
&lt;div id="outline-container-headline-138" class="outline-4">
&lt;h4 id="headline-138">
데이터베이스 먼저 분할
&lt;/h4>
&lt;div id="outline-text-headline-138" class="outline-text-4">
&lt;p>
스키마를 먼저 분할하면 성능과 트랜잭션 무결성 문제를 일찍 발견하여 처리할 수 있다.&lt;/p>
&lt;p>
하지만 여전히 모놀리스 코드에 의존하므로 공유 데이터베이스로 인한 고충이 늘어난다.&lt;/p>
&lt;p>
ORM 도구를 사용하는 경우 단일 저장소 계층보다 경계 컨텍스트를 따라 저장소를 분해하는 방법이 추천된다.&lt;/p>
&lt;p>
코드가 여전히 모놀리스에 남아 있는 경우 이 분리된 데이터베이스를 유지하는 것은 큰 의미가 없다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-139" class="outline-4">
&lt;h4 id="headline-139">
코드 먼저 분할
&lt;/h4>
&lt;div id="outline-text-headline-139" class="outline-text-4">
&lt;p>
서비스를 먼저 분리하면 얻는 단기적인 개선이 있다. 이후 데이터베이스를 분리하는 방법이 많이 사용되고 있다.&lt;/p>
&lt;p>
서비스가 분리되면 서비스가 요구하는 데이터가 무엇인지 명확하게 알 수 있다. 이후 데이터베이스까지 분리해가는 역량이 필요하다.&lt;/p>
&lt;p>
코드를 분할하면서 데이터 접근 계층으로 모놀리스를 사용할 수 있다.&lt;/p>
&lt;p>
하지만 멀티 스키마를 대응하는 편이 좋다. FK 관련된 문제는 4장 후반부에 다시 논의한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-140" class="outline-4">
&lt;h4 id="headline-140">
함께 분할
&lt;/h4>
&lt;div id="outline-text-headline-140" class="outline-text-4">
&lt;p>
아무래도 큰 변화가 수반되기 때문에 스키마나 애플리케이션 먼저 분할하는 방식을 강력히 권장한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-141" class="outline-4">
&lt;h4 id="headline-141">
그러면 무엇을 먼저 분할하나?
&lt;/h4>
&lt;div id="outline-text-headline-141" class="outline-text-4">
&lt;p>
케바케. 성능이나 데이터 일관성에 영향이 우려되면 스키마를 먼저 분할. 그런 경우가 아니라면 코드를 분할하여 코드가 데이터 소유에 미치는 형향을 이해하는데 도움이 되는 방향으로 결정한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-142" class="outline-3">
&lt;h3 id="headline-142">
스키마 분리 사례
&lt;/h3>
&lt;div id="outline-text-headline-142" class="outline-text-3">
&lt;p>
저수준 데이터 분해 패턴을 살펴보자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-143" class="outline-3">
&lt;h3 id="headline-143">
테이블 분할
&lt;/h3>
&lt;div id="outline-text-headline-143" class="outline-text-3">
&lt;p>
경계 컨텍스트를 포함하는 하나의 테이블을 마이크로서비스의 소유권에 따라 분리하는 방법이다.&lt;/p>
&lt;p>
이 과정에 모놀리스의 여러 기능이 하나의 데이터에 수정을 가할 수 있다면 분리되는 마이크로서비스가 데이터를 소유하고 외부 기능에 대해 API를 제공하는 것이 좋다.&lt;/p>
&lt;div id="outline-container-headline-144" class="outline-4">
&lt;h4 id="headline-144">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-144" class="outline-text-4">
&lt;p>
경계 컨텍스트에 따라 테이블을 분할해야 한다. 소유권에 대한 문제도 함께 적용할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-145" class="outline-3">
&lt;h3 id="headline-145">
외래 키 관계를 코드로 이동
&lt;/h3>
&lt;div id="outline-text-headline-145" class="outline-text-3">
&lt;p>
외래 키를 사용해 데이터 정합성과 빠른 Join 속도를 도모할 수 있다. 새로운 마이크로서비스에서 이를 처리하려면 어떻게 대응해야 할까?&lt;/p>
&lt;div id="outline-container-headline-146" class="outline-4">
&lt;h4 id="headline-146">
조인 이동
&lt;/h4>
&lt;div id="outline-text-headline-146" class="outline-text-4">
&lt;p>
대기 시간이 걸리는 것을 감수하고 코드로 기능을 이동해야 한다. 캐싱을 적극적으로 사용할 수 있다면 그나마 좋은 해법이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-147" class="outline-4">
&lt;h4 id="headline-147">
데이터 일관성
&lt;/h4>
&lt;div id="outline-text-headline-147" class="outline-text-4">
&lt;p>
외래 키를 사용하는 이유 중 하나인 데이터 무결성을 위해 데이터를 삭제하기 전 반드시 확인 과정을 거쳐야 한다.&lt;/p>
&lt;p>
그리고 삭제가 정말 필요한지 확인하여 삭제 대신 레코드의 상태를 변경하는 것도 가능한 옵션이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-148" class="outline-4">
&lt;h4 id="headline-148">
적용 대상
&lt;/h4>
&lt;div id="outline-text-headline-148" class="outline-text-4">
&lt;p>
외래 키 관계 해결에서 중요한 것은 하나로 만들고 싶은 두 가지를 나누지 말아야 한다는 것이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-149" class="outline-4">
&lt;h4 id="headline-149">
공유되는 정적 데이터
&lt;/h4>
&lt;div id="outline-text-headline-149" class="outline-text-4">
&lt;p>
정적으로 참조되는 데이터는 그냥 공유하는 것도 좋다. 각 마이크로서비스가 하나의 참조 데이터 스키마를 공유하는 것이다.&lt;/p>
&lt;p>
그렇지 않다면 마이크로서비스마다 중복하여 참조되는 데이터를 관리할 수도 있다. 물론 코드로 정적 데이터를 관리하는 기법도 있다. 적어도 빌드 시점에 최신화 하는 과정이 필요할 것이다.&lt;/p>
&lt;p>
또 다른 방법으로 정적 데이터를 제공하는 데이터 서비스를 구성한다. Spring Cloud Config 서버가 그런 역할을 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-150" class="outline-3">
&lt;h3 id="headline-150">
트랜잭션
&lt;/h3>
&lt;div id="outline-text-headline-150" class="outline-text-3">
&lt;p>
마지막 난제이다.&lt;/p>
&lt;div id="outline-container-headline-151" class="outline-4">
&lt;h4 id="headline-151">
ACID 트랜잭션
&lt;/h4>
&lt;div id="outline-text-headline-151" class="outline-text-4">
&lt;p>
대부분의 트랜잭션 문제는 여기에 있다. 다행히 모든 데이터베이스가 ACID를 만족하는 것이 아니라는 점을 활용하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-152" class="outline-4">
&lt;h4 id="headline-152">
원자성이 부족한 상황
&lt;/h4>
&lt;div id="outline-text-headline-152" class="outline-text-4">
&lt;p>
트랜잭션 경계로 분리된 마이크로서비스는 원자성이 떨어진다. 지금 단계에서는 어쩔 수 없다.&lt;/p>
&lt;p>
이중 커밋을 살펴보자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-153" class="outline-4">
&lt;h4 id="headline-153">
2단계 커밋
&lt;/h4>
&lt;div id="outline-text-headline-153" class="outline-text-4">
&lt;p>
각 커밋은 투표와 커밋 단계로 구분하여 동작하도록 개선한다. 로컬 Lock 이 필요하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-154" class="outline-4">
&lt;h4 id="headline-154">
분산 트랜잭션까지 가지 말자
&lt;/h4>
&lt;div id="outline-text-headline-154" class="outline-text-4">
&lt;p>
그냥 데이터베이스를 분리하지 않는 방법도 있다.&lt;/p>
&lt;p>
아니면 Saga 패턴을 알아보자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-155" class="outline-3">
&lt;h3 id="headline-155">
사가 패턴
&lt;/h3>
&lt;div id="outline-text-headline-155" class="outline-text-3">
&lt;p>
2단계 커밋과 달리 설계상 상태의 여러 변경 사항을 조정할 수 있지만 자원을 잠글 필요가 없는 알고리즘이다. 이렇게 하려면 비즈니스 프로세스가 명시적으로 모델링되어 있어야 한다.&lt;/p>
&lt;p>
Long Lived 트랜잭션에 대한 해결 방법으로 사가 패턴은 등장하였다.&lt;/p>
&lt;div id="outline-container-headline-156" class="outline-4">
&lt;h4 id="headline-156">
사가 실패 모드
&lt;/h4>
&lt;div id="outline-text-headline-156" class="outline-text-4">
&lt;p>
사가의 핵심은 역방향 복구와 정방향 복구에 있다.&lt;/p>
&lt;p>
주문에 대한 롤백은 보상 트랜잭션을 통해 이루어진다. 보상 트랜잭션은 데이터베이스 롤백과 동일하게 수행될 수 없다. 그래서 시맨틱 롤백이라고 하기도 한다.
예를 들면 주문이 완료되어 발송된 이메일을 취소할 수 없다. 대신 주문이 취소되었다는 이메일을 발송해야 하는 것이다.&lt;/p>
&lt;p>
트랜잭션 단계를 정렬하여 롤백이 수월하도록 개선하는 방법도 있다. 고객에게 포인트 제공을 주문이 완료된 시점이 아니라 상품을 포장하고 발송한 후에 이루어지게 하는 것이 좋은 예제이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-157" class="outline-4">
&lt;h4 id="headline-157">
사가 패턴 구현
&lt;/h4>
&lt;div id="outline-text-headline-157" class="outline-text-4">
&lt;p>
오케스트레이션 사가와 연출된 사가 패턴이 있다.&lt;/p>
&lt;p>
오케스트레이션 사가는 중앙에 관리자가 있다. 오케스트레이터이다. 각 트랜젝션에 대해 조정하며 협업 서비스와 동기화된다. 도메인 결합도가 생길 수밖에 없다.&lt;/p>
&lt;p>
대신 오케스트레이터의 역할을 간결하게 하고 각 서비스에서 오케스트레이션의 요구를 수용하도록 개발하는 방법이 좋다.&lt;/p>
&lt;p>
이에 반해 연출된 사가 패턴은 비-선점형 멀티 태스크와 유사하게 동작한다. 각 서비스가 상호 간 협업을 위해 이벤트를 발송하고 이벤트에 반응하도록 구성한다.&lt;/p>
&lt;p>
이 둘을 적절히 혼용해 사용할 수도 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-158" class="outline-4">
&lt;h4 id="headline-158">
사가와 분산 트랜잭션
&lt;/h4>
&lt;div id="outline-text-headline-158" class="outline-text-4">
&lt;p>
왠만하면 분산 트랜잭션은 피하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-159" class="outline-2">
&lt;h2 id="headline-159">
5장: 마이크로서비스 도입 과정에서 직면하는 문제와 해법
&lt;/h2>
&lt;div id="outline-text-headline-159" class="outline-text-2">
&lt;p>
마이크로서비스를 도입하면서 나오는 문제는 샘 뉴먼의 첫 책에 충분히 소개하고 있다. 이를 해결하기 위한 정보를 추가한다.&lt;/p>
&lt;div id="outline-container-headline-160" class="outline-3">
&lt;h3 id="headline-160">
서비스가 늘어날수록 고충도 커진다
&lt;/h3>
&lt;div id="outline-text-headline-160" class="outline-text-3">
&lt;p>
마이크로서비스 아키텍처에서 문제가 발생하는 시점은 복잡 다단하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-161" class="outline-3">
&lt;h3 id="headline-161">
규모에 맞는 소유권
&lt;/h3>
&lt;div id="outline-text-headline-161" class="outline-text-3">
&lt;p>
소쿠리 아키텍처가 되기 전에 코드 변경에 대한 소유권을 통제하는 시점이 필요하다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-162" class="outline-3">
&lt;h3 id="headline-162">
기존 호환을 깨뜨리자
&lt;/h3>
&lt;div id="outline-text-headline-162" class="outline-text-3">
&lt;p>
가능하면 그러지 말고 적어도 컨슈머에 마이그레이션 할 시간을 제공하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-163" class="outline-3">
&lt;h3 id="headline-163">
리포팅
&lt;/h3>
&lt;div id="outline-text-headline-163" class="outline-text-3">
&lt;p>
모놀리스 데이터베이스의 가장 큰 장점은 리포팅이 쉽다는 것이다.
별도의 리포팅 데이터베이스를 관리하고 운영하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-164" class="outline-3">
&lt;h3 id="headline-164">
모니터링과 트러블슈팅
&lt;/h3>
&lt;div id="outline-text-headline-164" class="outline-text-3">
&lt;p>
로그 집계 시스템이 필요하게 될 것이다. 가능하면 초기에 구성하자.&lt;/p>
&lt;p>
운영 환경에서 테스트하기 위해 가짜 클라이언트를 등록해 살펴보는 방법도 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-165" class="outline-3">
&lt;h3 id="headline-165">
로컬 개발 환경
&lt;/h3>
&lt;div id="outline-text-headline-165" class="outline-text-3">
&lt;p>
서비스를 몇 개 띄워야 하는가? 서비스를 Mock으로 대체하여 구성할 수도 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-166" class="outline-3">
&lt;h3 id="headline-166">
너무 많은 것들을 실행해야 한다
&lt;/h3>
&lt;div id="outline-text-headline-166" class="outline-text-3">
&lt;p>
높은 수준의 자동화 도구와 쿠버네티스 같은 마이크로서비스 관리 도구를 사용할 필요가 있다.
오픈쉬프트나 관리형 쿠버네티스를 사용하는 것도 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-167" class="outline-3">
&lt;h3 id="headline-167">
E2E 테스트
&lt;/h3>
&lt;div id="outline-text-headline-167" class="outline-text-3">
&lt;p>
자동화 테스트 범위를 제한하는 것도 좋다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-168" class="outline-3">
&lt;h3 id="headline-168">
전역 최적화 대 지역 최적화
&lt;/h3>
&lt;div id="outline-text-headline-168" class="outline-text-3">
&lt;p>
가역적 결정과 비가역적 결정을 고민하여 대응하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-169" class="outline-3">
&lt;h3 id="headline-169">
견고성과 회복탄력성
&lt;/h3>
&lt;div id="outline-text-headline-169" class="outline-text-3">
&lt;p>
실패하는 시나리오를 알고 있는 것이 중요하다. 서킷 브레이커 등으로 배압 문제를 해결하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-170" class="outline-3">
&lt;h3 id="headline-170">
외톨이 서비스
&lt;/h3>
&lt;div id="outline-text-headline-170" class="outline-text-3">
&lt;p>
아무도 모르게 돌아가는 서버가 있는데 이 서버가 뭔 일을 하는지 아무도 몰라 끄지 못하는 상황이다.&lt;/p>
&lt;p>
마이크로서비스가 오래되면 이런 일도 생긴다. 담당자는 퇴사한 지 오래고 코드도 없다.&lt;/p>
&lt;blockquote>
&lt;p>마이크로서비스는 모두를 위한 아키텍처는 아니다. 이 책을 통해 마이크로서비스가 자신에게 적합한지 제대로 감을 잡을 수 있길 바랄 뿐이다.&lt;/p>
&lt;/blockquote>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 7</title><link>https://faultnote.github.io/posts/typescript-50-lessons-7/</link><pubDate>Sat, 27 Aug 2022 22:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-7/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 43 Promise 와 가변variadic</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 43
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
Promise 와 가변variadic 튜플 타입
&lt;/pre>
&lt;p>새로운 기법을 활용해 callback 스타일의 코드를 promisify 하게 만들어 아래와 같은 동작을 기대하는 유틸리티 함수를 만들어보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">loadFile&lt;/span>(&lt;span style="color:#a6e22e">fileName&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">cb&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">result&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">loadFilePromise&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">promisify&lt;/span>(&lt;span style="color:#a6e22e">loadFile&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">loadFilePromise&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;./chapter7.md&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span>.&lt;span style="color:#a6e22e">toUpperCase&lt;/span>())&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>우리가 만들 함수는 여러 인자가 있지만 마지막 인자로 콜백 함수를 가지고 있어야 하고 promisified 된 함수를 반환한다. 함수 원형은 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">promisify&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FunctionWithCallback&lt;/span> &amp;gt;(&lt;span style="color:#a6e22e">fun&lt;/span>: &lt;span style="color:#66d9ef">Fun&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">PromisifiedFunction&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FunctionWithCallback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ((&lt;span style="color:#a6e22e">arg1&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">cb&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">result&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> ((&lt;span style="color:#a6e22e">arg1&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">arg2&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">cb&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">result&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> ((&lt;span style="color:#a6e22e">arg1&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">arg2&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">arg3&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">cb&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">result&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 Fun 을 extends 하여 사용하는 패턴에 익숙해져야 한다. 여기에 사용된 FunctionWithCallback 의 타입도 확인해보자. 콜백을 포함한 인자의 개수에 따라 union 연산을 하고 있다.
가변 튜플 타입을 사용하여 대응할 수 있다. 튜플은 다음과 같이 표현된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">PersonProps&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">number&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> [&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">PersonProps&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">37&lt;/span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 방식을 적용하면 함수 선언은 이렇게 표현할 수 있게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">msg&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(...&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">string&lt;/span>])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>가변 튜플 타입의 튜플은 가변이란 말처럼 아직 정의되지 않은 타입을 가지고 있다. 이런 특성을 활용하면 콜백 스타일의 함수 원형을 완벽하게 표현할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FunctionWithCallback&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> (...&lt;span style="color:#a6e22e">t&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [...&lt;span style="color:#a6e22e">T&lt;/span>, (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>`t` 는 튜플이고 그 안에 가변 인자로 T[] 와 마지막 콜백 함수를 가지고 있다. 이 콜백 함수도 가변 인자 타입이 선언된 와일드카드 함수 타입이다. 여기에서 명확히 `any` 를 사용하고 있다. 의도된 any 타입이다. 이 함수는 헬퍼 함수이기 때문에 any 선언이 괜찮다.
이제 Promise 를 반환하는 타입을 선언하면 가변 튜플 타입 선언과 함께 아래와 같이 정리할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">PromisifiedFunction&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">InferArguments&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">InferResults&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Promisify 를 위해 마지막 콜백 함수를 제외한 인자를 따로 할 필요가 있다. 콜백을 제외한 가변 인자 타입을 InferArguments&amp;lt;T&amp;gt; 로 선언하면 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">InferArguments&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> (...&lt;span style="color:#a6e22e">t&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [...&lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>, (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>반환 타입은 Promise 안에서 사용되는 콜백 함수이기 때문에 같은 방식으로 InferResults&amp;lt;T&amp;gt; 를 선언할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">InferResults&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> (...&lt;span style="color:#a6e22e">t&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [...&lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>, (&lt;span style="color:#a6e22e">res&lt;/span>: &lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>promisify 에 대한 실제 구현을 살펴 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">promisify&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>&lt;span style="color:#a6e22e">...args&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[])&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">any&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#a6e22e">f&lt;/span>: &lt;span style="color:#66d9ef">Fun&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">InferArguments&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span>&amp;gt;) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">InferResults&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Fun&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">InferArguments&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span>&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>((&lt;span style="color:#a6e22e">resolve&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>: &lt;span style="color:#66d9ef">InferResults&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span>&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resolve&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">args&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">callback&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">call&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>, ...&lt;span style="color:#a6e22e">args&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>콜백을 포함한 promisify 할 함수 f 를 인자로 promisify 함수를 호출하면 infer arguement 를 통해 args 를 인자로 삼고 infer result 를 반환하는 함수를 반환한다. promisify 된 함수는 콜백 함수 이전의 args 를 인자로 받고 Promise 로 감싸진 callback 을 기존 콜백 함수 대신 마지막 인자로 전달하여 resolve 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 44
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
JSONify 클래스 디자인
&lt;/pre>
&lt;p>infer 는 extends 와 함께 삼항 연산의 결과를 나중에 참조하기 위해 사용한다. T 는 일반 함수이고 함수의 반환 타입을 R 로 추론 가능하면 R 로 정의하고 그렇지 않으면 any 를 반환한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ReturnType&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>&lt;span style="color:#a6e22e">...args&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">)&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">any&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span> : &lt;span style="color:#66d9ef">any&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>T extends (…args: any) =&amp;gt; infer R ? R : any
JSON 은 parse, stringify 로 이루어진 함수가 없고, undefined 가 없는 자바스크립트 객체 표현이다.
타입스크립트를 만든 Anders Hejlsberg 의 쇼케이스로 사용된 JSON 타입 제너릭 코드로 Serializer 를 구현하고 있다.
JSONify 타입은 기본 타입과 중첩된 배열이나 객체도 대응한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Serializer&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">serialize&lt;/span>(&lt;span style="color:#a6e22e">inp&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">stringify&lt;/span>(&lt;span style="color:#a6e22e">inp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">deserialize&lt;/span>(&lt;span style="color:#a6e22e">inp&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">JSONified&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#a6e22e">inp&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이에 추가로 toJSON 함수 타입을 가지고 있는데 전달되는 객체가 toJSON 함수를 가지고 있는 경우 JSON.stringify 의 결과를 사용하도록 대응할 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Widget&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">toJSON&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Widget&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">date&lt;/span>: &lt;span style="color:#66d9ef">Date&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>JSONified 타입을 구성해 보자. toJSON 함수가 있는 경우를 구분하여 infer 를 통해 반환 타입을 구해 사용한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">JSONified&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">JSONifiedValue&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> { &lt;span style="color:#a6e22e">toJSON&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">():&lt;/span> &lt;span style="color:#a6e22e">infer&lt;/span> &lt;span style="color:#a6e22e">U&lt;/span> } &lt;span style="color:#960050;background-color:#1e0010">?&lt;/span> &lt;span style="color:#a6e22e">U&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이제 각 값에 대한 타입 정의를 하고 있는 JSONifiedValue 타입을 살펴 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">JSONifiedValue&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Function &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Array&amp;lt;&lt;span style="color:#f92672">infer&lt;/span> &lt;span style="color:#a6e22e">U&lt;/span>&amp;gt; &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">JSONifiedArray&lt;/span>&amp;lt;&lt;span style="color:#f92672">U&lt;/span>&amp;gt; &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">JSONifiedObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>원시 타입인 경우 해당 타입을 반환 한다. 함수인 경우 버린다. 배열 인 경우 배열 안에 있는 타입을 참조하는 JSONifiedArray 타입을 반환한다. 객체인 경우는 JSONifiedObject 타입을 반환한다. 객체 타입인 재귀 타입이 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">JSONifiedObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {[&lt;span style="color:#a6e22e">P&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">JSONified&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt;}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>배열 타입인 경우, 배열의 요소가 undefined 값이 있는 경우 null 타입을 반환하도록 한다. 배열의 요소로 객체가 있을 수 있으니 여기에도 재귀 구문이 추가된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UndefinedAsNull&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">JSONifiedArray&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> Array&amp;lt;&lt;span style="color:#f92672">UndefinedAsNull&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">JSONified&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Serializer 클래스에 대한 타입 제약이 완성되었다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SomeItem&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">text&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>; &lt;span style="color:#a6e22e">count&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>; &lt;span style="color:#a6e22e">choice&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;yes&amp;#34;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#34;no&amp;#34;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">func&lt;/span>&lt;span style="color:#f92672">:&lt;/span> () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nested&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">isSaved&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>; &lt;span style="color:#a6e22e">data&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">undefined&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>]; &lt;span style="color:#a6e22e">what&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#66d9ef">undefined&lt;/span>, &lt;span style="color:#66d9ef">undefined&lt;/span>] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">widget&lt;/span>: &lt;span style="color:#66d9ef">Widget&lt;/span>; &lt;span style="color:#a6e22e">children?&lt;/span>: &lt;span style="color:#66d9ef">SomeItem&lt;/span>[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">serializer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Serializer&lt;/span>&amp;lt;&lt;span style="color:#f92672">SomeItem&lt;/span>&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">serializer&lt;/span>.&lt;span style="color:#a6e22e">serialize&lt;/span>(&lt;span style="color:#a6e22e">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">o&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">serializer&lt;/span>.&lt;span style="color:#a6e22e">deserialize&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 45
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
복합 서비스 정의 타입 패턴
&lt;/pre>
&lt;p>앤더스 헤일스버그의 다른 예제로 동적 타입 정의에 대한 내용을 살펴 보자. 아래와 같이 사용되는 객체가 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">serviceDefinition&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">open&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">filename&lt;/span>: &lt;span style="color:#66d9ef">String&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">insert&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">pos&lt;/span>: &lt;span style="color:#66d9ef">Number&lt;/span>, &lt;span style="color:#a6e22e">text&lt;/span>: &lt;span style="color:#66d9ef">String&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">pos&lt;/span>: &lt;span style="color:#66d9ef">Number&lt;/span>, &lt;span style="color:#a6e22e">len&lt;/span>: &lt;span style="color:#66d9ef">Number&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 정의를 사용하는 createService 함수를 구현하기 위해 서비스를 정의한 내용과 이 요청을 처리하는 핸들러를 전달할 것이다.
반환되는 서비스는 open, insert 등 정의된 스펙에 따라 사용할 수 있다. createService 함수 원형을 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createService&lt;/span>&amp;lt;&lt;span style="color:#f92672">S&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">ServiceDefinition&lt;/span>&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">serviceDefinition&lt;/span>: &lt;span style="color:#66d9ef">S&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">handler&lt;/span>: &lt;span style="color:#66d9ef">RequestHandler&lt;/span>&amp;lt;&lt;span style="color:#f92672">S&lt;/span>&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">ServiceObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">S&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>서비스 정의 타입은 간단히 아래와 같이 정의할 수 있다. 문자열을 키로 사용하는 객체 타입을 구성하고 키가 정의되는 과정에 타입이 narrow 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ServiceDefinition&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">x&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">MethodDefinition&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MethodDefinition&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">x&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">StringConstructor&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">NumberConstructor&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>핸들러 타입을 정의해 보자. request 를 받은 핸들러의 실행을 완료하고 boolean 을 반환한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RequestHandler&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">ServiceDefinition&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">req&lt;/span>: &lt;span style="color:#66d9ef">RequestObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>RequestObject 타입은 서비스 정의에 따른다. RequestObject 는 아래처럼 정의된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RequestObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">ServiceDefinition&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">P&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">message&lt;/span>: &lt;span style="color:#66d9ef">P&lt;/span>; &lt;span style="color:#a6e22e">payload&lt;/span>: &lt;span style="color:#66d9ef">RequestPayload&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt;; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}[&lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>];&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 정의된 request 객체는 다음과 같은 타입에 대한 상황을 만족한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">req&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;open&amp;#34;&lt;/span>; &lt;span style="color:#a6e22e">payload&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">filename&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>; } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> { &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;insert&amp;#34;&lt;/span>; &lt;span style="color:#a6e22e">payload&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">pos&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>; &lt;span style="color:#a6e22e">text&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>; } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> { &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;delete&amp;#34;&lt;/span>; &lt;span style="color:#a6e22e">payload&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">pos&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>; &lt;span style="color:#a6e22e">len&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>; } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> { &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;close&amp;#34;&lt;/span>; &lt;span style="color:#a6e22e">payload&lt;/span>: &lt;span style="color:#66d9ef">undefined&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>createService 함수가 반환하는 객체의 반환 타입도 정리해 보자. 문자열 키에 대한 ServiceMethod 제너릭 타입이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ServiceObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">ServiceDefinition&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">P&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">ServiceMethod&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>각 서비스 메소드는 페이로드를 받아 실행 결과를 반환한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ServiceMethod&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">MethodDefinition&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {} &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#f92672">?&lt;/span> () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">payload&lt;/span>: &lt;span style="color:#66d9ef">RequestPayload&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>페이로드는 RequestPayload 로 정의된 제너릭 타입이다. 서비스 정의에 사용된 자바스크립트 타입을 통해 생성자 타입을 구성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RequestPayload&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">MethodDefinition&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {} &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span> &lt;span style="color:#f92672">:&lt;/span> { [&lt;span style="color:#a6e22e">P&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">TypeFromConstructor&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TypeFromConstructor&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">StringConstructor&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">NumberConstructor&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>실제 서비스 생성 함수를 구현하면 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createService&lt;/span>&amp;lt;&lt;span style="color:#f92672">S&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">ServiceDefinition&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">serviceDefinitions&lt;/span>: &lt;span style="color:#66d9ef">S&lt;/span>, &lt;span style="color:#a6e22e">handler&lt;/span>: &lt;span style="color:#66d9ef">RequestHandler&lt;/span>&amp;lt;&lt;span style="color:#f92672">S&lt;/span>&amp;gt;,)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">ServiceObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">S&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">service&lt;/span>: &lt;span style="color:#66d9ef">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">string&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Function&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">serviceDefinitions&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">service&lt;/span>[&lt;span style="color:#a6e22e">name&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">payload&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">handler&lt;/span>({ &lt;span style="color:#a6e22e">message&lt;/span>: &lt;span style="color:#66d9ef">name&lt;/span>, &lt;span style="color:#a6e22e">payload&lt;/span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">service&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">ServiceObject&lt;/span>&amp;lt;&lt;span style="color:#f92672">S&lt;/span>&amp;gt;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">service&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">createService&lt;/span>(&lt;span style="color:#a6e22e">serviceDefinition&lt;/span>, &lt;span style="color:#a6e22e">req&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (&lt;span style="color:#a6e22e">req&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;open&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;insert&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something or reach never
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">service&lt;/span>.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">service&lt;/span>.&lt;span style="color:#a6e22e">open&lt;/span>({ &lt;span style="color:#a6e22e">filename&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;text.txt&amp;#39;&lt;/span> });&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 타입 정보를 추가하여 흔히 사용하는 서비스 정의 패턴의 타입 안정성을 확보할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 46
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
DOM JSX 타입 엔진 만들기 1
&lt;/pre>
&lt;p>JSX 는 템플릿 언어도 아니고 HTML 도 아니고 XML 도 아니다. JSX 의 실체는 함수 호출이다. `(element, properties, …children)` 로 보면 된다.&lt;/p>
&lt;div class="src src-xml">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;Button&lt;/span> &lt;span style="color:#a6e22e">onClick=&lt;/span>&lt;span style="color:#e6db74">{()&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> alert(&amp;#39;YES&amp;#39;)}&amp;gt;Click me&lt;span style="color:#f92672">&amp;lt;/Button&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위 구문은 사실 아래로 변환 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#a6e22e">Button&lt;/span>, { &lt;span style="color:#a6e22e">onClick&lt;/span>&lt;span style="color:#f92672">:&lt;/span> () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;YES&amp;#39;&lt;/span>) }, &lt;span style="color:#e6db74">&amp;#39;Click me&amp;#39;&lt;/span>);&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>태그 문법이라 중첩 사용이 가능하다. 이는 재귀로 표현할 수 있다.&lt;/p>
&lt;div class="src src-xml">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;Button&lt;/span> &lt;span style="color:#a6e22e">onClick=&lt;/span>&lt;span style="color:#e6db74">{()&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> alert(&amp;#39;YES&amp;#39;)}&amp;gt;&lt;span style="color:#f92672">&amp;lt;span&amp;gt;&lt;/span>Click me&lt;span style="color:#f92672">&amp;lt;/span&amp;gt;&amp;lt;/Button&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#a6e22e">Button&lt;/span>, { &lt;span style="color:#a6e22e">onClick&lt;/span>&lt;span style="color:#f92672">:&lt;/span> () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">alert&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;YES&amp;#39;&lt;/span>) }, &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;span&amp;#39;&lt;/span>, {}, &lt;span style="color:#e6db74">&amp;#39;Click me&amp;#39;&lt;/span>));&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>대문자로 시작되는 요소는 컴포넌트로, 소문자로 시작되는 항목은 문자열로 변환되고 있다.
타입스크립트를 사용해 JSX 컴파일러를 만들어보자. 함수 원형은 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">factory&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>, ...&lt;span style="color:#a6e22e">children&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>컴파일러 옵션을 추가한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;jsx&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;react&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;jsxFactory&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;DOMcreateElement&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;noImplicitAny&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>팩토리 함수의 스펙을 살펴보자. element 가 함수이면 함수형 컴포넌트로 사용하고 properties 와 children 을 인자로 호출하여 결과를 얻어 낸다. element 가 문자열이면 일반 노드로 사용한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMcreateElement&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>, ...&lt;span style="color:#a6e22e">children&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;function&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span>({ ...&lt;span style="color:#a6e22e">nonNull&lt;/span>(&lt;span style="color:#a6e22e">properties&lt;/span>, {}), &lt;span style="color:#a6e22e">children&lt;/span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">DOMparseNode&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>, &lt;span style="color:#a6e22e">children&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">nonNull&lt;/span>(&lt;span style="color:#a6e22e">val&lt;/span>, &lt;span style="color:#a6e22e">fallback&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Boolean(&lt;span style="color:#a6e22e">val&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> : &lt;span style="color:#66d9ef">fallback&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>일반 노드를 파싱하는 구문을 보자. children 을 처리하는 함수는 재귀 패턴을 사용하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMparseNode&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>, &lt;span style="color:#a6e22e">children&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">el&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Object.&lt;span style="color:#a6e22e">assign&lt;/span>(document.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>), &lt;span style="color:#a6e22e">properties&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">DOMparseChildren&lt;/span>(&lt;span style="color:#a6e22e">children&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#a6e22e">child&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> { &lt;span style="color:#a6e22e">el&lt;/span>.&lt;span style="color:#a6e22e">appendChild&lt;/span>(&lt;span style="color:#a6e22e">child&lt;/span>); });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">el&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMparseChildren&lt;/span>(&lt;span style="color:#a6e22e">children&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">children&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#a6e22e">child&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">child&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;string&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> document.&lt;span style="color:#a6e22e">createTextNode&lt;/span>(&lt;span style="color:#a6e22e">child&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">child&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>앞으로 이어서 사용할 JSX 템플릿은 아래와 같다.&lt;/p>
&lt;div class="src src-xml">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>const Button = ({ msg }: { msg: string }) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;button&lt;/span> &lt;span style="color:#a6e22e">onclick=&lt;/span>&lt;span style="color:#e6db74">{()&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> alert(msg)}&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;strong&amp;gt;&lt;/span>Click me&lt;span style="color:#f92672">&amp;lt;/strong&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/button&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>const el = (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;h1&lt;/span> &lt;span style="color:#a6e22e">className=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;what&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>Hello world&lt;span style="color:#f92672">&amp;lt;/h1&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;p&amp;gt;&lt;/span>...&lt;span style="color:#f92672">&amp;lt;/p&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;Button&lt;/span> &lt;span style="color:#a6e22e">msg=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Yay&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;Button&lt;/span> &lt;span style="color:#a6e22e">msg=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Nay&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/div&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>document.body.appendChild(el);&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 47
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
DOM JSX 엔진 만들기 2
&lt;/pre>
&lt;p>이제 타입 정보를 추가해보자. 이전의 nonNull 함수에 타입 정보를 추가하면 이렇게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">nonNull&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">K&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>, &lt;span style="color:#a6e22e">fallback&lt;/span>: &lt;span style="color:#66d9ef">K&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Boolean(&lt;span style="color:#a6e22e">val&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> : &lt;span style="color:#66d9ef">fallback&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>다음으로 DOMParseChildren 함수를 위해 타입을 추가하자. HTMLElement 는 가장 기본 클래스이다. 이 경우 string 과 Text 타입을 추가로 받을 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">PossibleElements&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Text&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMparseChildren&lt;/span>(&lt;span style="color:#a6e22e">children&lt;/span>: &lt;span style="color:#66d9ef">PossibleElements&lt;/span>[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Fun&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>함수 타입 원형을 위해 Fun 타입도 정의해 두었다. HTML 의 모든 엘리먼트에 대한 태그 맵이 있다. HTMLElementTagNameMap 인터페이스가 브라우저 안에 정의되어 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">AllElementsKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">HTMLElementTagNameMap&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CreatedElement&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">AllElementsKeys&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">HTMLElementTagNameMap&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span>] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>프로퍼티를 위한 타입 정의는 이렇게 가능하다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Props&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Fun&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Parameters&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Partial&lt;/span>&amp;lt;&lt;span style="color:#f92672">CreatedElement&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이제 DOMParseNode 함수 원형은 아래와 같이 구성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMparseNode&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">element&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>: &lt;span style="color:#66d9ef">Props&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;, &lt;span style="color:#a6e22e">children&lt;/span>: &lt;span style="color:#66d9ef">PossibleElements&lt;/span>[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>DOMCreateElement 함수 원형도 다음과 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMcreateElement&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">element&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>: &lt;span style="color:#66d9ef">Props&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;, ...&lt;span style="color:#a6e22e">children&lt;/span>: &lt;span style="color:#66d9ef">PossibleElements&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMcreateElement&lt;/span>&amp;lt;&lt;span style="color:#f92672">F&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">Fun&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">element&lt;/span>: &lt;span style="color:#66d9ef">F&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>: &lt;span style="color:#66d9ef">Props&lt;/span>&amp;lt;&lt;span style="color:#f92672">F&lt;/span>&amp;gt;, ...&lt;span style="color:#a6e22e">children&lt;/span>: &lt;span style="color:#66d9ef">PossibleElements&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">DOMcreateElement&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">properties&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, ...&lt;span style="color:#a6e22e">children&lt;/span>: &lt;span style="color:#66d9ef">PossibleElements&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 타입 정보가 제공되면 HTML 엘리먼트 코드 작업 때 자동 완성 등의 기능과 함께 타입 안전한 코드를 작성할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 48
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
객체 타입 확장하기 1
&lt;/pre>
&lt;p>타입스크립트의 컨트롤 플로우 분석은 타입 좁히기에 도움을 준다. 자주 사용되는 구문은 아래와 같을 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;string&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">toUpperCase&lt;/span>()) &lt;span style="color:#75715e">// We know msg is a string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">msg&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;number&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">msg&lt;/span>.&lt;span style="color:#a6e22e">toFixed&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>)) &lt;span style="color:#75715e">// I know msg is a number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>객체에 대해서는 조금 더 복잡하게 타입을 확인하게 되는데 타입스크립트는 타입을 좁히지 못하는 상황이 온다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;object&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;prop&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// It&amp;#39;s safe to access obj.prop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>.&lt;span style="color:#a6e22e">prop&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// But TS doesn&amp;#39;t know :-(
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;object&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>.&lt;span style="color:#a6e22e">hasOwnProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;prop&amp;#39;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// It&amp;#39;s safe to access obj.prop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>.&lt;span style="color:#a6e22e">prop&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// But TS doesn&amp;#39;t know :-(
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>hasOwnProperty 에 대해 타입 정보를 제공하여 이 문제를 해결해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">hasOwnProperty&lt;/span>&amp;lt;&lt;span style="color:#f92672">X&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> {}&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Y&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyKey&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">X&lt;/span>, &lt;span style="color:#a6e22e">prop&lt;/span>: &lt;span style="color:#66d9ef">Y&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">Y&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">unknown&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>.&lt;span style="color:#a6e22e">hasOwnProperty&lt;/span>(&lt;span style="color:#a6e22e">prop&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>X 는 객체에 대한 확장을 보장한다. 객체의 키로 위해 string, number, symbol 을 사용할 수 있는데 이를 위해 `PropertyKey` 타입이 제공된다.
obj: X 와 prop: Y 에 대한 타입을 확보하게 된다. 이 헬퍼 함수를 아래와 같이 사용하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// person is an object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// person = { } &amp;amp; Record&amp;lt;&amp;#39;name&amp;#39;, unknown&amp;gt; = { } &amp;amp; { name: &amp;#39;unknown&amp;#39;}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">person&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;object&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">hasOwnProperty&lt;/span>(&lt;span style="color:#a6e22e">person&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">person&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;string&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Yes! name now exists in person
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Do something with person.name, which is a string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>또 다른 흔한 예제를 보자. 자바스크립트에서 자주 볼 수 있는 코드이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span>: &lt;span style="color:#66d9ef">38&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Object.&lt;span style="color:#a6e22e">keys&lt;/span>(&lt;span style="color:#a6e22e">obj&lt;/span>).&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">obj&lt;/span>[&lt;span style="color:#a6e22e">key&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>타입스크립트는 key 에 대한 타입 정보를 얻을 수 없어 경고를 안내한다. Object.keys 는 여러 타입을 받을 수 있다. number 늘 받는 경우는 빈 배열을 반환한다. 문자열이나 배열을 담으면 숫자 인덱스를 가지는 배열을 반환한다. 객체를 전달 받는다면 이 객체에 사용된 키를 반환한다. 스펙을 알았으니 타입을 강제해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ReturnKeys&lt;/span>&amp;lt;&lt;span style="color:#f92672">O&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">O&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">?&lt;/span> [] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">O&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Array&amp;lt;&lt;span style="color:#f92672">any&lt;/span>&amp;gt; &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">O&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#f92672">?&lt;/span> Array&amp;lt;&lt;span style="color:#f92672">keyof&lt;/span> &lt;span style="color:#a6e22e">O&lt;/span>&amp;gt; &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Extending the interface
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ObjectConstructor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">keys&lt;/span>&amp;lt;&lt;span style="color:#f92672">O&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">O&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">ReturnKeys&lt;/span>&amp;lt;&lt;span style="color:#f92672">O&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>ReturnKey&amp;lt;T&amp;gt; 타입과 인터페이스 확장으로 Object.keys 메소드의 타입 제약을 강화할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 49
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
객체 타입 확장하기 2
&lt;/pre>
&lt;p>자바스크립트는 동적으로 객체를 생성할 수 있다. 특히 Object.defineProperty 를 통해 런타임에 확장이 가능하고 객체의 writable 속성을 조정하여 객체의 변경을 보호할 수 있다.
타입스크립트는 assets 키워드를 통해 타입 단정을 할 수 있다. 타입 단정을 통해 타입 좁히기 역할을 할 수 있다. 다음 예제를 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">assertIsNum&lt;/span>(&lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;number&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">AssertionError&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Not a number!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assertIsNum&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assertIsNum&lt;/span>(&lt;span style="color:#a6e22e">y&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>; &lt;span style="color:#75715e">// x, y 의 타입 정보가 없다.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>assetIsNum 함수에 타입 단정문을 추가해보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">assertIsNum&lt;/span>(&lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">asserts&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">y&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assertIsNum&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assertIsNum&lt;/span>(&lt;span style="color:#a6e22e">y&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>; &lt;span style="color:#75715e">// Now also TypeScript knows that both x and y are numbers
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 개념을 Object.defineProperty 에도 적용해 볼 수 있다. defineProperty 헬퍼 함수 원형은 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">defineProperty&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">object&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyKey&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">PDesc&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyDescriptor&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">Obj&lt;/span>, &lt;span style="color:#a6e22e">prop&lt;/span>: &lt;span style="color:#66d9ef">Key&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#66d9ef">PDesc&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object.&lt;span style="color:#a6e22e">defineProperty&lt;/span>(&lt;span style="color:#a6e22e">obj&lt;/span>, &lt;span style="color:#a6e22e">prop&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>PropertyKey 와 PropertyDescriptor 는 빌트인 타입이다. (obj, prop, val) 에 타입 단정을 추가해 보면 아래와 같은 모양이 될 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">defineProperty&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">object&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyKey&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">PDesc&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyDescriptor&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">Obj&lt;/span>, &lt;span style="color:#a6e22e">prop&lt;/span>: &lt;span style="color:#66d9ef">Key&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#66d9ef">PDesc&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">asserts&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">DefineProperty&lt;/span>&amp;lt;&lt;span style="color:#f92672">Key&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">PDesc&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object.&lt;span style="color:#a6e22e">defineProperty&lt;/span>(&lt;span style="color:#a6e22e">obj&lt;/span>, &lt;span style="color:#a6e22e">prop&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>DefineProperty 타입과 이 타입이 사용하는 InferValue 제너릭 타입은 아래와 같이 정의할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">DefineProperty&lt;/span>&amp;lt;&lt;span style="color:#f92672">Prop&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyKey&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyDescriptor&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">writable&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#66d9ef">set&lt;/span>(&lt;span style="color:#a6e22e">val&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">writable&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#66d9ef">get&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">writable&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Readonly&lt;/span>&amp;lt;&lt;span style="color:#f92672">InferValue&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Prop&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Desc&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">writable&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">InferValue&lt;/span>&amp;lt;&lt;span style="color:#f92672">Prop&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Desc&lt;/span>&amp;gt; &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Readonly&lt;/span>&amp;lt;&lt;span style="color:#f92672">InferValue&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Prop&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Desc&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">InferValue&lt;/span>&amp;lt;&lt;span style="color:#f92672">Prop&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">PropertyKey&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Desc&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#66d9ef">get&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">value&lt;/span>: &lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">Prop&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Desc&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#66d9ef">get&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">Prop&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span>;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 작업을 객체 생성자에 적용해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ObjectKeys&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#f92672">?&lt;/span> (&lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>)[] &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">?&lt;/span> [] &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Array&amp;lt;&lt;span style="color:#f92672">any&lt;/span>&amp;gt; &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">never&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ObjectConstructor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">keys&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">o&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">ObjectKeys&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Object.defineProperty 대신 defineProperty 를 사용해 객체를 확장해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">currentValue&lt;/span>: &lt;span style="color:#66d9ef">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">defineProperty&lt;/span>(&lt;span style="color:#a6e22e">storage&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;maxValue&amp;#39;&lt;/span>, { &lt;span style="color:#a6e22e">writable&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#a6e22e">value&lt;/span>: &lt;span style="color:#66d9ef">9001&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">maxValue&lt;/span> &lt;span style="color:#75715e">// it&amp;#39;s a number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">maxValue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#75715e">// Error! It&amp;#39;s read-only
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">storageName&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;My Storage&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">defineProperty&lt;/span>(&lt;span style="color:#a6e22e">storage&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">storageName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#75715e">// it&amp;#39;s a string!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// it&amp;#39;s not possible to assing a value and a getter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">defineProperty&lt;/span>(&lt;span style="color:#a6e22e">storage&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;broken&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">storageName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">value&lt;/span>: &lt;span style="color:#66d9ef">4000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">storage&lt;/span> &lt;span style="color:#75715e">// storage is never because we have a malicious property descriptor
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-9" class="outline-3">
&lt;h3 id="headline-9">
Lesson 50
&lt;/h3>
&lt;div id="outline-text-headline-9" class="outline-text-3">
&lt;pre class="example">
에필로그
&lt;/pre>
&lt;p>마지막 레슨.
타입스크립트 팀에서 제공하는 정보에 귀를 기울이기. 깃헙에서 볼 수 있다. 로드맵, 다음 버전의 기능들 등. TC39 소식도 보자.
타입스크립트 핸드북을 계속 보자. Deno 와 Pika CDN 의 정보도 주시하자.
타입스크립트 위클리는 필수.
필자의 블로그도 계속 볼 것: &lt;a href="https://fettblog.eu/">https://fettblog.eu/&lt;/a>&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 6</title><link>https://faultnote.github.io/posts/typescript-50-lessons-6/</link><pubDate>Sat, 13 Aug 2022 20:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-6/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 36 조건부 타입 4장에서 union 과 intersection</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 36
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
조건부 타입
&lt;/pre>
&lt;p>4장에서 union 과 intersection 을 통해 타입 공간을 확장하고 축소하는 방법과 임의의 데이터 구성에 대해 적당한 집합을 생성하는 법을 알아보았다. 5장에서는 generic 기법을 통해 타입을 공용화하고 데이터가 사용되는 시점에 함수와 클래스의 타입을 적용해 타입을 제약했다. 만약 타입이 애매하면 어떻게 할까? 제너릭하게 하나의 타입으로 묶지 못할 때는? 결과에 따라 타입을 선택해야 할 경우 등을 위해 조건부 타입이 필요하다.
if-else 를 사용하는 것과 같은 방식으로 타입에 조건을 사용하는 것이다. CD 나 LP 들을 파는 커머스 앱을 구성하면서 조건부 타입을 사용하는 방법을 알아보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">customerId&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">firstName&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lastName&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">productId&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">orderId&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">customer&lt;/span>: &lt;span style="color:#66d9ef">Customer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">products&lt;/span>: &lt;span style="color:#66d9ef">Product&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">date&lt;/span>: &lt;span style="color:#66d9ef">Date&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>전달되는 데이터에 따라 customer 인 경우 고객의 주문 목록을 제공하고, product 를 전달하는 경우 이 상품을 포함하는 주문서를 제공하고, orderId 를 전달하는 경우 해당 주문서를 제공하도록 fetchOrder 라는 함수를 구성해 보자.
함수 시그니처는 아래와 유사할 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>(&lt;span style="color:#a6e22e">customer&lt;/span>: &lt;span style="color:#66d9ef">Customer&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>(&lt;span style="color:#a6e22e">product&lt;/span>: &lt;span style="color:#66d9ef">Product&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>(&lt;span style="color:#a6e22e">orderId&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>(&lt;span style="color:#a6e22e">param&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Implementation to follow
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>하지만 아래처럼 구성한다 하더라도 번잡해 보인다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>(&lt;span style="color:#a6e22e">param&lt;/span>: &lt;span style="color:#66d9ef">Customer&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Implementation to follow
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>조건부 타입 선언은 아래와 같은 형식을 가진다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Conditional&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">U&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> : &lt;span style="color:#66d9ef">B&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이전에 배운 extends 를 사용한다. 조건부 타입 정의는 3항 연산자 사용과 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이제 함수 선언을 다시 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">Param&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">param&lt;/span>: &lt;span style="color:#66d9ef">Param&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Param&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Well, the implementation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>전달되는 타입에 대해 반환되는 타입도 강제된다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 37
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
함수 오버로딩과 조건부 타입을 결합하기
&lt;/pre>
&lt;p>조건부 타입은 옵셔널 인자에 대해도 동작한다. fetchOrder 를 비동기 함수로 변경하고 두 번째 인자에 콜백할 수 있는 옵셔널 함수를 추가해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Callback&lt;/span>&amp;lt;&lt;span style="color:#f92672">Res&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">result&lt;/span>: &lt;span style="color:#66d9ef">Res&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">param&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">param&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>: &lt;span style="color:#66d9ef">Callback&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">param&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>, &lt;span style="color:#a6e22e">callback?&lt;/span>: &lt;span style="color:#66d9ef">Callback&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;url&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">callback&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span>.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> { &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이제 저 복잡한 함수 선언을 정리해보자. 두 번째 인자가 선택적으로 제공되기 때문에 가변 인자를 사용할 수 있는 점을 활용해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">P&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(...&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">P&lt;/span>])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">P&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(...&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">P&lt;/span>, &lt;span style="color:#a6e22e">Callback&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>함수 인자의 타입을 정리해 보자. FetchParams 와 FetchCallback 을 FetchHead 로 묶어 본다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchCallback&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Callback&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">AsyncResult&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchHead&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Param&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">FetchHead&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Param&lt;/span>, &lt;span style="color:#a6e22e">FetchCallback&lt;/span>&amp;lt;&lt;span style="color:#f92672">Param&lt;/span>&amp;gt;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">FetchHead&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Param&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Param&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>정의된 타입을 활용하는 함수 선언은 이렇게 될 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParam&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">U&lt;/span>&amp;gt;(...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">U&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">AsyncResult&lt;/span>&amp;lt;&lt;span style="color:#f92672">U&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>함수 인자의 길이를 판단하여 조건부 타입으로 반환하는 연산을 통해 함수의 인자 타입과 반환 타입을 단순하게 정리하였다.
이 과정은 가독성과 정확성을 기준으로 적용을 고려하면 된다. 이해하기 위운 함수 오버로드 버전도 나쁘지 않음을 기억하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Version 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">Par&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">inp&lt;/span>: &lt;span style="color:#66d9ef">Par&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Par&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Version 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">Par&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">inp&lt;/span>: &lt;span style="color:#66d9ef">Par&lt;/span>, &lt;span style="color:#a6e22e">fun&lt;/span>: &lt;span style="color:#66d9ef">Callback&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Par&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// The implementation!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrder&lt;/span>&amp;lt;&lt;span style="color:#f92672">Par&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">inp&lt;/span>: &lt;span style="color:#66d9ef">Par&lt;/span>, &lt;span style="color:#a6e22e">fun?&lt;/span>: &lt;span style="color:#66d9ef">Callback&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Par&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Par&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Fetch the result
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`/backend?inp=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">JSON&lt;/span>.&lt;span style="color:#a6e22e">stringify&lt;/span>(&lt;span style="color:#a6e22e">inp&lt;/span>)&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>).&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">res&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If there’s a callback, call it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">fun&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">result&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fun&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Otherwise return the result promise
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 38
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
체크된 타입이 네이키드 타입의 매개변수인 조건 타입을 분배 조건 타입이라고 한다.
&lt;/pre>
&lt;p>지난 시간에 인자를 가지고 조건에 맞는 타입을 반환하는 함수처럼 동작하는 제너릭 타입을 살펴 보았다. 조건부 타입을 더 들여다보기 전에 이전 예제로 사용한 조건부 타입을 한 번 더 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Param&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Param&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Param&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>FetchReturn 타입에 Customer 를 적용해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByCustomer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Customer&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// transalated
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByCustomer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// finally
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByCustomer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>분산된 유니언 타입을 살펴 보자. 대부분의 경우 조건부 타입은 실행시기에 유니언 타입으로 배분된다. FetchReturn 은 Product 와 number 타입으로 생성된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Product&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>FetchReturn 은 배분되는 조건부 타입이다. 뭔 말이냐면, 이는 제네릭 유형 매개변수의 각 구성요소가 동일한 조건부 유형으로 인스턴스화됨을 의미한다. 간단히 말해서, Union 유형의 조건부 유형은 조건부 유형의 Union 타입과 같다. 코드를 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> (&lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> (&lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// transalated
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>타입스크립트의 조건부 타입의 동작이 분산을 통해 동작한다는 것을 아는 것은 매우 중요하다.&lt;/p>
&lt;ol>
&lt;li>각각의 입력되는 타입이 하나의 출력 타입이 되는 것을 추적할 수 있다.&lt;/li>
&lt;li>각각 다른 타입 입력은 다른 출력 타입을 가져야 한다.&lt;/li>
&lt;/ol>
&lt;p>다양한 조건이 있더라도 반환되는 타입은 중복되고 불가능한 조합은 제거된다. 아래 코드의 출력 타입은 같다는 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Product&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equal to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> (&lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> (&lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equal to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Removed redundancies
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>분산 조건부 타입의 중요한 전제 조건은 연산에 사용되는 제너릭 타입의 파라미터가 네이키드 타입이어야 한다는 것이다. 네이키드 타입은 타입 파라미터가 현재 존재하고 다른 구성의 일부분이 아닌 타입을 말한다. 배열, 튜플, 함수형, 비동기 타입 등의 제너릭 타입이 아닌 타입이다.
제너릭 타입의 파라미터가 네이키드 타입이 아닌 경우는 사이드 이펙트가 발생할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Param&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#a6e22e">Param&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span>] &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">Param&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Product&lt;/span>] &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>단일 타입이 연동될 때 조건부 타입은 예전처럼 동작할 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByCustomer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Customer&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// This condition is still true!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByCustomer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span>] &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Product&lt;/span>] &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equal to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByCustomer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>하지만 튜플 타입이 입력된다면 Customer 는 서브 타입으로 식별되고 분산되지 않게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByCustomerOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Customer&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span>] &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#75715e">// This is false!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Product&lt;/span>] &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#75715e">// This is obviously also false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> &lt;span style="color:#75715e">// So we resolve to this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equal to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchByProductOrId&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>[Customer | number] 는 [Customer] 의 수퍼 타입이기 때문에 [Customer] 를 확장하지 못한다.
위 FetchReturn 을 안전하고 정확하게 만들기 위해 숫자의 서브 타입을 확인하는 다른 조건을 추가할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Param&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchParams&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#a6e22e">Param&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Customer&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">Param&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#a6e22e">Product&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">Param&lt;/span>] &lt;span style="color:#66d9ef">extends&lt;/span> [&lt;span style="color:#66d9ef">number&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 하면 단일 유형으로 입력하는 경우까지 올바른 반환 타입을 얻을 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 39
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
Never 타입과 Extract
&lt;/pre>
&lt;p>조건부 타입의 분산 프로퍼티는 never 와 결합할 때 유용한 필터 역할을 한다. CD 와 LP 를 골라 파는 웹서비스를 구현하는 과정에 적용해 본다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Medium&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">id&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>; &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>; &lt;span style="color:#a6e22e">artist&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TrackInfo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">duration&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>; &lt;span style="color:#a6e22e">tracks&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span> }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>CD 와 LP 의 특성에 따라 Union 타입을 구성한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CD&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Medium&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">TrackInfo&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;cd&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">LP&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Medium&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sides&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">a&lt;/span>: &lt;span style="color:#66d9ef">TrackInfo&lt;/span>; &lt;span style="color:#a6e22e">b&lt;/span>: &lt;span style="color:#66d9ef">TrackInfo&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;lp&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>모든 미디어에 적용할 수 있는 타입과 미디어에 대한 유니언 키를 정의하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">AllMedia&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">CD&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">LP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MediaTypes&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">AllMedia&lt;/span>[&lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>미디어 종류와 나머지 정보를 전달하여 createMedium 함수를 만들자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createMedium&lt;/span>(&lt;span style="color:#a6e22e">kind&lt;/span>: &lt;span style="color:#66d9ef">MediaKinds&lt;/span>, &lt;span style="color:#a6e22e">info&lt;/span> )&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">AllMedia&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위와 같은 함수 원형을 구성할 수 있다. 여기에 제너릭을 추가해보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createMedium&lt;/span>&amp;lt;&lt;span style="color:#f92672">Kin&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">MediaKinds&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">kind&lt;/span>: &lt;span style="color:#66d9ef">Kin&lt;/span>, &lt;span style="color:#a6e22e">info&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">AllMedia&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이어서 AllMedia 의 타입을 좁혀 보자. Union 의 조건부 결과는 해당 조건의 합집합이다. 조건부 유형을 처리하는 과정에 CD 나 LP 가 아닌 경우 never 를 사용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectBranch&lt;/span>&amp;lt;&lt;span style="color:#f92672">Brnch&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Kin&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Brnch&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">kind&lt;/span>: &lt;span style="color:#66d9ef">Kin&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Brnch&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Brnch 값을 통해 CD, LP 타입을 구분할 수 있고 그 어떤 것도 아닌 것을 알아 판단할 수 있게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectCD&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">SelectBranch&lt;/span>&amp;lt;&lt;span style="color:#f92672">AllMedia&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">cd&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// This equals
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectCD&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">SelectBranch&lt;/span>&amp;lt;&lt;span style="color:#f92672">CD&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">LP&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">cd&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectCD&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">SelectBranch&lt;/span>&amp;lt;&lt;span style="color:#f92672">CD&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">cd&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&amp;gt; &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">SelectBranch&lt;/span>&amp;lt;&lt;span style="color:#f92672">LP&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">cd&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectCD&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">CD&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;cd&amp;#39;&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">CD&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> (&lt;span style="color:#a6e22e">LP&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;cd&amp;#39;&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">LP&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Evaluate!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectCD&lt;/span> &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// This is true! Awesome! Let’s return CD
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> (&lt;span style="color:#a6e22e">CD&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;cd&amp;#39;&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">CD&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// This is false. let’s return never
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> (&lt;span style="color:#a6e22e">LP&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> { &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;cd&amp;#39;&lt;/span> } &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">LP&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equal to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectCD&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">CD&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>결국 CD | never 의 유니언 타입을 얻게 되는데 결국 SelectCD 는 CD 를 얻게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createMedium&lt;/span>&amp;lt;&lt;span style="color:#f92672">Kin&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">MediaKinds&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">kind&lt;/span>: &lt;span style="color:#66d9ef">Kin&lt;/span>, &lt;span style="color:#a6e22e">info&lt;/span> )&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">SelectBranch&lt;/span>&amp;lt;&lt;span style="color:#f92672">AllMedia&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Kin&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>그래서 함수 원형은 위와 같이 작성할 수 있다. 타입 연산만으로 입력과 출력에 대해 튜링 컴플리트할 수 있게 된다.
이렇게 never 를 사용하는 유틸리티 함수 타입에 Extract 가 제공된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Extract&lt;/span>&amp;lt;&lt;span style="color:#f92672">A&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Extract 를 사용해 LP 타입을 구성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SelectLP&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Extract&lt;/span>&amp;lt;&lt;span style="color:#f92672">AllMedia&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> { &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">lp&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> }&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 40
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
합성 보조 타입
&lt;/pre>
&lt;p>이전에 CD 와 LP 타입을 정의하였으니 이것만으로 createMedium 의 info 인수 타입을 정의할 때 재사용하자.
우선 key 가 되는 식별자를 제거해 보자. 예를 들면, CD 인지 LP 인지 구별할 수 있으니 kind 나 자동 생성되는 id 는 필요없다.
이를 위해 Remove 합성 보조 타입을 살펴 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">CD&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equal to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;description&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;title&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;tracks&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;duration&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Now for the keys we actually want
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfoKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&amp;lt;&lt;span style="color:#f92672">CDKeys&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Removable&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equal to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfoKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;description&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;title&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;tracks&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;duration&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// A conditional of a union is a union of conditionals
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfoKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;description&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;title&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Remove&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;tracks&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;duration&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Remove 는 아래와 같이 정의된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Remove&lt;/span>&amp;lt;&lt;span style="color:#f92672">A&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>각 보조 타입을 대치해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfoKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#39;description&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;description&amp;#39;&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#39;title&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;title&amp;#39;&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#39;tracks&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;tracks&amp;#39;&lt;/span>) &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#e6db74">&amp;#39;duration&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;duration&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Evaluate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfoKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;description&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;title&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;tracks&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;duration&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Remove impossible types from the union
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfoKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;description&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;title&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;tracks&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;duration&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 Remove 타입은 Exclude 라는 내장 타입으로 선언되어 있다.
이제 key 를 제외한 info 타입을 정의할 수 있다. 이전에 사용한 Pick 합성 타입을 사용하면 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Pick&lt;/span>&amp;lt;&lt;span style="color:#f92672">CD&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Exclude&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">keyof&lt;/span> &lt;span style="color:#a6e22e">CD&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>좀 복잡하기 때문에 Omit 이라는 보조 타입을 제공한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">CDInfo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Omit&lt;/span>&amp;lt;&lt;span style="color:#f92672">CD&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이전에 정의해 둔 RemovableKeys 를 사용해 정리해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RemovableKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GetInfo&lt;/span>&amp;lt;&lt;span style="color:#f92672">Med&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Omit&lt;/span>&amp;lt;&lt;span style="color:#f92672">Med&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">RemovableKeys&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createMedium&lt;/span>&amp;lt;&lt;span style="color:#f92672">Kin&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">MediaKinds&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">kind&lt;/span>: &lt;span style="color:#66d9ef">Kin&lt;/span>, &lt;span style="color:#a6e22e">info&lt;/span>: &lt;span style="color:#66d9ef">GetInfo&lt;/span>&amp;lt;&lt;span style="color:#f92672">SelectedBranch&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">AllMedia&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Kin&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> )&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">SelectBranch&lt;/span>&amp;lt;&lt;span style="color:#f92672">AllMedia&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Kin&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>기본 타입의 모델 데이터를 잘 구성하고 제너릭과 분산 조건부 타입을 통해 그 안의 타입을 재활용하는 것이 타입스크립트를 잘 활용하는 것 같다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 41
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
함수 선언에서 파라미터 타입을 infer 하기
&lt;/pre>
&lt;p>타입 관리 드는 비용을 적게할수록 타입스크립트는 효율적으로 동작한다. 지금까지 데이터를 모델링하고 행동을 기술하는 작업 방식을 깨끗하게 유지시키지는 과정이었다. 다른 타입에서 동적으로 타입을 생성하고 운용하여 타입 관리에 많은 시간을 보내지 않은 것이다.
하지만 개발이 진행되는 과정에는 계속 변한다. 지금까지 실습해 온 이커머스의 어드민 서비스를 가정하고 레슨을 시작하자.
새 유저를 생성하는 코드이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createUser&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">role&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;admin&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;maintenace&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;shipping&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">isActive&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { &lt;span style="color:#a6e22e">userId&lt;/span>: &lt;span style="color:#66d9ef">userId&lt;/span>&lt;span style="color:#f92672">++&lt;/span>, &lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">role&lt;/span>, &lt;span style="color:#a6e22e">isActive&lt;/span>, &lt;span style="color:#a6e22e">createdAt&lt;/span>: &lt;span style="color:#66d9ef">new&lt;/span> Date() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>두 개의 속성은 자동 생성되고 나머지는 인수로 받는다. 타입을 적용해 좀 더 단단하게 만들 것이다.
역할은 admin, maintenance 와 shopoing 으로 나눈다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createUser&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">role&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;admin&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;maintenace&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;shipping&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">isActive&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>더 타입 안전한 환경으로 개선하자. 그 전에 생성되는 user 의 타입을 추론해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">createUser&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;shipping&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">user&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 User 타입을 추론할 수 있지만 비용도 높고 위험하다. 함수의 반환 값이 아니라 함수 선언에서 반환 타입을 추론할 수 있게 해보자.
우선 함수 인지 확인하고 createUser 의 함수 타입을 생성한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GetReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Fun&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Fun&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// get this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Fun&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GetReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">typeof&lt;/span> &lt;span style="color:#a6e22e">createUser&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이제 infer 키워드를 통해 extends 로 확장된 함수 타입에 대해 제너릭 타입을 구성할 수 있다. 함수의 반환 타입 any 를 제너릭하게 처리하게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GetReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">Fun&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Fun&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// get this
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GetReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">typeof&lt;/span> &lt;span style="color:#a6e22e">createUser&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이런 보조 타입은 데이터베이스에서 데이터를 저장하고 불러올 때나 스키마를 통해 새 객체를 만드는 일을 할 때 자주 필요하다. infer 키워드를 통해 타입 제약을 견고하게 할 수 있다.
promise 를 통해 조회되는 값에 대해 타입을 정의해 보면 이렇다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Unpack&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">infer&lt;/span> &lt;span style="color:#a6e22e">Res&lt;/span>&amp;gt; &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Res&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Unpack&lt;/span>&amp;lt;&lt;span style="color:#f92672">Promise&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">number&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#75715e">// A1 is number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A2&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Unpack&lt;/span>&amp;lt;&lt;span style="color:#f92672">number&lt;/span>&amp;gt; &lt;span style="color:#75715e">// A2 is never
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>배열을 풀어내는 타입이라면 이렇게 정의할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Flatten&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Array&amp;lt;&lt;span style="color:#f92672">infer&lt;/span> &lt;span style="color:#a6e22e">Vals&lt;/span>&amp;gt; &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Vals&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Flatten&lt;/span>&amp;lt;&lt;span style="color:#f92672">Customer&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt; &lt;span style="color:#75715e">// A1 is Customer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A2&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Flatten&lt;/span>&amp;lt;&lt;span style="color:#f92672">Customer&lt;/span>&amp;gt; &lt;span style="color:#75715e">// A2 is never
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이런 응용 방식을 통해 제공되는 함수 인수의 타입을 추론하는 Parameters 내장 보조 타입이 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Parameters&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> (...&lt;span style="color:#a6e22e">args&lt;/span>: &lt;span style="color:#66d9ef">infer&lt;/span> &lt;span style="color:#a6e22e">Param&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Param&lt;/span> : &lt;span style="color:#66d9ef">never&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Parameters&lt;/span>&amp;lt;&lt;span style="color:#f92672">typeof&lt;/span> &lt;span style="color:#a6e22e">createUser&lt;/span>&amp;gt; &lt;span style="color:#75715e">// A is [string, &amp;#34;admin&amp;#34; | &amp;#34;maintenace&amp;#34; | &amp;#34;shipping&amp;#34;, boolean]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 42
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
null 타입 다루기
&lt;/pre>
&lt;p>tsconfig 에서 strictNullChecks 을 활성화하여 undefined 와 null 을 고유한 타입 속성으로 처리하게 할 수 있다. 이는 nullish 한 경우를 강력하게 제약하여 타입 안전을 도모한다.
이전 학습에서 살펴 본 fetchOrderList 함수를 다시 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrderList&lt;/span>(&lt;span style="color:#a6e22e">input&lt;/span>: &lt;span style="color:#66d9ef">Customer&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Order&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Promise 는 그 정의에도 있지만 rejected 될 수 있다. 그리고 return any 라면 null 과 undefined 그리고 never 를 포함하고 있다. 실제 추론되는 함수 선언 타입은 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchOrderList&lt;/span>(&lt;span style="color:#a6e22e">input&lt;/span>: &lt;span style="color:#66d9ef">Customer&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Order&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">null&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이어 소개되는 NunNullable 타입을 위해 listOrder 함수 선언을 보자. fetchOrderList 의 반환 결과를 활용할 수 있도록 구성하면 이렇게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">listOrders&lt;/span>(&lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>만약 listOrder 안에서 null 처리가 되어 있다면 아래와 같이 선언하고 싶을 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">listOrders&lt;/span>(&lt;span style="color:#a6e22e">Order&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이를 위해 아래의 제너릭으로 확장한 함수 선언을 보자&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isAvailable&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">Obj&lt;/span> )&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">NonNullable&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>NonNullable 은 아래와 같이 구성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">NonNullable&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이를 활용해 isAvailable 함수를 구현해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isAvaialble&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">Obj&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">NonNullable&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">orders&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">fetchOrderList&lt;/span>(&lt;span style="color:#a6e22e">customer&lt;/span>) &lt;span style="color:#75715e">// orders is Order[] | null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isAvailable&lt;/span>(&lt;span style="color:#a6e22e">orders&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">listOrders&lt;/span>(&lt;span style="color:#a6e22e">orders&lt;/span>) &lt;span style="color:#75715e">//orders is Order[]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 점검은 런타임에서 일어나지 않고 타입스크립트의 컴파일 타임에 제약된다는 것이다. 데이터를 패치하여 주문 목록을 구하는 함수를 다시 설계 해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchDBKind&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;orders&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;products&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;customers&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FetchDBReturn&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;orders&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;products&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Products&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#e6db74">&amp;#39;customers&amp;#39;&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">Customers&lt;/span>[] &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">never&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">fetchFromDatabase&lt;/span>&amp;lt;&lt;span style="color:#f92672">Kin&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">FetchKind&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">kind&lt;/span>: &lt;span style="color:#66d9ef">Kin&lt;/span> )&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">FetchDbReturn&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Kin&lt;/span>&amp;gt;&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 타입을 활용하는 고차함수를 구성해 보자. 자바스크립트는 함수형 프로그래밍에도 잘 맞는다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">process&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">any&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#a6e22e">promise&lt;/span>: &lt;span style="color:#66d9ef">T&lt;/span>, &lt;span style="color:#a6e22e">cb&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">res&lt;/span>: &lt;span style="color:#66d9ef">Unpack&lt;/span>&amp;lt;&lt;span style="color:#f92672">NonNullable&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">promise&lt;/span>.&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">res&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isAvailable&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cb&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>데이터가 잘 fetch 된 경우에 listOrder 를 실행한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">process&lt;/span>(&lt;span style="color:#a6e22e">fetchFromDatabase&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;orders&amp;#39;&lt;/span>), &lt;span style="color:#a6e22e">listOrders&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>조건부 타입을 통해 복잡한 데이터 모델의 타입을 구성하고 제너릭하게 표현하고 보조 타입과 결합하여 안전한 자바스크립트 코딩을 하도록 강제한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 5</title><link>https://faultnote.github.io/posts/typescript-50-lessons-5/</link><pubDate>Sat, 23 Jul 2022 15:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-5/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 29 내가 원하는 게 뭔지 모르지만</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 29
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
내가 원하는 게 뭔지 모르지만 어떻게 얻을지 알고 있다.
&lt;/pre>
&lt;p>비디오 스트리밍 플랫폼 예제를 통해 제너릭 타입을 살펴보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">format360p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">format480p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">format720p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">format1080p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SubtitleURLs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">english&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">german&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">french&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>그리고 이를 사용하기 위한 함수들과 유틸리티를 준비한다. 추가로 자막에 대한 타입도 준비했다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isFormatVailable&lt;/span>(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">VideoFormatURLs&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isSubtitleAvailable&lt;/span>(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">SubtitleURLs&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">SubtitleURLs&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// generalized
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isAvailable&lt;/span>(&lt;span style="color:#a6e22e">obj&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>작성하고 보니 비디오 포맷에 대한 점검 함수와 자막에 대한 점검 함수가 같은 모양이다. 제너릭 타입이 필요하다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isAvailable&lt;/span>&amp;lt;&lt;span style="color:#f92672">Formats&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">Formats&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">symbol&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Formats&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이를 사용하는 과정은 `&amp;lt; &amp;gt;` 안에 명시적으로 타입을 추가하는 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isFormatAvailable&lt;/span>&amp;lt;&lt;span style="color:#f92672">VideoFormatURLs&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">videos&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>우리가 자주 사용하는 Promise 객체도 제너릭 타입을 사용한다.
제너릭 타입은 선언 시점이 아닌, 사용 시점에 타입이 추론된다. 이를 제너릭 인퍼런스라고 할 수 있다.
이를 위해 타입을 인수로 받아서 사용하는데 이를 제너릭 어노테이션이라고 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 30
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
제너릭 제약
&lt;/pre>
&lt;p>이전 예제는 그럴듯 하지만 전달되는 인자에 대한 타입 제약이 없다. 이는 제너릭 타입이 기본적으로 `any` 를 바탕으로 제공되기 때문이고 따라서 아래와 같은 코드에서도 정상으로 타입 체크가 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isAvailable&lt;/span>({ &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span>: &lt;span style="color:#66d9ef">38&lt;/span> }, &lt;span style="color:#a6e22e">key&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// key is now “name” | “age”
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isAvailable&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;A string&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;length&amp;#39;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Also strings have methods,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// like length, indexOf, ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isAvailable&lt;/span>(&lt;span style="color:#ae81ff">1337&lt;/span>, &lt;span style="color:#a6e22e">aKey&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Also numbers have methods
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// aKey is now everything number has to offer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>제너릭 어노테이션에 대한 경계를 추가해야 하는데 `extends` 키워드를 사용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isAvailable&lt;/span>&amp;lt;&lt;span style="color:#f92672">FormatList&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">object&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">obj&lt;/span>: &lt;span style="color:#66d9ef">FormatList&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">FormatList&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이제 적어도 FormatList 는 object 타입으로 제약된다.
비디오를 로딩하는 함수를 하나 만들면 이전에 작성한 제너릭 타입을 사용하는 코드와 유사하게 작성될 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">loadFile&lt;/span>&amp;lt;&lt;span style="color:#f92672">Formats&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">object&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">fileFormats&lt;/span>: &lt;span style="color:#66d9ef">Formats&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// You know
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>비디오 파일을 로드하기 위한 주요 타입은 URL 이고 이 정보를 동적으로 만들어내는 인덱스 타입을 사용해 제너릭 어노테이션을 확장할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">URLList&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { [&lt;span style="color:#a6e22e">k&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">loadFile&lt;/span>&amp;lt;&lt;span style="color:#f92672">Formats&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">URLList&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">fileFormats&lt;/span>: &lt;span style="color:#66d9ef">Formats&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// The real work ahead
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 31
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
키 활용하기
&lt;/pre>
&lt;p>문자열을 키로 사용하는 경우 오탈자나 정의되지 않은 키를 사용해 발생하는 런타임 에러를 막아보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">loadVideoFormat&lt;/span>(&lt;span style="color:#a6e22e">fileFormats&lt;/span>: &lt;span style="color:#66d9ef">VideoFormatURLs&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// You know
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>`keyof` 를 통해 &amp;#39;format&amp;#39; 의 타입을 제약하는 방법이 있다. 아래는 제너릭 타입과 타입 제약을 적용한 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">URLObject&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { [&lt;span style="color:#a6e22e">k&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">loadFile&lt;/span>&amp;lt;&lt;span style="color:#f92672">Formats&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">URLObject&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">fileFormats&lt;/span>: &lt;span style="color:#66d9ef">Formats&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Formats&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// The real work ahead
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">loadFile&lt;/span>(&lt;span style="color:#a6e22e">video&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;format1080p&amp;#39;&lt;/span>) &lt;span style="color:#75715e">// ok
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">loadFile&lt;/span>(&lt;span style="color:#a6e22e">video&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;format4k&amp;#39;&lt;/span>) &lt;span style="color:#75715e">// &amp;#39;format4k&amp;#39; is not available
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>제너릭 어노테이션은 하나 이상 작성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">loadFile&lt;/span>&amp;lt;&lt;span style="color:#f92672">Formats&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">URLObject&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">keyof&lt;/span> &lt;span style="color:#a6e22e">Formats&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">fileFormats&lt;/span>: &lt;span style="color:#66d9ef">Formats&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">Key&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#a6e22e">fileFormats&lt;/span>[&lt;span style="color:#a6e22e">format&lt;/span>].&lt;span style="color:#a6e22e">href&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { &lt;span style="color:#a6e22e">format&lt;/span>, &lt;span style="color:#a6e22e">loaded&lt;/span>: &lt;span style="color:#66d9ef">data.response&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Promise 타입에 대한 부분도 제너릭으로 표현할 수 있다. loadFile 의 실제 구현에 await 가 필요하다면 이 함수의 반환 타입을 `Promise&amp;lt;{ format: keyof Formats, loaded: boolean }&amp;gt;` 처럼 작성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">URLObject&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { [&lt;span style="color:#a6e22e">k&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Loaded&lt;/span>&amp;lt;&lt;span style="color:#f92672">Key&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">Key&lt;/span>, &lt;span style="color:#a6e22e">loaded&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">loadFile&lt;/span>&amp;lt;&lt;span style="color:#f92672">Formats&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">URLObject&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">keyof&lt;/span> &lt;span style="color:#a6e22e">Formats&lt;/span>&amp;gt;(&lt;span style="color:#a6e22e">fileFormats&lt;/span>: &lt;span style="color:#66d9ef">Formats&lt;/span>, &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">Key&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Loaded&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">Key&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#a6e22e">fileFormats&lt;/span>[&lt;span style="color:#a6e22e">format&lt;/span>].&lt;span style="color:#a6e22e">href&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { &lt;span style="color:#a6e22e">format&lt;/span>, &lt;span style="color:#a6e22e">loaded&lt;/span>: &lt;span style="color:#66d9ef">data.response&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 32
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
제너릭 맵 타입
&lt;/pre>
&lt;p>타입스크립트는 기본 타입을 확장해 사용할 수 있는 헬퍼 타입(유틸리티 타입)을 제공한다. 제너릭 맵 타입을 알아보기 위해 Record 와 Pick 을 살펴 본다.
Pick 은 첫 번째 인자의 타입에서 두 번째 인자를 선택한 타입을 만든다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HD&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Pick&lt;/span>&amp;lt;&lt;span style="color:#f92672">VideoFormatURLs&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">format1080p&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&lt;span style="color:#a6e22e">format720p&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Record 는 키와 타입으로 이루어진 맵이다. Record 는 쉽게 동적으로 object 타입에 대한 타입을 만들어 낸다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">URLObject&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">string&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">URL&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>맵 타입과 인덱스 타입을 활용하면 복잡한 타입을 단순하게 풀어낼 수 있다. 이어지는 예제를 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equivalent to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format360p&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format480p&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format1080p&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { [&lt;span style="color:#a6e22e">P&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">P&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equivalent to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">format360p&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format360p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">format480p&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format480p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">format720p&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">format1080p&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format1080p&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { [&lt;span style="color:#a6e22e">P&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">P&lt;/span> }[&lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equivalent to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format360p&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format480p&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format1080p&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { [&lt;span style="color:#a6e22e">P&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">P&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt; }[&lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equivalent to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;format360p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">URL&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;format480p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">URL&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">URL&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;format1080p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">URL&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Equivalent to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">format360p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span> } &lt;span style="color:#f92672">|&lt;/span> { &lt;span style="color:#a6e22e">format480p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span> } &lt;span style="color:#f92672">|&lt;/span> { &lt;span style="color:#a6e22e">format720p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span> } &lt;span style="color:#f92672">|&lt;/span> { &lt;span style="color:#a6e22e">format1080p&lt;/span>: &lt;span style="color:#66d9ef">URL&lt;/span> }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>마지막으로 잘 인덱스와 맵으로 정의된 제너릭 타입을 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> { [&lt;span style="color:#a6e22e">Prop&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">Prop&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">P&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt; }[&lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">AvailableFormats&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Split&lt;/span>&amp;lt;&lt;span style="color:#f92672">VideoFormatURLs&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 33
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
맵 타입 모디파이어
&lt;/pre>
&lt;p>타입스크립트는 Pick 처럼 맵 타입을 수정해 사용할 수 있는 수정자를 제공한다.
이전 예제에서 사용할 사용자 속성을 아래 코드처럼 정의해 볼 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UserPreferences&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">format&lt;/span>: &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">VideoFormatURLs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">subtitles&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">active&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">language&lt;/span>: &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">SubtitleURLs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">theme&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;dark&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;light&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>새로 추가된 UserPreferences 을 사용하는 코드에서 기본 세팅과 사용자 정의 세팅을 제공해야 한다면 사용자 세팅을 override 해야 한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">combinePreferences&lt;/span>(&lt;span style="color:#a6e22e">defaultPerf&lt;/span>: &lt;span style="color:#66d9ef">UserPreferences&lt;/span>, &lt;span style="color:#a6e22e">userPerf&lt;/span>: &lt;span style="color:#66d9ef">unknown&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { ...&lt;span style="color:#a6e22e">defaultPerf&lt;/span>, ...&lt;span style="color:#a6e22e">userPerf&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>처음 정의한 UserPreferences 타입을 수정하지 않고 옵셔널 하게 정의할 수 있는 Optional&amp;lt;T&amp;gt; 수정자를 만들어 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Optional&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>]&lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>[&lt;span style="color:#a6e22e">Key&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">combinePreferences&lt;/span>(&lt;span style="color:#a6e22e">defaultPerf&lt;/span>: &lt;span style="color:#66d9ef">UserPreferences&lt;/span>, &lt;span style="color:#a6e22e">userPerf&lt;/span>: &lt;span style="color:#66d9ef">Optional&lt;/span>&amp;lt;&lt;span style="color:#f92672">UserPreferences&lt;/span>&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { ...&lt;span style="color:#a6e22e">defaultPerf&lt;/span>, ...&lt;span style="color:#a6e22e">userPerf&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 기능을 위한 Partial&amp;lt;T&amp;gt; 수정자가 내장되어 있다. 상반된 목적의 Required&amp;lt;T&amp;gt; 수정자도 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Required&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>]&lt;span style="color:#f92672">-?:&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>[&lt;span style="color:#a6e22e">Key&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>읽기 전용으로 변경하는 Readonly&amp;lt;T&amp;gt; 수정자는 아래 코드처럼 구현된다. 타입스크립트는 컴파일 타임에 이를 검사하기 때문에 런타임에 변경되는 것을 막기 위해서는 Object.freeze 를 사용해야 한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Const&lt;/span>&amp;lt;&lt;span style="color:#f92672">Obj&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">readonly&lt;/span> [&lt;span style="color:#a6e22e">Key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Obj&lt;/span>[&lt;span style="color:#a6e22e">Key&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>추가로 Readonly 나 Partial 수정자는 첫 단계의 프로퍼티에 대해 동작하는 것을 기억해야 한다. deep 하게 제약을 추가하기 위해 DeepReadyonly 같은게 필요할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">DeepReadonly&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">readonly&lt;/span> [&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">DeepReadonly&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">DeepPartial&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>]&lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#a6e22e">DeepPartial&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[&lt;/span>&lt;span style="color:#a6e22e">key&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">]&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 34
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
고정 타입을 제너릭 타입으로 확장하기
&lt;/pre>
&lt;p>이전에 combinePreferences 함수의 반환 타입을 만들어가며 제너릭을 확장하고 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">combinePreferences&lt;/span>(&lt;span style="color:#a6e22e">defaultUserPref&lt;/span>, { &lt;span style="color:#a6e22e">format&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">theme&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;dark&amp;#39;&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">userSettings&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">format&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">theme&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;dark&amp;#39;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">combinePreferences&lt;/span>(&lt;span style="color:#a6e22e">defaultUserPref&lt;/span>, &lt;span style="color:#a6e22e">userSettings&lt;/span>) &lt;span style="color:#75715e">// type errors
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 리터럴을 사용할 때랑 참조를 전달할 때 동작이 다르다. userSettings 가 만들어지는 시점을 보면 타입스크립트는 이 타입 UserPreferences 타입인지 확인하기 어렵다. format 이나 theme 가 변경 가능하기 때문에 가능하면 더 넓은 범위의 타입을 추론한다. `as const` 타입을 제약해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">userSettings&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">format&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">theme&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;dark&amp;#39;&lt;/span> } &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이제 Partial&amp;lt;UserPreferences&amp;gt; 타입을 만족한다. 다른 방법으로 userSettings 를 생성할 때 타입을 정의하여 타입 체크를 만족시킬 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">userSettings&lt;/span>: &lt;span style="color:#66d9ef">Partial&lt;/span>&amp;lt;&lt;span style="color:#f92672">UserPreferences&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">format&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;format720p&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">theme&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;dark&amp;#39;&lt;/span> }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>모디파이어를 사용한 타입이라도 제너릭 기준에서 보면 고정 타입이다. 예제 함수의 매개변수 타입을 제너릭으로 개선해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">combinePreferences&lt;/span>&amp;lt;&lt;span style="color:#f92672">UserSettings&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">Partial&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">UserPreferences&lt;/span>&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">defaultPref&lt;/span>: &lt;span style="color:#66d9ef">UserPreferences&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userPref&lt;/span>: &lt;span style="color:#66d9ef">UserSettings&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>물론 defaultPerf 의 UserPreferences 도 제너릭하게 변경할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 35
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
제너릭 타입의 기본 타입을 정의하기
&lt;/pre>
&lt;p>협업 상황에서 주의할 것은 사이드 이펙트를 유발하는 undefined, null 데이터들이다. Nullable 한 타입을 하나 가정하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Nullable&lt;/span>&amp;lt;&lt;span style="color:#f92672">T&lt;/span>&amp;gt; &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>HTML 을 처리하기 위한 HTMLElement 타입의 Container 클래스를 만들 때에도 제너릭을 활용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Container&lt;/span>&amp;lt;&lt;span style="color:#f92672">CustomElement&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span>: &lt;span style="color:#66d9ef">Nullable&lt;/span>&amp;lt;&lt;span style="color:#f92672">CustomElement&lt;/span>&amp;gt;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span>(&lt;span style="color:#a6e22e">value&lt;/span>: &lt;span style="color:#66d9ef">Nullable&lt;/span>&amp;lt;&lt;span style="color:#f92672">CustomElement&lt;/span>&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#a6e22e">element&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span> &lt;span style="color:#a6e22e">element&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Nullable&lt;/span>&amp;lt;&lt;span style="color:#f92672">CustomElement&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#a6e22e">element&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">container&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Container&lt;/span>(&lt;span style="color:#a6e22e">userPrefs&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위 코드처럼 container 에 제너릭 타입 어노테이션을 작성하지 않고 생성할 때에도 VideoElement 를 위한 기본 타입을 가지도록 정의하기 위해 제너릭은 기본 값을 가질 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Container&lt;/span>&amp;lt;&lt;span style="color:#f92672">CustomElement&lt;/span> &lt;span style="color:#a6e22e">extends&lt;/span> &lt;span style="color:#a6e22e">HTMLElement &lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">HTMLVideoElement&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>기본 타입이 정의된다면 조금 더 편리하게 코드를 작성할 수 있다.&lt;/p>
&lt;p>
제너릭스의 개념은 1970년대 Ada 프로그래밍 언어에서 처음 소개되었다. 타입스크립트의 제너릭 문법은 C++ 의 템플릿에서 물려 받았다. 그래서 기본 타입을 표기할 때 `T` 를 사용한다. 이어지는 타입으로 U,V,W 을 사용하고 프로퍼티로 P, 키로 K 등을 쓴다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 4</title><link>https://faultnote.github.io/posts/typescript-50-lessons-4/</link><pubDate>Sat, 11 Jun 2022 18:00:00 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-4/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 22 데이터 모델링 레슨 22 는 4장</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 22
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
데이터 모델링
&lt;/pre>
&lt;p>레슨 22 는 4장의 시작인데 4장은 타입스크립트를 지탱하고 있는 집합 이론에 대해 소개한다. 특히 유니언 타입과 인터섹션 타입에 대한 논의를 하고 있다.&lt;/p>
&lt;p>
데이터 모델링 예제로 테크 컨퍼런스, 밋업, 웨비나를 들어 소개하고 있다.&lt;/p>
&lt;ul>
&lt;li>테크 컨퍼런스: 사람들이 특정 장소에 만나서 여러 이얘기를 듣는다. 참가 비용이 있다.&lt;/li>
&lt;li>밋업: 컨퍼런스보다 조금 작은 규모지만 이 데이터 모델에서는 무료로 진행된다.&lt;/li>
&lt;li>웨비나: 위 두 형태와 다르게 온라인에서 진행되고 시청을 위한 URL 이 제공된다. 유료인 경우도 있고 무료인 경우도 있다. 그리고 한 이벤트 당 하나의 주제를 제공한다.&lt;/li>
&lt;/ul>
&lt;p>이 이벤트에 대해 데이터 모델링을 시작해 보자.
각 이벤트는 Talk 라는 최소 엔티티를 구성할 수 있다. 컨퍼런스는 참가자 수용 정원, 참여 비용, 예약 인원, 참여 비용과 Talk 들로 구성된다. 밋업은 비용이 없기 때문에 참여 비용이 없다. (여기에서는 &amp;#39;free&amp;#39; 라는 문자열로 처리) 웨비나는 URL 이 추가로 제공되고 Location 정보가 없다.&lt;/p>
&lt;div class="comment-block">
&lt;p>데이터를 모델링 하는 것은 추상화 하는 것인데, (객체지향) 프로그래밍에서 가장 중요한 부분이기도 하다. 객체지향 프로그래밍은 역할 모델을 기반으로 엔티티를 구분하고 객체를 설계하는 것이다. 이건 추상화를 잘 해야 하는데… 연습도 많이 해야 하지만 세상이, 특히 비즈니스가 어떻게 움직이고 어떤 걸 필요로 하고 이걸 일반화하여 구분하고 공통점과 차이점을 찾아내어 코드로 옮기는 능력이 있어야 한다. 이런 건 어떻게 배우나?&lt;/p>
&lt;/div>
&lt;p>
교차 타입은 Intersection 이라고 하는데 `&amp;amp;` 로 타입을 묶는다. &amp;#39;and&amp;#39; 로 부르면 된다. 클래스를 확장하는 것과 유사하다. 반복되는 타입을 묶어 TechEventBase 타입으로 선언했다. 나는 TechEvent 나 BaseTechEvent 로 쓰는 편이다.
각 타입으로 이벤트를 모델링 했지만 어떤 이벤트는 웨비나가 될지 밋업 또는 컨퍼런스가 될지 모르는 경우는 유니언 타입을 사용한다. `|` 로 묶고 &amp;#39;or&amp;#39; 로 부른다. 유니언으로 묶는 경우 Type Narrowing (Type Guard) 을 해야 할 경우도 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 23
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
타입 스페이스 이동
&lt;/pre>
&lt;p>왜 인터섹션, 유니언 타입이라고 불렸는가? 집합 이론에 근거한 용어.
&amp;#39;Programming with Types&amp;#39; - Vlad Riscutia 의 정의에 따르면,&lt;/p>
&lt;div class="center-block" style="text-align: center; margin-left: auto; margin-right: auto;">
&lt;p>타입은 데이터에 대해 수행할 수 있는 동작, 데이터 자체의 의미, 허용되는 값 집합;&lt;/p>
&lt;/div>
&lt;p>이라고 한다.
허용되는 값 집합을 정의하는 부분이 우리가 중요하게 보는 부분인데 이미 우리가 타입을 사용하면서 경험한 부분이다.
유니언 타입 string | number 의 경우 숫자와 문자열이 값 집합의 제약으로 동작한다. 반면 인터섹션 타입 string &amp;amp; number 의 경우 공유하는 집합이 없다.&lt;/p>
&lt;p>
벨류 타입으로도 정의할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">withTypeAny&lt;/span>: &lt;span style="color:#66d9ef">any&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#75715e">// OK!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">withTypeString&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#75715e">// OK!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">withValueType&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#75715e">// OK!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>`conference` 타입의 경우 문자열 &amp;#39;conference&amp;#39; 가 가능한 값이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">EventKind&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;webinar&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;meetup&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tomorrowsEvent&lt;/span>: &lt;span style="color:#66d9ef">EventKind&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;concert&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우 tomorrowsEvent 는 타입 체크 단계에 실패한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 24
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
값 타입
&lt;/pre>
&lt;p>값 타입과 유니언 타입으로 테크 이벤트 데이터 구성을 개선한다. kind 필드에 string 으로 되어 있는 것을 narrowing 할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TechEventBase&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;meetup&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;webinar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 제약은 switch case 에도 적용되어 된다. 발생하지 않을 조건에 대해 검사하지 않을 수 있게 가이드 한다.
TechEventBase 에 kind 도 세 개의 개별 타입으로 내릴 수 있다. 그 전에는 string 타입이었지만 이제는 discrimicated 되었다. 이걸 discriminated union type 이라고 부른다.&lt;/p>
&lt;p>
쉽게 타입을 고정하는 기법을 배워보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">script19&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ScriptConf&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">129&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">talks&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [ ... ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>서버에서 새 이벤트 타입을 받아 보면 kind: &amp;#39;conference&amp;#39; 를 받는다 하더라도 타입 체크에 실패한다. 타입스크립트는 서버에서 받은 kind 정보를 string 으로 추론하기 때문이다. 이를 해결하기 위해 left hand typing 을 할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">script19&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// All the properties from before ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>또 다른 방법으로는 kind 를 conference 값 타입으로 정의하는 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">script19&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우도 괜찮지만 meetup 같은 경우 또다른 수정이 필요하다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">script19&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>kind 를 const 로 정의하는 경우 타입 고정이 되고 타입스크립트의 구조적 타이핑 시스템에 타입 힌트가 된다. 사이드 이펙트로 이 script19 객체는 read-only 가 된다는 단점이 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 25
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
동적 유니언 타입 만들기
&lt;/pre>
&lt;p>테크 이벤트들을 필터링 하는 함수를 만들면서 타입을 보강한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Webinar&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Conference&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Meetup&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">EventKind&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;webinar&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;meetup&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">filterByKind&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[], &lt;span style="color:#a6e22e">kind&lt;/span>: &lt;span style="color:#66d9ef">EventKind&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span>[] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">list&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>(&lt;span style="color:#a6e22e">el&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">el&lt;/span>.&lt;span style="color:#a6e22e">kind&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">kind&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 코드는 안정된 타입 정보를 바탕으로 테크 이벤트를 필터링 할 수 있지만 Hackathon 같은 새로운 이벤트가 추가되면 수정할 부분이 생긴다. EventKind 와 TechEvent 간에 연결이 끊어지는 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Hackathon&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">TechEventBase&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">location&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price?&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">kind&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;hackathon&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Conference&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Webinar&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Meetup&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Hackathon&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">filterByKind&lt;/span>(&lt;span style="color:#a6e22e">eventList&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;hackathon&amp;#39;&lt;/span>) &lt;span style="color:#75715e">// Error
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>EventKind 와 TechEvent 간에 관계를 만들자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Conference&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Webinar&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Meetup&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">Hackathon&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">EventKind&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span>[&lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이런 타입을 &amp;#39;인덱스 접근 타입&amp;#39; 또는 &amp;#39;룩업 타입&amp;#39;이라고 부른다. 하지만 타입 추론이 실패하게 된다. 동적으로 타입을 생성하기에는 이걸로 부족하다. 타입 맵을 통해 동적으로 타입을 구성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GroupedEvents&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">conference&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">meetup&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">webinar&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hackathon&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위 코드는 아래와 같이 개선될 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GroupedEvents&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">Kind&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">EventKind&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 종류의 타입을 Mapped type 이라고 부른다. 프로퍼티 이름을 직접 사용하는 대신 브라켓으로 프로퍼티를 담는 식별자를 사용한다. 이게 동작하는 과정은 아래와 같다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Resolving the type alias.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GroupedEvents&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">Kind&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span>[&lt;span style="color:#e6db74">&amp;#39;kind&amp;#39;&lt;/span>]]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Resolving the union
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GroupedEvents&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#a6e22e">Kind&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#39;webinar&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;meetup&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;hackathon&amp;#39;&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Extrapolating keys
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">GroupedEvents&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">webinar&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[], &lt;span style="color:#a6e22e">conference&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[], &lt;span style="color:#a6e22e">meetup&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[], &lt;span style="color:#a6e22e">hackathon&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>맵 타입은 편리하기도 하지만 코드량을 많이 줄여주기도 한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 26
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
객체 키와 타입 단정
&lt;/pre>
&lt;p>새로운 데이터 모델로 참가자에 대한 내용을 추가하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UserEvents&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">watching&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rvsp&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">attended&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">signedout&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>UserEventCategory 의 타입을 구하는 코드로 아래와 같이 선언하고 참가자의 이벤트를 필터링 할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UserEventCategory&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;watching&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;rsvp&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;attended&amp;#39;&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">&amp;#39;signedoff&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">filterUserEvent&lt;/span>(&lt;span style="color:#a6e22e">userEventList&lt;/span>: &lt;span style="color:#66d9ef">UserEvents&lt;/span>, &lt;span style="color:#a6e22e">category&lt;/span>: &lt;span style="color:#66d9ef">UserEventCategory&lt;/span>, &lt;span style="color:#a6e22e">filterKind?&lt;/span>: &lt;span style="color:#66d9ef">EventKind&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">filteredList&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">userEventList&lt;/span>[&lt;span style="color:#a6e22e">category&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">filterKind&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">filteredList&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">kind&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">filterKind&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">filteredList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>지난 Lesson 에서 겪은 타입 문제를 다시 해결하기 위해 동적으로 타입을 생성할 수 있는 `keyof` 연산자를 사용햐 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// &amp;#39;speaker&amp;#39; | &amp;#39;title&amp;#39; | &amp;#39;abstract&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TalkProperties&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">Talk&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// number | &amp;#39;toString&amp;#39; | &amp;#39;charAt&amp;#39; | ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">StringKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#e6db74">&amp;#39;speaker&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// number | &amp;#39;length&amp;#39; | &amp;#39;pop&amp;#39; | &amp;#39;push&amp;#39; | ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ArrayKeys&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> []&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위 예제에서 보듯 연산 대상 타입의 속성을 값 타입으로 얻을 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// no needed type UserEventCategory = &amp;#39;watching&amp;#39; | &amp;#39;rsvp&amp;#39; | &amp;#39;attended&amp;#39; | &amp;#39;signedoff&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">filterUserEvent&lt;/span>(&lt;span style="color:#a6e22e">userEventList&lt;/span>: &lt;span style="color:#66d9ef">UserEvents&lt;/span>, &lt;span style="color:#a6e22e">category&lt;/span>: &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">UserEvents&lt;/span>, &lt;span style="color:#a6e22e">filterKind?&lt;/span>: &lt;span style="color:#66d9ef">EventKind&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>UserEvent 에 새로운 타입이 추가되어도 필터링 함수에 필터 category 가 동적으로 반영되어 코드를 수정할 필요가 없게 된다.
만약 이 함수를 타입스크립트를 사용하지 않는 다른 곳에서 사용된다면, category 가 없는 리스트에 접근하게 되는 버그를 안고 있다. 추가로 제공되는 카테고리가 사용 가능한 것인지 점검하는 함수가 필요할 것이다. 그리고 이를 적용한 필터 함수는 아래처럼 개선해야 한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isUserEventListCategory&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>: &lt;span style="color:#66d9ef">UserEvents&lt;/span>, &lt;span style="color:#a6e22e">category&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Object.&lt;span style="color:#a6e22e">keys&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>).&lt;span style="color:#a6e22e">includes&lt;/span>(&lt;span style="color:#a6e22e">category&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">filterUserEvent&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>: &lt;span style="color:#66d9ef">UserEvents&lt;/span>, &lt;span style="color:#a6e22e">category&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">filterKind?&lt;/span>: &lt;span style="color:#66d9ef">EventKind&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// check it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">isUserEventListCategory&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>, &lt;span style="color:#a6e22e">category&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">filteredList&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">list&lt;/span>[&lt;span style="color:#a6e22e">category&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">filterKind&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">filteredList&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">kind&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">filterKind&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">filteredList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 되면 잘 동작하긴 하지만 타입스크립트 입장에서 category 를 단지 string 타입으로 선언하여 사용하는 것은 좋지 않다. 이 경우 type predicate 가 필요하다. 타입 narrowing 의 한 방법이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isUserEventListCategory&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>: &lt;span style="color:#66d9ef">UserEvents&lt;/span>, &lt;span style="color:#a6e22e">category&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">category&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">keyof&lt;/span> &lt;span style="color:#a6e22e">UserEvents&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Object.&lt;span style="color:#a6e22e">keys&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>).&lt;span style="color:#a6e22e">includes&lt;/span>(&lt;span style="color:#a6e22e">category&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>함수 본문의 결과는 boolean 이어야 하고 결과가 참이면 category 는 지정된 타입을 만족하는 것으로 처리된다. 단순히 string 으로 타입을 반환하던 것보다 명확한 UserEvent 를 반환하니 타입 시스템이 훼손되지 않는다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 27
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
가장 바닥에 있는 Never 타입
&lt;/pre>
&lt;p>집합론에 따라 타입을 넓히고 좁히는 과정에 가장 아래에 있는 값은 never 타입이다. 아무 것도 없는 집합이다.
any 의 반대편에 있다.
서버에서 도착하는 데이터가 그 어떤 TechEvent 타입도 아닌 경우 throw 되어 never 타입이 된다.
다루고 있는 예제에서 실수로 hackathon 에 대한 코드를 작성하지 않았다면 getEventTeaser 함수는 타입 체크에 실패할 것이고 우리는 코드를 완결 할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">neverError&lt;/span>(&lt;span style="color:#a6e22e">message&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">token&lt;/span>: &lt;span style="color:#66d9ef">never&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Error(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">. &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">token&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> should not exist`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">getEventTeaser&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span>: &lt;span style="color:#66d9ef">TechEvent&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">kind&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;conference&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> (Conference), `&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">`priced at &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> USD`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;meetup&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> (Meetup), `&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">`hosted at &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">location&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;webinar&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> (Webinar), `&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">`available online at &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#39;hackathon&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">`even that: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#a6e22e">neverError&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Not sure what to do with that&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">event&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 28
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
undefined 와 null
&lt;/pre>
&lt;p>null 과 undefined 는 값이 없다는 표현을 담당한다. 타입의 관점에서 undefined 는 아직 값이 할당되기 전에 값이 없는 상태이고 null 은 변수나 속성에 값을 지우기 위해 빈 값이 할당하는 것이다. never 타입처럼 가장 아래 쪽에 있는 타입이다. 아쉽게도 이 바텀 벨류에 대해 논의는 많이 있었지만 이 값이 두 종류여야 한다는 의견은 없었다.
타입 공간에서 undefined 와 null 은 각각의 타입 공간에 존재한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">age&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#75715e">// Let&amp;#39;s define a number variable
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">// I&amp;#39;m getting one year older!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위 코드는 이상이 없는 타입스크립트 코드지만 결과는 NaN 이다.
tsconfig.json 에서 strictNullChecks 가 활성화 되어 있다면 null, undefined 는 각 타입에서 배제된다. Number 타입의 예를 들면 undefined 와 null 은 number 타입에 속하지 않게 된다. 위 예제에서 age = age + 1 은 타입 체크에서 실패한다.
html querySelector 를 통해 반환되는 결과는 null 일 수 있는데 예제에서 사용한 코드에는 null 에 대한 가정이 없다. 그래서 list.append 코드는 nullish 에 대한 처리가 필요하다.
많은 경우 nullish 값을 사용할 경우 null 이나 undefined 중 하나로 강제하여 사용할 수 있도록 하자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-9" class="outline-3">
&lt;h3 id="headline-9">
튜플 타입에 대하여
&lt;/h3>
&lt;div id="outline-text-headline-9" class="outline-text-3">
&lt;p>
타입스크립트에서 튜플 타입은 길이를 가진 배열 형태이다. 각 엘리먼트의 타입이 선언되어 있다. 각 타입은 다를 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">38&lt;/span>] &lt;span style="color:#75715e">// tuple is `(string | number)[]`
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>`as` 키워드를 통해 immutable 하게 선언할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tuple&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">38&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#75715e">// tuple is read-only [string, number]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>함수 반환 타입에도 사용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">useToggleState&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#66d9ef">boolean&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... Some magic
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Type checks!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#66d9ef">false&lt;/span>, () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> { &lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">state&lt;/span>}]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 3</title><link>https://faultnote.github.io/posts/typescript-50-lessons-3/</link><pubDate>Sat, 19 Feb 2022 14:46:31 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-3/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 15 타입스크립트는 값을 생성하</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 15
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
타입스크립트는 값을 생성하는 영역과 타입을 생성하는 영역으로 구분, 함수는 값을 생성
&lt;/pre>
&lt;p>
함수는 선언부와 본문으로 구성된다. `declare` 키워드는 함수의 본문을 구현하지 않고 코드를 구성할 수 있게 해준다. 인자부와 반환부에 타입을 선언할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Result&lt;/span>[]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>실제 구현을 하게 되면 이 함수는 비동기로 작동하는데 데이터 fetch 를 위해 `fetch` 함수를 사용하기로 가정하면, 자바스크립트의 fetch 는 `Promise&amp;lt;any&amp;gt;` 를 반환하기 때문에 이 값을 Result 타입으로 캐스팅하여 타입 세이프한 환경을 구성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`/search&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">queryString&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>() &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>`as` 키워드는 좌측의 값을 우측의 타입으로 처리한다. 함수 선언부에 반환 정보를 정의하는 것과 같은 역할을 한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`/search&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">queryString&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>저자는 함수 선언부에 사용하는 것을 선호한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 16
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
함수 인자의 콜백 함수에 타입을 정의하여 타입 시스템을 강화
&lt;/pre>
&lt;p>
`typeof` 연산을 함수에 적용하면 함수의 타입을 알 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
함수 인자를 `Query` 라는 타입으로 정의해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Query&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assemble&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">includeTags&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>&amp;#39;assemble&amp;#39; 인자는 함수 타입을 가지고 이 함수는 includeTags 를 받아서 string 을 반환하는 콜백 함수인 것을 알 수 있다. 물론 이렇게 개선할수도 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">AssembleFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">includeTags&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Query&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[], &lt;span style="color:#a6e22e">assemble&lt;/span>: &lt;span style="color:#66d9ef">AssembleFn&lt;/span> }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
콜백 함수를 사용하는 코드는 특정 기능을 끼워넣을 수 있는 함수로 패턴화 된다.
브라우저의 특정 엘리먼트에서 값을 받아 다른 엘리먼트로 노출하는 함수를 정의한다면 아래와 같이 확장이 가능하다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">displaySearch&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">inputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">outputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">search&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 함수는 반환하는 값이 없다. (그냥 바깥 세상에 사이드이펙트만 발생시킨다.) `void` 는 lesson 17 에서 조금 더 알아본다.&lt;/p>
&lt;p>
`구조적 타입 시스템` 에서 함수 인자의 타입 정보는 이름에 제약되지 않고 인자의 전달 순서에 따라 제약된다. 아래 두 함수는 같은 타입 정보를 가진다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">testSearch&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>, &lt;span style="color:#a6e22e">tags&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>([{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`The &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">query&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> test book`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">query&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-design-patterns`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">abstract&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`A practical book on &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">query&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">testSearch&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>, &lt;span style="color:#a6e22e">options&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>([{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`The &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">term&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> test book`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">term&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-design-patterns`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">abstract&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`A practical book on &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">term&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위 코드의 경우 &amp;#39;tags&amp;#39; 나 &amp;#39;options&amp;#39; 는 사용되지 않고 있다. 구조적 타입 시스템에서 이 두 번째 인자를 생략해도 타입 점검을 정상적으로 완료한다. 이어지는 레슨에서 이 타입들을 좀 더 다듬어 볼 예정이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 17
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
대체가능성
&lt;/pre>
&lt;p>
이전 코드의 함수 본문에서 첫 번째 인자도 사용하지 않는다면 선언하지 않아도 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">dummyContentSearchFn&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>([{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Form Design Patterns&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/form-design-patterns&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">abstract&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;A practical book on accessible forms&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
자바스크립트에서 함수는 인자의 개수에 따라 주의해야할 케이스가 있다. 필요한 인자가 없는 경우와 인자가 너무 많은 경우인데 함수를 실행할 때 필요한 인자가 없는 경우 런타임에 실행 실패한다. 인자가 너무 많은 경우 초과된 인자 그냥 무시된다.
이런 오류들은 타입스크립트를 적용하면 사전 점검된다.&lt;/p>
&lt;p>
&amp;#39;SearchFn&amp;#39; 을 사용하는 displaySearch 함수의 인자로 콜백 함수를 전달하는데 SearchFn 의 모양을 가지면 사용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">displaySearch&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;input&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;output&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">dummyContentSearchFn&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이를 대체 가능성이라 한다.&lt;/p>
&lt;p>
대체 가능성은 반환하는 값의 타입이 일치하면 이루어진다. 위 코드의 경우 두 콜백 함수 모두 배열 결과를 담은 promise 함수를 반환하고 있다.&lt;/p>
&lt;p>
타입스크립트의 `void` 는 다른 프로그래밍 언어에서 사용하는 void 와 조금 다르다.
자바스크립트의 모든 함수는 기본적으로 undefined 를 반환한다. 타입스크립트에서도 모든 함수는 반환 타입이 있다. 타입 추론이 어려울 경우 기본적으로 `void` 타입을 반환한다. void 타입의 하나의 값이 있는데 그 값은 &amp;#39;undefined&amp;#39; 이다.&lt;/p>
&lt;p>
void 타입은 모든 반환 타입에 대해 대체 가능하다. 콜백 함수가 void 반환인 경우 number 를 반환해도 타입 점검은 성공한다. 하지만 실제 반환되는 타입은 undefined 이기 때문에 다른 연산은 할 수 없다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`/search&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">queryString&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>() &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">didItWork&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">didItWork&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우 didItWork 는 undefined 를 가지기 때문에 컴파일에 실패한다.
바닐라 자바스크립트에서도 void 를 사용하여 함수의 실행 결과를 undefined 시킬 수 있다.&lt;/p>
&lt;p>
함수의 반환 타입을 `void` 에서 `undefined` 로 변경하면 대체 가능성을 제거할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>그리고 옵셔널 파라미터는 가장 마지막에 전달하는게 관행이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 18
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
콜백 함수의 첫 인자에 명시적으로 this 를 추가하고 타입을 부여할 수 있다.
&lt;/pre>
&lt;p>
displaySearch 함수를 작성하는 과정에 this 를 사용하게 되는데 this.value 같은 경우 타입 추론이 실패하여 컴파일이 되지 않는다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">displaySearch&lt;/span>(&lt;span style="color:#a6e22e">inputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">outputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">search&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#a6e22e">inputId&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;change&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">searchTerm&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>DOM 엘리먼트도 타입스크립트를 위해 타입을 제공하고 있다. 타입을 좁혀 타입스크립트 컴파일러가 추론이 가능하도록 개선해 본다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">HTMLInputElement&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">searchTerm&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이어서 이 addEventListner 의 콜백을 별도의 함수로 분리하면 this 는 콜백 함수의 첫 번째 인자로 this 의 타입을 정의해 줄 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">inputChangeHandler&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 인자는 타입스크립트만을 위한 정보로 컴파일된 자바스크립트에는 사라지게된다.&lt;/p>
&lt;div class="src src-javascript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">inputChangeHandler&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>그리고 this 를 포함한 함수는 호출되는 컨텍스트에 따라 달라지기 때문에 this 를 HTMLElement 타입으로 추론할 수 없는 위치에서 호출하게 되면 컴파일 되지 않는다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 19
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
함수 타입의 추가 기능들
&lt;/pre>
&lt;p>
tagged template 함수는 함수 호출에 &amp;#39;(인자)&amp;#39; 대신 &amp;#39;`인자`&amp;#39; 를 사용한다. 태그드 템플릿은 템플릿 문자 배열과 대상이 되는 문자열 표현식으로 구분된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">taggedTemplate&lt;/span>&lt;span style="color:#e6db74">`템플릿A&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿B`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">taggedTemplate&lt;/span>&lt;span style="color:#e6db74">`템플릿A&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿B&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿C`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">taggedTemplate&lt;/span>&lt;span style="color:#e6db74">`템플릿A&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿B&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿C&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿D`&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>템플릿과 표현식은 배열로 처리되는데 표현식은 rest 연산자를 통해 표현된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">taggedTemplate&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, ...&lt;span style="color:#a6e22e">tags&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Promise 를 반환하는 경우 async 로 함수를 선언하고 await 를 통해 Promise 의 resolved 값을 받을 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 20
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
함수 오버로딩
&lt;/pre>
&lt;p>
타입스크립트는 함수 인자의 개수와 인자/반환 타입이 달라지는 경우를 위해 함수 오버로딩을 지원한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우 실제 구현 형태는 이렇게 풀이된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">p2?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> ((&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>), &lt;span style="color:#a6e22e">p3?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>처음으로 `|` 를 통한 유니언 타입이 소개되고 있다.
이 함수를 타입으로 등록하면 좀 더 나은 코드를 볼 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SearchOverload&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>: &lt;span style="color:#66d9ef">SearchOverload&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">p2?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> ((&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>), &lt;span style="color:#a6e22e">p3?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// body
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 21
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
제너레이터
&lt;/pre>
&lt;p>
제너레이터는 이터레이션을 구현하기 위해 시간의 흐름에 따라 값을 생성해 제공해 준다. 타입스크립트는 다양한 타입 정보를 제공하여 제너레이터 함수를 손쉽게 사용할 수 있도록 해준다.
제너레이터 함수의 반환 타입은 아래와 유사하다. async 함수가 반환하는 Promise 와 비교해 보면 도움이 될 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Generator&lt;/span>&amp;lt;&lt;span style="color:#f92672">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">4&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">unknown&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>제너레이터는 풀링이 필요한 시스템에서 유용하다. fetch 를 통해 데이터를 받도록 하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">PollingResults&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]; &lt;span style="color:#a6e22e">done&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">polling&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">PollingResults&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/...&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">res&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>입력이 있을 때마다 백엔드에서 쿼리를 조회하는 제너레이터 함수는 이렇게 구성된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">getResults&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">AsyncGenerator&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[],&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">unknown&lt;/span>&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">polling&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">results&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">done&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>AsyncGenerator 타입은 타입스크립트의 시스템 인터페이스로 등록되어 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getResults&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#a6e22e">someFn&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>제너레이터는 이터레이터이기 때문에 `for … of` 대상이 된다.
yield 의 반환 값을 처리하기 위해 .next() 을 사용할 수 있다. `.next(value)` 를 통해 yield 의 반환 값을 받을 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>, &lt;span style="color:#a6e22e">stop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">polling&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stop&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">results&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">stop&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>브라우저에서 입력된 값을 사용하는 제너레이터 호출 구문은 아래처럼 구성될 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;searchField&amp;#39;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;change&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">handleChange&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">handleChange&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>, &lt;span style="color:#a6e22e">ev&lt;/span>: &lt;span style="color:#66d9ef">Event&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">HTMLInputElement&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getResults&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>, &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span>(&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#a6e22e">appendResultToAnswerArea&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">done&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>await 와 .next(isStop) 을 통해 비동기로 데이터를 요청하고 반환된 결과의 상태에 따라 응답읍 제공한다.
이 경우 AsynGenerator 의 타입은 이렇게 정의된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">AsyncGenerator&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[],&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">boolean&lt;/span>&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>로컬 웹 서비스에 Easy-RSA 인증서 적용하기</title><link>https://faultnote.github.io/posts/easyrsa-nginx-guide/</link><pubDate>Sat, 12 Feb 2022 14:05:53 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/easyrsa-nginx-guide/</guid><description>nginx 서버에 로컬 호스트의 도메인을 위한 인증서를 적용하는 가장 쉽고 빠른 방법 개인 키/공개 키 기반 인증 시스템 PKI - Public Key Infrastructure 이해하기 우리말로 공개 키 기반 인증 시스템 으</description><content>&lt;blockquote>
&lt;p>nginx 서버에 로컬 호스트의 도메인을 위한 인증서를 적용하는 가장 쉽고 빠른 방법&lt;/p>
&lt;/blockquote>
&lt;h2 id="개인-키공개-키-기반-인증-시스템">개인 키/공개 키 기반 인증 시스템&lt;/h2>
&lt;h3 id="pki---public-key-infrastructure-이해하기">PKI - Public Key Infrastructure 이해하기&lt;/h3>
&lt;p>우리말로 &lt;code>공개 키 기반 인증 시스템&lt;/code> 으로 이해할 수 있는데, 사실 한 쌍의 키가 중심이 되지만 &amp;lsquo;공개 키&amp;rsquo; 라고 불리는 이유는 이 공개 키를 기반으로 암호화 하는 과정이 핵심이라 그런 듯 하다.&lt;/p>
&lt;p>공개 키 기반 인증은 한 쌍의 키를 전제로 한다. 만들어 진 한 쌍의 키는 하나는 공개용, 다른 하나는 비공개용 개인 키이다.&lt;/p>
&lt;h4 id="공개키-기반-암호화복호화">공개키 기반 암호화/복호화&lt;/h4>
&lt;p>PKI 를 통한 통신 과정에 암호화/복호화 작업은 기존에 보내는 사람이 주체가 되어 암호화 하는 과정에 일부 변형이 추가되었다. 암호화된 파일을 받을 대상의 공개 키로 암호화 하는 것이 핵심이다.&lt;/p>
&lt;p>인터넷에 있는 많은 참고 이미지 중 이 도식이 가장 좋은 것 같다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/pki-brief.jpeg" alt="https://bobbyarvian.blogspot.com/2010/05/pki-public-key-infrastructure-dan-ca.html" title="PKI-public key infrastructure dan CA-certificate authority">&lt;/p>
&lt;p>나를 Sender 라 하고 받을 대상을 Recipient 라 보면, 받을 대상의 공개 키로 암호화 하여 파일을 보내면 된다.&lt;/p>
&lt;p>내가 누군가에게 암호화된 파일을 받기 위해서 내 공개 키를 제공하면 된다. 인증 관련된 서비스에서 요구하는 공개키가 이런 개념이다.&lt;/p>
&lt;blockquote>
&lt;p>예를 들면, 깃헙의 애플리케이션 연동이나 ssh 서버 연결에 사용되는 public key 가 이런 종류다.&lt;/p>
&lt;/blockquote>
&lt;p>ssh 접속의 경우 내 공개키는 각 클라이언트와 서버가 암호화된 통신을 할 때 사용된다.&lt;/p>
&lt;p>이 방식을 응용하여 메일을 교환하거나 송신, 수신되는 네트워크의 데이터들을 암호화 한다.&lt;/p>
&lt;h4 id="x509">X.509&lt;/h4>
&lt;p>X.509 는 이 공개 키 기반의 인증 시스템으로 1988년 시작되어 현재는 버전3 를 사용하고 있다. 공개 키 기반의 다른 인증 시스템과 다르게 인증 기관이라는 개념을 도입하여 상위 기관을 통해 인증을 허용하는 시스템을 구성하고 있다.&lt;/p>
&lt;p>인증서 작업에 사용되는 파일의 종류를 좀 알아두면 좋다. 대부분 모두 일반 텍스트 파일이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>.key&lt;/code>: 개인 키 파일이다. 이 파일은 공개용이 아니다.&lt;/li>
&lt;li>&lt;code>.csr&lt;/code>: 인증 기관에 인증서를 받기 위해 요청하는 스펙을 담은 문서&lt;/li>
&lt;li>&lt;code>.crt&lt;/code>: 인증서 자체, 암호화된 인증서 파일&lt;/li>
&lt;li>&lt;code>.pem&lt;/code>: Base64 로 인코딩된 인증서로 웹 서버에 사용된다.&lt;/li>
&lt;/ul>
&lt;h4 id="브라우저-통신과-ssltls">브라우저 통신과 SSL/TLS&lt;/h4>
&lt;p>웹 서버 데이터에 대한 암호화를 위해 무한에 가까운 수의 서비스가 공개 키를 제공하고 이를 관리하기에는 효율이 좋지 않기에 제3자가 개입하여 인증을 대행하는 방식이다.&lt;/p>
&lt;p>CA (Certificate authority) 또는 Root Certificate (루트 인증 기관) 라고 불리는 기관들이 이 역할을 한다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/ca-tls-brief.jpeg" alt="https://bobbyarvian.blogspot.com/2010/05/pki-public-key-infrastructure-dan-ca.html" title="PKI-public key infrastructure dan CA-certificate authority">&lt;/p>
&lt;p>https 통신에 사용되는 보안 프로토콜로 1999년 SSL(Secure Sockets Layer) 3.0 이 TLS(Transport Sockets Layer) 1.0 으로 공개 되었다.&lt;/p>
&lt;p>현재 SSL 버전 사용은 권고 되지 않는다.&lt;/p>
&lt;h2 id="openssl-과-easy-rsa">OpenSSL 과 Easy-RSA&lt;/h2>
&lt;p>OpenSSL 은 이런 암호화/복호화에 관여하는 프로토콜인 TLS 의 오픈소스 구현으로 다양한 시스템에 사용되고 있으며 무료 인증서로 자주 거론되는 Let&amp;rsquo;s encrypt 에서도 사용하고 있다.&lt;/p>
&lt;p>얼마 전 (2021년) 3.0 을 공개하였다.&lt;/p>
&lt;blockquote>
&lt;p>openssl 툴을 활용해 다양한 인증서 생성 및 인증 요청서를 만들수 있는데, 조금 복잡하다. 그래서 이 과정을 단순화하고 체계적으로 유지하기 위한 &amp;rsquo;easy-rsa&amp;rsquo; 가 개발되어 있고, 이를 사용하여 로컬 서비스에 인증서를 적용하는 방법을 알아보려 한다.&lt;/p>
&lt;/blockquote>
&lt;p>아마 대부분의 개발자 시스템에 openssl 은 설치되어 있을 것이다. 추가로 easy-rsa 를 설치해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ brew info easy-rsa
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실행 파일은 &lt;code>easyrsa&lt;/code> 이니 헷갈리지 말자.&lt;/p>
&lt;p>Public Key Infrastructure(PKI) 환경을 구성하기 위해 초기화 작업이 필요하다.
개인키가 없지 않겠지만 easyrsa 를 통해 서비스용을 하나 만들자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa init-pki
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="macos-키체인-유틸리티">macOS 키체인 유틸리티&lt;/h3>
&lt;p>인증서를 생성하기 전에 인증서를 운영체제에서 사용하고 유지/관리하는 방법을 이해해야 한다.&lt;/p>
&lt;p>맥OS 에서 인증서는 &lt;code>Keychain Access&lt;/code> 유틸리티를 통해 관리할 수 있다. 이 안에 각종 루트 인증서들이 있고 우리가 만들 사설 루트 인증서를 추가하여 관리할 것이다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/macos-keychain-access.png" alt="macOS Keychain Access">&lt;/p>
&lt;h3 id="시나리오">시나리오&lt;/h3>
&lt;p>주요 작업 시나리오는 다음과 같다.&lt;/p>
&lt;ol>
&lt;li>가상의 최상위 인증 기관 인증서 생성&lt;/li>
&lt;li>최상위 인증 기관의 인증서를 운영체제에 추가, 사용 허용&lt;/li>
&lt;li>인증 기관에서 상속된 서비스용 인증서 생성&lt;/li>
&lt;li>nginx 에 인증서 적용&lt;/li>
&lt;/ol>
&lt;h3 id="루트-인증서-발급">루트 인증서 발급&lt;/h3>
&lt;p>웹 브라우저는 루트 인증기관(CA)을 신뢰하고 대부분의 브라우저는 이 루트 인증서와 암호화된 통신 프로토콜을 내장하고 있다.&lt;/p>
&lt;p>실제 서비스에는 이 루트 인증기관에서 비용을 제공하고 운영할 서비스 사이트의 인증서를 발급 받아 적용해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>우리가 사용할 로컬 개발 환경의 웹 서버를 위해 인증서를 구입하거나 실제 도메인이 부여되지 않은 사이트의 인증서를 발급 받기는 애매하다. 그래서 가상의 루트 인증기관을 만들어 루트 인증서를 생성하고 이 기관을 통해 로컬 서비스의 인증서를 생성해 웹 서버에 적용할 것이다.&lt;/p>
&lt;/blockquote>
&lt;h4 id="ca-만들기">CA 만들기&lt;/h4>
&lt;p>easyrsa 를 통해 루트 인증기관의 인증서를 쉽게 생성할 수 있다. 이 과정은 CA 에 대한 조직 정보를 포함한다. easyrsa 는 &lt;code>Easy-RSA CA&lt;/code> 을 사용한다. 그대로 쓰자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa build-ca
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>생성된 인증서는 &lt;code>/usr/local/etc/pki/ca.crt&lt;/code> 에서 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cat /usr/local/etc/pki/ca.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 과정은 다음 내용을 포함하고 있다.&lt;/p>
&lt;ol>
&lt;li>루트 인증기관을 위한 개인 키를 만들고 → &lt;code>.key&lt;/code> 파일&lt;/li>
&lt;li>인증 서명 요청서를 만들고 → &lt;code>.csr&lt;/code> 파일&lt;/li>
&lt;li>x509 서명까지 완성한다 → &lt;code>.crt&lt;/code> 파일&lt;/li>
&lt;/ol>
&lt;p>만들어진 루트 인증서 내용은 easyrsa 를 통해 확인할 수 있다. 기본적으로 10년 짜리 서명을 제공해 준다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa show-ca
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Using SSL: /usr/local/opt/openssl@1.1/bin/openssl OpenSSL 1.1.1m &lt;span style="color:#ae81ff">14&lt;/span> Dec &lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Showing details &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ca&amp;#39;&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This file is stored at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/local/etc/pki/ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="keychain-access-에-추가-및-허용">KeyChain Access 에 추가 및 허용&lt;/h4>
&lt;p>&lt;code>File &amp;gt; Import Item&lt;/code> 메뉴를 통해 위에서 생성한 루트 인증서를 추가하고 안전한 사용을 허용하자.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/macos-keychain-access-permit-root-cert.png" alt="macOS Keychain Access">&lt;/p>
&lt;p>이 작업 후에는 로그아웃 하고 다시 로그인 하여 시스템에 인증서가 적재되도록 한다.&lt;/p>
&lt;h3 id="로컬-서비스용-인증서-발급">로컬 서비스용 인증서 발급&lt;/h3>
&lt;p>이제 우리가 사용할 로컬 서비스의 서버 인증서 만들자.&lt;/p>
&lt;p>마찬가지로 서버 용 비공개 키를 만들고 루트 인증 기관의 인증을 받아 서버 인증서를 만든다. 복잡한 절차가 있지만 easyrsa 로 단순하게 처리할 수 있다.&lt;/p>
&lt;p>이 과정에서 &lt;code>localhost&lt;/code> 라는 파일 이름 기반의 식별자를 사용하였다. 이 부분을 xxx-server 등으로 자유롭게 변경하여 사용할 수 있다.&lt;/p>
&lt;h4 id="멀티-호스트-인증">멀티 호스트 인증&lt;/h4>
&lt;p>내 경우 관리하는 호스트가 여러 개이다 보니 멀티 호스트 인증을 하면 하나의 인증서로 다중 도메인을 처리할 수 있다. &lt;code>EASYRSA_EXTRA_EXTS&lt;/code> 환경 변수에 추가할 도메인 정보를 담아 생성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ export EASYRSA_EXTRA_EXTS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;subjectAltName=DNS.1:local.site-a,DNS.2:local.site-b&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="서버-인증서-생성">서버 인증서 생성&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa build-server-full localhost nopass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>nopass&lt;/code> 옵션은 인증서의 사용 과정에 패스워드를 적용하지 않는 옵션이다.&lt;/p>
&lt;blockquote>
&lt;p>서버 인증서는 nginx 등의 서버를 구동할 때마다 패스워드를 요구해서 보통 패스워드 없이 생성한다.&lt;/p>
&lt;/blockquote>
&lt;p>이렇게 생성된 인증서는 &lt;code>/usr/local/etc/pki/issued&lt;/code> 에 저장되어 있다.&lt;/p>
&lt;p>앞 부분에는 인증 대상의 정보가 있고 아래에 인증서 정보가 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cat /usr/local/etc/pki/issued/localhost.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ easyrsa show-cert localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Extended Key Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TLS Web Server Authentication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Digital Signature, Key Encipherment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Alternative Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DNS:local.site-a, DNS:local.site-b, DNS:local.site-c, DNS:local.site-d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Subject Alternative Name:&lt;/code> 항목에 다중 도메인이 기록된 것을 확인할 수 있다.&lt;/p>
&lt;h4 id="nginx-용-인증서-조립">nginx 용 인증서 조립&lt;/h4>
&lt;p>이렇게 생성된 인증서를 웹 서버에 사용하기 위해 조립 과정을 거쳐야 한다.&lt;/p>
&lt;p>핵심은 서버 인증서와 루트 인증서를 결합하여 웹 서버에 맞는 인증서 파일을 생성하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cat -p /usr/local/etc/pki/issued/localhost.crt &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> /usr/local/etc/pki/ca.crt &amp;gt; ./server.pem
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>오리지널 cat 대신 bat 을 사용하고 있어 &lt;code>-p&lt;/code> 옵션이 추가되었다.&lt;/p>
&lt;/blockquote>
&lt;p>이렇게 생성된 파일과 서버의 키 정보를 nginx conf 에 추가하자.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">ssl_certificate [server.pem 이 있는 경로]/server.pem;
ssl_certificate_key /usr/local/etc/pki/private/localhost.key;
&lt;/code>&lt;/pre>&lt;p>easyrsa 가 없었으면 아래와 여러 단계의 과정을 거쳐야 했을 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ openssl ecparam -out server.key -name prime256v1 -genkey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ openssl req -new -sha256 -key server.key -out server.csr -config ./openssl-host.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ openssl x509 -req -sha256 -days &lt;span style="color:#ae81ff">365&lt;/span> -in server.csr -CA /usr/local/etc/pki/ca.crt -CAkey /usr/local/etc/pki/private/ca.key -CAcreateserial -out server.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ openssl x509 -in server.crt -text -noout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>물론 openssl 을 통해 생성된 인증서를 점검할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ openssl x509 -in /usr/local/etc/pki/issued/localhost.crt -text -noout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://faultnote.github.io/posts/images/ngixn-certi-localhost.png" alt="certified localhost in nginx">&lt;/p>
&lt;h4 id="인증서-관리">인증서 관리&lt;/h4>
&lt;p>&lt;code>easyrsa&lt;/code> 는 &lt;code>renew&lt;/code> 나 &lt;code>revoke&lt;/code> 등의 명령이 제공된다.&lt;/p>
&lt;p>revoke 하더라도 기존 .key 파일이나 .csr 등의 파일을 지워주는 것이 아니니 따로 삭제해줘야 한다.&lt;/p>
&lt;p>도메인 추가 정도라면 EASYRSA_EXTRA_EXTS export 를 수정하고 renew 하면 된다.&lt;/p></content></item><item><title>TypeScript 50 Lessons Part 2</title><link>https://faultnote.github.io/posts/typescript-50-lessons-2/</link><pubDate>Sat, 22 Jan 2022 12:40:51 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-2/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 9 any 괜찮은가? 아니, 안괜찮</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 9
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
any 괜찮은가? 아니, 안괜찮음
&lt;/pre>
&lt;p>
타입스크립트에서 `:` 을 통해 정의되는 타이핑 기법을 레프트핸드 타이핑이라고 한다.&lt;/p>
&lt;ul>
&lt;li>Left-Hand Typing: 식별자에 선언되는 타입 정보를 통해 타입을 정의한다.&lt;/li>
&lt;li>Right-Hand Typing: 식별자에 대입되는 값 정보를 통해 타입이 추론된다.&lt;/li>
&lt;/ul>
&lt;p>라이트핸드 타이핑은 조금 더 자바스크립티 하다.&lt;/p>
&lt;p>
`any` 타입은 가능하면 사용하지 말자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 10
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
조건문을 추가하여 타입을 제한을 우회하기
&lt;/pre>
&lt;p>
타입 좁히기 기법은 비교/조건문을 통해 any 나 unknown 이 주는 위험을 보완할 수 있다.&lt;/p>
&lt;ol>
&lt;li>타입 가드: typeof 같은 연산을 통해 타입 정보를 추론할 수 있다.&lt;/li>
&lt;li>타입 비교 구문: 타입 가드를 통해 추론된 타입 정보로 이어지는 코드의 식별자에 대해 타입을 추론한다.&lt;/li>
&lt;li>타입 좁히기: any 타입이 적용된 식별자라 하더라도 타입을 제한할 수 있게 된다.&lt;/li>
&lt;/ol>
&lt;p>`any` 는 모든 타입의 수퍼 타입이다. 예를 들면, DOM 에서 `HTMLElement` 는 모든 HTML 엘리먼트의 수퍼 타입이다. 그래도 `any` 가 필요한 경우에는 `unknown` 으로 타협하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">selectDeliveryAddress&lt;/span>(&lt;span style="color:#a6e22e">addressOrIndex&lt;/span>: &lt;span style="color:#66d9ef">unknown&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;number&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">deliveryAddresses&lt;/span>[&lt;span style="color:#a6e22e">addressOrIndex&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우 unknown 타입은 number 타입으로 추론되어 string 을 반환하는 함수에 적합하지 않은 타입을 반환하게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;number&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">deliveryAddresses&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">deliveryAddresses&lt;/span>[&lt;span style="color:#a6e22e">addressOrIndex&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;string&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 조건문을 추가하여 타입 가드를 완성한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 11
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
객체에 타입 정보를 추가하면서 구조적 타입 시스템과 과잉 속성 점검 기능을 이해하기
&lt;/pre>
&lt;p>
두 개의 최상위 타입 any 와 unknown 도 타입스크립트 전용의 원시 타입이다.
객체는 컴포지트 타입에 속한다. Shape 이 다른 경우 타입 오류를 유발한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stock&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">description&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">movie&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Helvetica&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">6.66&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.19&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stock&lt;/span>: &lt;span style="color:#66d9ef">1000&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>description 이 누락되어 타입 에러이다. 만약 타입에 정의된 프로퍼티 이외의 프로퍼티를 추가해도 타입 에러를 낸다. 그런데 이런 경우는 에러를 찾아내지 못한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">movieRated&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Helvetica&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">6.66&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.19&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stock&lt;/span>: &lt;span style="color:#66d9ef">1000&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">description&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;90 minutes of gushing about Helvetica&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rating&lt;/span>: &lt;span style="color:#66d9ef">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">movie&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">movieRated&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>타입스크립트의 구조적 타입 시스템에 따라 구조적 계약을 이행하는 조건이라면 타입 체크를 통과한다.&lt;/p>
&lt;p>
조금 깊게 본다면 대입문을 통해 새로운 식별자에 객체를 지정하는 과정(객체 할당)에 객체 주소의 복사가 일어나기 때문이다. 즉, 대입문을 통한 객체 할당 과정에서 계약 조건을 만족하면 타입 체크를 통과하는 것으로 이해할 수 있다.&lt;/p>
&lt;p>
그리고, 타입이 정의된 식별자 이름과 무관하게 모양이 같으면 같은 타입으로 혼용할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>타입스크립트의 타입 시스템은 친절하다고 소개하고 있지만 노미널 타입을 선호하는 사용자에게는 조금 부실하다.&lt;/p>
&lt;/blockquote>
&lt;p>
레프트핸드 타이핑이 동작 가능한 경우 과잉 속성 점검 기능을 통해 식별자에 대입시 초과되는 속성을 검사하여 오류를 제공한다. 물론 부족한 속성이 있어도 오류다.&lt;/p>
&lt;p>
함수의 인자로 객체를 전달할 때 타입 정의를 포함할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createArticleElement&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createArticleElement&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>, &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>명시적으로 풀어 사용해도 모양만 맞으면 된다. 당연히 과잉 속성 점검 기능도 동작한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">createArticleElement&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Design Systems by Alla Kholmatova&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">20&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.19&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rating&lt;/span>: &lt;span style="color:#66d9ef">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 12
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
객체 타입을 구분하기
&lt;/pre>
&lt;p>
복잡한 객체 구조가 있을 경우 객체 타입을 나눠서 새 객체 타입을 구성하는 방법을 소개하고 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">OrderComplex&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">articles&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">customer&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">address&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">city&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">zip&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">street&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">number&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dateOfBirth&lt;/span>: &lt;span style="color:#66d9ef">Date&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이런 구성의 객체 타입은 풀어 쓰면 이렇게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ArticleStub&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">city&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">zip&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">street&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">number&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">address&lt;/span>: &lt;span style="color:#66d9ef">Address&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dateOfBirth&lt;/span>: &lt;span style="color:#66d9ef">Date&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">articles&lt;/span>: &lt;span style="color:#66d9ef">ArticleStub&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">customer&lt;/span>: &lt;span style="color:#66d9ef">Customer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
다양한 기능으로 무장한 타입스크립트의 `typeof` 연산자를 통해 실제 객체 변수에 저장된 값을 추론해 새로운 타입으로 등록할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">someOrder1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
옵셔널 프로퍼티 선언을 통해 유연한 타입 시스템을 구성할 수 있다. 강타입을 구현하면서 Null safety 를 실현하는 모던 프로그래밍 언어의 특징 중 하나이다.&lt;/p>
&lt;p>
이렇게 정의된 타입만 공유하기 위해 `import type` `export type` 구문을 사용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// some-example.ts file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stock?&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">description?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> { &lt;span style="color:#a6e22e">Article&lt;/span> } &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#39;./some-example&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">book&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">29&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Another book by Smashing Books&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 13
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
객체 타이핑
&lt;/pre>
&lt;p>
타입스크립트가 자바스크립트로 컴파일 되는 동안 값 정보만 남고 우리가 추가한 타입 정보는 사라지게 된다. 하지만 클래스는 그 자체로 타입 정보와 값 정보를 가지고 있는 특징이 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">isPercentage&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amount&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#a6e22e">isPercentage&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>, &lt;span style="color:#a6e22e">amount&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isPercentage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">isPercentage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">amount&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isPercentage&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>클래스는 두 파트로 구성되는데 생성자와 프로토타입으로 나뉜다. 프로토타입은 객체의 모양을 정의하고 생성자에 의해 실체화 된다. 타입스크립트의 구조적 타이핑 기법에 따라 아래는 `Discount` 객체를 생성해 낼 수 있게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">DiscountType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">isPercentage&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amount&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">disco&lt;/span>: &lt;span style="color:#66d9ef">DiscountType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#ae81ff">0.2&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>구조적 타입 시스템에서 중요한 것은 오직 모양이다. 그 이름은 무의미하다.&lt;/p>
&lt;p>
클래스는 상속을 통해 확장할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TwentyPercentDiscount&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constructor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#ae81ff">0.2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">40&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">isValidForDiscount&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-4">
&lt;h4 id="headline-7">
구조적 타입 시스템과 명명형 타입 시스템
&lt;/h4>
&lt;div id="outline-text-headline-7" class="outline-text-4">
&lt;p>최근 프로그래밍 언어의 타입 시스템은 두 종류로 구분할 수 있다.&lt;/p>
&lt;ul>
&lt;li>Nominal Typing 을 가지는 언어: C++, Java 등; 클래스의 이름이 다르면 다른 타입이다.&lt;/li>
&lt;li>Structural Typing 을 가지는 언어: Ocaml, Haskell, TypeScript, Go 등; 클래스의 모양이 같으면 같은 타입이다. 덕 타이핑 등의 용어가 이 사상에서 나온다.&lt;/li>
&lt;/ul>
&lt;p>각각의 장단점이 있고 혼용되기도 한다. 타입스크립트를 명명형 타입 시스템처럼 사용하기 위한 기법도 많이 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://michalzalecki.com/nominal-typing-in-typescript/">Nominal typing techniques in TypeScript&lt;/a> 를 참고하자.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 14
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
인터페이스는 객체를 특정하는 제약
&lt;/pre>
&lt;p>
타입 시스템에는 인터페이스가 항상 따라오는데 타입스크립트에서도 마찬가지다. 객체지향 프로그래밍에서 인터페이스는 클래스를 기술하는 명세라고 볼 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stock?&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">description?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ShopItem&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">stock?&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">description?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>구조적 타입 시스템에서 위 둘은 같은 모양을 가지고 있고 혼용이 가능하다.
클래스에 인터페이스를 구현하기 위해 아래와 같이 사용한다. 명세를 구현하는 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DVD&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> &lt;span style="color:#a6e22e">ShopItem&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">title&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9.99&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">vat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Book&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">title&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">39&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">vat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
인터페이스와 타입은 같은 목적으로 사용되는 듯 해 보인다. 타입스크립트 코딩을 오래할수록 타입을 사용하기 위해 인터페이스를 사용하게 될 것이라고 조언하고 있다. 그 첫 이유는 선언을 병합하여 사용할 수 있는 점 때문이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">global&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">isDevelopment&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Window 타입에 인터페이스를 추가하여 안전한 코드를 작성하는 예를 보여준다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (window.&lt;span style="color:#a6e22e">isDevelopment&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Another discount applied&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>점진적으로 자바스크립트를 확장해가며 빨간 줄을 만나지 않기 위한 노력을 하고 있다.&lt;/p>
&lt;ol>
&lt;li>타입스크립트 컴파일러는 자바스크립트로 변환하면서 타입 어노테이션을 잃어버린다.&lt;/li>
&lt;li>타입스크립트의 `any` 는 어느 타입에도 대응 가능한 고유한 원시 타입이다.&lt;/li>
&lt;li>이 `any` 는 타입스크립트의 점진적 타입 개선 과정에 도움이 된다.&lt;/li>
&lt;li>타입 가드 기법을 통해 타입을 추론이 동작하는 과정을 알아보았고 `typeof` 연산자는 타입 정보를 반환하는 기능도 가지고 있다.&lt;/li>
&lt;li>구조적 타입 시스템에 대해 살펴보았다.&lt;/li>
&lt;li>타입을 구성하는 다양한 방법을 알았다.&lt;/li>
&lt;li>객체지향 프로그래밍의 클래스는 값으로도 동작하고 타입으로도 동작하는 것을 알았다.&lt;/li>
&lt;li>인터페이스를 통해 타입 선언을 병합하는 방법이 있음을 알았다.&lt;/li>
&lt;/ol>
&lt;p>타입스크립트는 자바스크립트에 영향을 주고 있다.&lt;/p>
&lt;ol>
&lt;li>접근 제어자가 있다. (최근 자바스크립트에 도입되었다.)&lt;/li>
&lt;li>추상 클래스 개념이 있다.&lt;/li>
&lt;li>열거형을 선언할 수 있다.&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 1</title><link>https://faultnote.github.io/posts/typescript-50-lessons-1/</link><pubDate>Fri, 21 Jan 2022 20:47:53 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-1/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. https://typescript-book.com/ 다루고 있는 주제는 아래와 같다</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://typescript-book.com/">https://typescript-book.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>다루고 있는 주제는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>타입스크립트의 컨셉과 이해하기&lt;/li>
&lt;li>타입스크립트 툴 사용법과 효과적인 사용법&lt;/li>
&lt;li>뭔가 새로 배우지 않고 타입스크립트를 사용하는 법&lt;/li>
&lt;li>구조적 타입 시스템과 시멘틱 그리고 이게 왜 중요한지 이해하기&lt;/li>
&lt;li>유지 관리가 적은 타입을 만들고 재사용하는 법과 점진적으로 개선시키는 법&lt;/li>
&lt;li>프로젝트에 적합한 타입 시스템을 적용하는 법&lt;/li>
&lt;li>타입스크립트 커뮤니티와 언어가 개선되는 과정&lt;/li>
&lt;/ul>
&lt;p>기술적으로 다루는 내용은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>빨간 줄을 지워가는 과정&lt;/li>
&lt;li>타입을 다루는 방법&lt;/li>
&lt;li>함수와 함수 타입&lt;/li>
&lt;li>유니언 타입과 인터섹트 타입&lt;/li>
&lt;li>제너릭 (타입ed 클래스, 타입 파라미터)&lt;/li>
&lt;li>컨디셔널 타입&lt;/li>
&lt;li>프로그래밍과 타입에 대한 고민&lt;/li>
&lt;/ul>
&lt;p>홈페이지에서 예제 코드를 함께 제공하고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 1
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
빨간 줄을 활성화 하기
&lt;/pre>
&lt;p>
VSCode 기준으로 강의를 진행하고 있고 빨간 줄을 줄이자! 를 목표로 안전한 코딩을 하기 위해 타입스크립트가 어떤 도움을 주고 있는지 안내하고 있다.&lt;/p>
&lt;p>
코딩 과정에서 타입이 제공되면서 함수를 호출하고 인자를 처리하는데 단순한 오탈자 뿐 아니라 코드를 이해하고 적용하는 방법도 소개하고 있다.&lt;/p>
&lt;p>
&amp;#39;//@ts-check&amp;#39; 를 통해서 기존 자바스크립트에서 개선하는 노하우도 알려주고 있다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//@ts-check
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">max&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">items&lt;/span>&lt;span style="color:#f92672">:&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Object.&lt;span style="color:#a6e22e">defineProperty&lt;/span>(&lt;span style="color:#a6e22e">storage&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;max&amp;#39;&lt;/span>, { &lt;span style="color:#a6e22e">readonly&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">5000&lt;/span> })&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 2
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
타입 추론 기능으로 버그를 찾자
&lt;/pre>
&lt;p>
찾을 수 없는 프로퍼티를 사용해 발생하는 버그를 소개로 챕터를 시작한다.
이건 매뉴얼 보면서 코드를 작성하면 나오지 않을 문제긴 하지만 보통 실행 과정에서 예외가 발생하는 경우로 버그를 발견하고 해결하기 시작한다.&lt;/p>
&lt;p>
왜 빨간 줄이 그어지는지에 대한 내용으로 타입 추론에 대해 소개하고 있다. 약(Weak) 타입 언어 환경에서 식별자에 대한 타입을 추론하고 코딩 과정에서 해당 식별자의 타입을 제안하여 안전한 코드를 만들어가는 과정을 제안한다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">storageUsed&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">currentStorage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
문법을 통해 식별자의 타입을 추론하는 기술도 가지고 있으니 VSCode 같은 자동 완성 기능을 포함한 환경을 제공하는 편집기를 사용하자.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">items&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">weigth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 3
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
구조적 타입 시스템을 제공하는 타입스크립트
&lt;/pre>
&lt;p>
타입은 무엇인가?&lt;/p>
&lt;blockquote>
&lt;p>A type is a classification of data that defines the operations that can be done on that data, the meaning of the data, and the set of allowed values Typing is checked by the compiler and/or run time to ensure the integrity of the data, enforce access restrictions, and interpret the data as meant by the developer&lt;/p>
&lt;ul>
&lt;li>Programming with Types, Vlad Riscutia&lt;/li>
&lt;/ul>
&lt;p>타입은;
해당 데이터에 대해 수행할 수 있는 작업을 구분하고,
데이터 스스로 의미를 규정하고,
컴파일러나 인터프리터가 오류없이 다룰 수 있는 값들에 대한 범위를 제한하며,
접근 제어를 강제하고,
개발자에게 데이터가 뭘 의미하는지 알려 준다.&lt;/p>
&lt;/blockquote>
&lt;p>
내 경우, 로우레벨로 보면 타입은 이 자료가 메모리를 얼마나 차지하고 있느냐, 라고 소개하고 뭉개 버린다.&lt;/p>
&lt;p>
타입은 프로그래밍에 필수 요소다. 아닌 것 같지만 자바스크립트도 타입이 있다.
number, string, boolean 이 대표적인 프리미티브 타입이다. object, array, function 등이 컴포지트 타입에 속한다.&lt;/p>
&lt;p>
자바스트립트는 타입이 있지만 동적 타입 언어에 속한다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1234&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Onetwothreefour&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>정의된 식별자에 다른 타입의 값을 지정해도 잘 동작하고 심지어 다른 타입끼리 연산도 허용되기도 한다. 😬&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> } &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
강타입이 주는 이점은 여러가지가 있다. 타입스크립트는 자바스크립트를 강타입 언어로 한 번 더 포장해 준다.&lt;/p>
&lt;p>
그리고 Shape 이란 용어가 소개되는데 타입스크립트의 구조적structural 타입 시스템을 설명하기 위해 사용된 것으로 보면 된다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">person&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">firstName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lastName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Baumgartner&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">age&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">38&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 코드는&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">firstName&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lastName&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">age&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이런 모양shape으로 표현된다.&lt;/p>
&lt;p>
이 모양에 대한 설명은 구조적 타입 시스템으로 계속 반복된다. (이에 상대되는 개념으로 nominal type system 이 있습니다.)&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 4
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
바닐라 자바스크립트에 JSDoc 을 적용하여 타입 추론을 맛보기
&lt;/pre>
&lt;p>
점진적으로 자바스크립트 코드를 개선하는 방법으로 JSDoc 을 추가하여 사용하는 것을 권하고 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jsdoc.app/">https://jsdoc.app/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>타입 정보가 없는 자바스크립트 코드에 JSDoc 을 추가하여 타입 정보를 참조할 수 있게 해주고 이는 더 안전한 코드를 만들기 위한 기초로 사용된다.&lt;/p>
&lt;pre class="example">
/**
* @typedef {Object} ShipStorage
* @property {number} max
* @property {StorageItem[]} items
*/
&lt;/pre>
&lt;div class="src src-javascript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/** @type ShipStorage */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">max&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">items&lt;/span>&lt;span style="color:#f92672">:&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">items&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">weigth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
커스텀 타입을 사용하여 타입 추론 기능을 사용할 수 있다면 더 안전한 코드를 작성할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 5
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
타입 선언 파일으로 타입을 재사용하기
&lt;/pre>
&lt;p>
타입스크립트는 자바스크립트의 수퍼셋으로 불리는데 이는 타입스크립트가 자바스크립트의 모든 것을 포함하고 있고 자바스크립트 보다 더 많은 부분을 가지고 있다는 뜻이다.
자바스크립트 코드는 타입스크립트 코드로 동작할 수 있지만 반대는 성립하지 못한다.
그래서 타입스크립트 코드를 브라우저나 노드JS 환경에서 직접 동작시킬 수 없다.&lt;/p>
&lt;p>
자바스크립트와 다른 첫번째 특징은 &amp;#39;.d.ts&amp;#39; 파일로 불리는 타입 선언 시스템이다.
선언된 타입들은 export 키워드로 선언하면 다른 파일에서 참조할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">StorageItem&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">weight&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ShipStorage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">max&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">items&lt;/span>: &lt;span style="color:#66d9ef">StorageItem&lt;/span>[]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 선언된 파일을 자바스크립트에서 사용하기 위해 &amp;#39;@ts-check&amp;#39; 아래에 이어&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/** @typedef { import(&amp;#39;./types.d&amp;#39;).ShipStorage } ShipStorage */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/** @typedef { import(&amp;#39;./types.d&amp;#39;).StorageItem } StorageItem */&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>선언하여 타입 시스템을 활성화 시킬 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 6
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
엠비언트 타입 정의 파일
&lt;/pre>
&lt;p>
타입 선언을 별도의 파일로 관리하고 재사용 할 수 있다면 더 나은 코딩 환경을 구성할 수 있다. 소스 코드를 수정하지 않고 전역으로 사용할 수 있는 타입을 선언하여 디버깅 환경을 활성화 시키는 기법도 있다.&lt;/p>
&lt;p>
jQuery 같은 라이브러리는 타입스크립트로 개발된 코드가 아니기에 별도의 타입 선언이 담긴 파일을 제공하지 않는다. 대신 앰비언트 타입 정의 파일을 추가하여 타입스크립트 개발 환경에 적용하자.&lt;/p>
&lt;div class="src src-shell">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>npm i @types/jquery&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 7
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
타입스크립트의 도구들
&lt;/pre>
&lt;p>
NodeJS 패키지 매니저를 통해 타입스크립트 컴파일러를 설치하여 사용할 수 있다.&lt;/p>
&lt;div class="src src-shell">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>npm i -g typescript&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
&amp;#39;tsconfig.json&amp;#39; 파일은 타입스크립트 컴파일러의 컴파일 환경을 정의하고 있다.&lt;/p>
&lt;ol>
&lt;li>target: 컴파일러의 빌드 타겟.&lt;/li>
&lt;li>module: 빌드 파일의 모듈 시스템. commonjs 와 es2020 이 지원된다.&lt;/li>
&lt;li>esModuleInterop: 모듈 시스템과 결부되어 더 깊은 호환성을 제공한다.&lt;/li>
&lt;li>allowJs: .ts 파일이 아닌 .js 파일을 참조할 수 있게 허용한다.&lt;/li>
&lt;li>checkJs: 일반 자바스크립트 파일에도 타입 체크를 적용한다.&lt;/li>
&lt;li>typeRoots: 타입 정의 파일의 위치를 지정한다.&lt;/li>
&lt;/ol>
&lt;p>tsc 의 `–noEmit` 옵션과 `–watch` 옵션도 소개하고 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-9" class="outline-3">
&lt;h3 id="headline-9">
Lesson 8
&lt;/h3>
&lt;div id="outline-text-headline-9" class="outline-text-3">
&lt;pre class="example">
타입스크립트로 컴파일하기
&lt;/pre>
&lt;p>
타입스크립트는 브라우저에서 바로 실행되지 않기 때문에 컴파일을 하여 자바스크립트로 변환해야 한다. 자바스크립트 파일의 확장자를 `.ts` 로 바꿏는 것만으로도 타입스크립트 파일로 변경된다.
`tsconfig.json` 파일을 생성하고 컴파일러 옵션을 정의하자.&lt;/p>
&lt;div class="src src-json">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;compilerOptions&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;target&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ES2020&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;module&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;es2020&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;typeRoots&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;@types&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;node_modules/@types&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;esModuleInterop&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
타입스크립트는 코드에 어노테이션을 추가하여 타입을 정의한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">addVAT&lt;/span>(&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>, &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">numer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">vat&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">boom&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">addVAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this is not a number!&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>Doom Emacs 익숙해지기</title><link>https://faultnote.github.io/posts/doom-emacs-guide-1/</link><pubDate>Sat, 15 Jan 2022 21:38:05 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/doom-emacs-guide-1/</guid><description>xkcd 의 설명을 심각하게 받지 말기 😁 글쓰기와 이맥스 나는 NodeJS 로 백엔드 개발을 하는데 Jetbrains 의 Webstorm 을 사용하고 있다. 예전 Phpstorm 시절부터 고려하면 10년 가까이 젯브레인즈의 제품</description><content>&lt;blockquote>
&lt;p>&lt;a href="https://xkcd.com/378/" title="Explain xkcd: It's 'cause you're dumb.">xkcd&lt;/a> 의 &lt;a href="https://www.explainxkcd.com/wiki/index.php/378:_Real_Programmers" title="The fact that Emacs already has a command for this simply exacerbates the other programmers' frustration with modern coding tools.">설명&lt;/a>을 심각하게 받지 말기 😁&lt;/p>
&lt;/blockquote>
&lt;h2 id="글쓰기와-이맥스">글쓰기와 이맥스&lt;/h2>
&lt;p>나는 NodeJS 로 백엔드 개발을 하는데 Jetbrains 의 Webstorm 을 사용하고 있다.
예전 Phpstorm 시절부터 고려하면 10년 가까이 젯브레인즈의 제품을 사용하고 있는 것이다.
2010년 경에 사용하던 Eclipse 기반의 단축키 일부를 차용하고 몇 년간 손에 맞게 수정한 버전의 단축키 세트를 사용하다 2019년부터 ideavim 을 통해 Vim Model 편집 기반의 조합으로 일부 수정하여 지금까지 사용 중이다.&lt;/p>
&lt;p>코드 작성은 그렇다 하더라도 글을 쓰거나 메모를 남기는 경우에 Webstorm 을 사용하기는 곤란하고 - 특정 시기와 조건에서 한글 입력에 자유롭지 못한 경우가 있었다. 요즘은 큰 문제가 없지만 메모 남기려고 IDE 를 올리는 건 이상하지만, Emacs 라면&amp;hellip; 가능할지도 모르겠다. - 주로 서브라임 텍스트를 활용해 메모를 남기거나 할 일 목록을 적어두는 도구로 사용했다.&lt;/p>
&lt;p>회사 업무를 위한 할일 관리는 주로 웹 브라우저 기반의 서비스(SaaS)를 사용하고 있는데 긴 글을 편집할 때나 마우스로 조작이 필요한 경우가 많아 즐겁지가 않다.&lt;/p>
&lt;p>모달 에디팅에 집착하기 전에는 Markdown 편집이 가능한 도구로 글쓰기를 해왔지만 해피해킹 배열로 키보드를 변경한 후에는 이 마저도 꺼려지게 되었다. 결국 VSCode, Sublime Text 와 그 외 Apple Reminder 나 MS To-do 같은 툴을 통해 글쓰기와 메모/할일 관리 등을 수행하였다.&lt;/p>
&lt;p>요즘 프로그래머들은 Editor War 겪지 않지만 예전에는 이런 취향을 두고 주기적으로 &amp;#x1f607; 논의를 하는게 재미있는 일이었다.
요즘 웹 개발자들이 이맥스를 경험하는 건 흔치 않지만 나는 운이 좋아 Evil 모드가 있는 &lt;a href="https://www.spacemacs.org/" title="The best editor is neither Emacs nor Vim, it's Emacs and Vim!">Spacemacs&lt;/a> 사용했고, 어떻게 기억하고 있는지 모르지만 바닐라 이맥스를 종료하는 방법도 알고 있었다.&lt;/p>
&lt;p>2021년부터는 Doom Emacs 를 사용하기 위한 시간을 만들어 보고 있다. 국내에는 이맥스 사용자가 얼마나 계신지 모르겠지만 이 편집기(그 이상이지만)에 대한 글도 많지 않다. 그나마 &lt;a href="https://seorenn.github.io/note/doom-emacs.html">seorenn 님의 Emacs 포스트&lt;/a>가 많이 정리되어 있다.&lt;/p>
&lt;h3 id="투두-노트-저널-그리고-작업-모드org-mode">투두, 노트, 저널 그리고 작업 모드(org mode)&lt;/h3>
&lt;p>내 경우, 글을 쓴다는 것에는 복합적인 요소가 포함되어 있다. 생각의 나열일 수 있고 구조화된 맥락인 경우도 있고, 단순히 오늘 벌어진 일이나 앞으로 하고 싶은 일들의 기록일 수도 있다. 그런 면에서 글쓰기를 일반 텍스트 에디터나 워드프로세서에서만 하는 것은 부족했다.
특히 워드프로세서로 글을 쓰는 건 엄청난 고통이다. 한때는 &amp;lsquo;아래아한글&amp;rsquo; 같은 워드 프로세싱 애플리케이션으로 책을 만들어 본 적도 있지만 다시 책을 쓴다면 저작 도구와 편집 도구를 분리하여 사용할 것이다.&lt;/p>
&lt;p>그러고 보니 몇 년 전 학교에서 사용한 책은 VSCode 의 마크다운 모드로 저작을 하고 애플 Pages 로 마무리를 했었다.&lt;/p>
&lt;blockquote>
&lt;p>나의 글쓰기는 책을 편집하는 것이 아니니 텍스트 에디터로도 충분하다. 단, 적당한 에디터가 필요하다.&lt;/p>
&lt;/blockquote>
&lt;p>현 시점에서 이맥스 환경은 이런 요구를 만족시켜주는 최고의 환경이 되고 있다.&lt;/p>
&lt;h4 id="작업-모드">작업 모드&lt;/h4>
&lt;p>이맥스의 &amp;lsquo;오그모드&amp;rsquo; 라고 불리는 작업 모드&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>는 특정 폴더를 대상으로 그 안에 있는 org 파일들에 대해 주어진 조건에 맞는 텍스트를 작업 모드의 대상으로 만들어 준다. 그리고 날짜/시간을 추가하고 트래킹 할 수 있는 기능이 포함되어 있어 일정 관리 도구로도 손색이 없는 수준으로 발전되어 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=hnMntOQjs7Q">Emacs Org Mode Demo 2021&lt;/a>&lt;/li>
&lt;/ul>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/hnMntOQjs7Q" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>이 5분이 안되는 영상을 보면 &amp;lsquo;Org Mode&amp;rsquo; 의 매력을 느낄 수 있을 것이다.&lt;/p>
&lt;h4 id="투두">투두&lt;/h4>
&lt;p>일반적인 &lt;code>[x]&lt;/code> 같은 표시부터 명시적으로 &lt;code>TODO&lt;/code> 등의 내용으로 할일 목록을 구성할 수 있다. 아래 소개할 &lt;code>org-deirectory&lt;/code> 에 있는 투두 목록이 들어간 파일은 별도의 투두 리스트로 추려질 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>SPC n t&lt;/code>: &lt;code>org-todo-list&lt;/code> 명령으로 할 일이 담긴 버퍼를 연다.&lt;/li>
&lt;/ul>
&lt;p>처음 시작한다면 &lt;code>SPC n n t&lt;/code> 를 통해 기본 todo 파일을 생성하고 시작해 볼수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">**&lt;/span> PROJ 프로젝트 이름
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">***&lt;/span> HOLD OOOO 북마크 대응 API 검수
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DEADLINE: &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">2022&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">21&lt;/span> Fri&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">***&lt;/span> STRT XXXX 시청 기록 API 대응
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DEADLINE: &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">2022&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">07&lt;/span> Fri&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">***&lt;/span> DONE MMMM 처리 스크립트 보완
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DEADLINE: &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">2022&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">05&lt;/span> Wed&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>: 추가 설명&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>뭐 이런 내용을 작성하면 에디터에서는 이렇게 보인다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/org_mode-todo-lookslike-1.png" alt="org mode - todo list" title="나쁘지 않다.">&lt;/p>
&lt;p>작업 모드(org mode)에서 기본 구성으로 제공되는 &lt;code>todo.org&lt;/code> 파일만 관리해도 적당히 쓸만한 할 일 관리를 수행할 수 있다.&lt;/p>
&lt;p>&lt;code>SPC n t&lt;/code> 로 즉시 전체 할 일 목록 버퍼를 띄울 수 있다. 할 일들은 꼭 &lt;code>todo.org&lt;/code> 파일 안에 있지 않아도 된다. 작업 모드의 지정된 폴더 안에 있는 org 파일은 모두 대상이 되고 각 아이템에서 기록이 있는 파일로 즉시 이동이 가능하다.&lt;/p>
&lt;p>투두 항목은 단축키로 상태와 중요도를 변경할 수 있고 위/아래로 위치를 이동시킬 수 있다. 따로 잘라내고 붙이는 작업을 하지 않아도 순서를 관리할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>M-j/k&lt;/code>: &lt;code>move subtree up/down&lt;/code> 으로 동작시킬 수 있다. &lt;code>M&lt;/code> 으로 표기되는 Meta 키는 &lt;code>Ctrl&lt;/code> 키와 함께 이맥스에서 사용되는 조합키로 맥OS 에서는 &lt;code>Opt&lt;/code> 키가 그 역할을 한다.&lt;/li>
&lt;/ul>
&lt;p>이맥스의 단축키 시스템은, 아직 그 깊은 곳까지 가지 못했지만 방대하고 유연해서 Vim/Neovim 에서 조합할 수 없었던 기능키를 쉽게 적용할 수 있다.&lt;/p>
&lt;p>좋은 단축키 환경을 구성하는 것은 코더로서도 중요하고 문서 생산성 향상에 매우 중요한 역할을 한다고 믿고 주장하는 입장이어서 Evil-mode Emacs 는 네이티브 Vim 환경보다 훌륭하다.&lt;/p>
&lt;h4 id="노트">노트&lt;/h4>
&lt;p>그동안 서브라임 텍스트로 빠르게 메모하던 내용들을 이맥스의 작업 모드 &lt;code>notes.org&lt;/code> 로 이관해 사용하고 있다.&lt;/p>
&lt;p>이맥스 작업 모드의 노트 생성은 캡처 기능과 함께 기본 템플릿을 구성하고 있어 노트를 생성한 날짜를 따로 입력하지 않아도 편리한 부분이 있다. (이맥스에서는 현재 날짜/시각을 입력하는 별도의 툴이 있기도 하다.)&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/org_mode-calendar-timestamp-1.png" alt="org mode calendar" title="타임스템프는 두 종류가 있다.">&lt;/p>
&lt;p>예전에 하루패드 사용할 때에도 입력 즉시 현재 날짜와 시각을 생성하는 기능이 매우 유용했는데 이맥스에서 그 기분을 다시 맛보니 글쓰기가 더 재밌어진다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>C-c .&lt;/code>: &lt;code>org mode&lt;/code> 환경 안에서 현재 위치에 날짜를 추가한다.&lt;/li>
&lt;li>&lt;code>Shift+H/L&lt;/code>: &lt;code>org mode&lt;/code> 환경의 날짜 텍스트 위에서 이전/다음 일로 변경한다.&lt;/li>
&lt;/ul>
&lt;p>나의 노트에는 짧은 메모들을 담고 있다. 직접 파일을 열고 편집하기 보다 다른 상황 다른 맥락에서 급히 메모 남길 때 사용한다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/org_mode-first-note.png" alt="org mode my first notes" title="부정확한 정보가 있을 수 있다.">&lt;/p>
&lt;ul>
&lt;li>&lt;code>SPC n n n&lt;/code> 또는 &lt;code>SPC X&lt;/code>: 글로벌 하게 동작하는 키로 현재 컨텍스트를 기반으로 노트를 생성한다.&lt;/li>
&lt;li>&lt;code>SPC n S&lt;/code>: 작업 모드로 지정된 폴더의 모든 문서를 검토해 노트의 헤더로 이동할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4 id="저널">저널&lt;/h4>
&lt;p>저널은 작업 모드에서 제공하는 기본 템플릿 중 가장 맘에 드는 구성이다. 우선 저널 생성을 위해 아무 내용이나 캡처하여 새 파일을 생성하자.&lt;/p>
&lt;ul>
&lt;li>&lt;code>SPC n n j&lt;/code>: 저널 파일이 없으면 새로 만들 수 있고 있으면 현재 컨텍스트를 참조하는 새 항목을 생성한다.&lt;/li>
&lt;/ul>
&lt;p>생성되는 헤더에는 현재 일자와 시각 정보가 있다. 나는 이걸 개인 일기로 사용하고 있다. 이 안에서는 할 일도 함께 정의 할 수 있다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/org_mode-first-journal.png" alt="org mode first journal" title="가끔은 남 얘기도 쓴다.">&lt;/p>
&lt;p>저널을 통해 자유롭게 글을 쓰고 할 일을 만들고 이들을 정리할 수 있다는 것을 알게 된 후부터 본격적으로 이맥스로 글쓰기를 해보려고 시도하고 있다.&lt;/p>
&lt;h2 id="인박스-구성">인박스 구성&lt;/h2>
&lt;h3 id="업무-일지의-예">업무 일지의 예&lt;/h3>
&lt;p>회사 생활 하면서 매일 매일 일지를 기록하고 있다. 처음에는 마크다운 에디터에서 기록을 시작했고 편집 환경을 Vim 같은 모달 에디팅 환경으로 개선하면서 업무 일지도 Vim 으로 편집했다. 쉘 환경에서 &lt;code>alias&lt;/code> 를 구성하고 구글 드라이브의 특정 파일을 편집하는 명령으로 즉시 즉시 Vim 에서 일지의 내용을 편집했다.&lt;/p>
&lt;p>구글 드라이브로 문서를 동기화하고 있었는데 &lt;code>md&lt;/code> 파일을 프리뷰하는 과정이 필요해 아예 지난 해는 구글 닥스의 문서를 직접 편집했다. 그러다 모달 에디팅 환경이 아닌게 너무 불편해 크롬 익스텐션을 일부 수정해 모달 에디팅 환경을 구성해 사용하기도 했다. 그래도 키보드 만으로 웹 브라우저에서 글을 쓰는 것은 쉽지 않았다.&lt;/p>
&lt;p>올해는 이맥스를 통해 업무 일지를 쓰고 있다. 아이클라우드 동기화를 켜고 인박스에 올해 업무일지 파일(.org)을 만들고 이 문서를 편집한다.&lt;/p>
&lt;p>일정 기반의 할 일 등 아젠다를 작성하여 관리하고 있는데 효율이 좋다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/org_mode-work-log-journal.png" alt="업무일지2022" title="오그모드 너무 좋아.">&lt;/p>
&lt;h3 id="저장-위치">저장 위치&lt;/h3>
&lt;p>하나의 장비(PC)로 글을 쓰는 환경이 아니라면 기기 간 동기화가 가능한 솔루션을 통해 진행하는 것이 좋다.&lt;/p>
&lt;p>애플의 iCloud 드라이브나 아이클라우드를 통해 지원하는 데스크탑/도큐멘트 폴더 동기화 기능이나 구글 드라이브, 드랍박스 등의 동기화가 가능한 대상을 인박스로 구성하는 것을 추천한다.&lt;/p>
&lt;p>내 경우, 데스크탑에 Inbox 폴더를 두었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ~/.doom.d/config.el &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; If you use &lt;span style="color:#e6db74">`&lt;/span>org&lt;span style="color:#e6db74">`&lt;/span> and don&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>t want your org files in the default location below,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; change &lt;span style="color:#e6db74">`&lt;/span>org-directory&lt;span style="color:#e6db74">`&lt;/span>. It must be set before org loads!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>setq org-directory &lt;span style="color:#e6db74">&amp;#34;~/Desktop/Inbox&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>자주 보는 곳에 두고 자주 사용할 수 있도록 했다.&lt;/p>
&lt;h3 id="자동-저장">자동 저장&lt;/h3>
&lt;p>Doom Emacs 에 아쉬운 점이 하나 있는데 자동 저장 기능이 디폴트가 아니라는 점이다.
Webstorm 이나 VSCode 를 사용할 때는 항상 자동 저장을 켜고 사용했고 다른 사람에게 안내할 때는 반드시 이 옵션부터 활성화 하라고 지시하기도 했다.&lt;/p>
&lt;p>물론 적당한 확장 코드를 통해서 이 기능을 추가할 수 있는데 그냥 써보기로 했다. Vim 과 다르게 &lt;code>CMD+S&lt;/code> 를 통해 저장이 가능하니 아주 힘든 것은 아니다.
수정된 버퍼가 남아 있는 동안 이맥스를 종료할 경우에 한 번 씩 더 물어보니 습관을 바꿔보는 것도 괜찮겠다.&lt;/p>
&lt;h2 id="둠-이맥스의-미래">둠 이맥스의 미래&lt;/h2>
&lt;p>&lt;a href="https://github.com/hlissner">Henrik Lissner&lt;/a> 가 시작한 이 프로젝트는 조만간 GitHub 의 doomemacs organization 으로 이관될 듯 하다. 그 밑 작업들이 계속 진행되고 있으며 Spacemacs 만큼 중요한 프로젝트가 될 것 같다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/doom-emacs-org-account.png" alt="DoomEmacs Organization in GitHub">&lt;/p>
&lt;p>둠 이맥스가 계획하고 있는 로드맵을 보면 이 에디터 환경에 배팅해도 좋을 듯 하다.&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>org mode - 이맥스에서 특정 확장을 위한 구성을 mode 라고 부르고 작업 관리를 위한 가장 유명한 도구로 org mode 가 있다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content></item><item><title>2022년에 Doom Emacs 시작하기</title><link>https://faultnote.github.io/posts/doom-emacs-intro/</link><pubDate>Sat, 01 Jan 2022 14:10:21 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/doom-emacs-intro/</guid><description>이맥스는 뭐냐? 오리지널 Vi 보다는 늦지만 Vim 보다 조금 먼저 개발된 텍스트 편집기로 오래되었고, 요즘은 VSCode 가 승리했지만 Emacs vs Vim 성전(聖戰, a holy war)의 핫한 주</description><content>&lt;h2 id="이맥스는-뭐냐">이맥스는 뭐냐?&lt;/h2>
&lt;p>오리지널 Vi 보다는 늦지만 Vim 보다 조금 먼저 개발된 텍스트 편집기로 오래되었고, 요즘은 VSCode 가 승리했지만 Emacs vs Vim 성전(聖戰, a holy war)의 핫한 주인공이었다. (지금 저 &lt;code>vs&lt;/code> 는 VSCode 가 되었고 코딩용 편집기의 de facto 가 되었다.)&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=3r1z5NDXU3s">I do use Vim other Emacs&lt;/a> 커버에 있는 이미지의 클립에서도 볼 수 있듯 연애 보다 중요한 문제다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="vi-와-vim">Vi 와 Vim&lt;/h3>
&lt;p>Vim 은 Vi Improved, 즉, Vi 의 개선판으로 퍼블릭 버전은 1991년에 등장했다.&lt;/p>
&lt;p>오리지널 vi 는 &lt;a href="https://en.wikipedia.org/wiki/Bill_Joy">빌 조이&lt;/a>가 만들었고 대부분의 UNIX 시스템의 에디터로 채용되었다. 이후 &lt;a href="https://en.wikipedia.org/wiki/Bram_Moolenaar">브람 뮬러너&lt;/a>가 Vi Imitation 으로 시작해 Vim 은 지금까지 가장 유명한 에디터 중 하나로 추앙 받고 있다.&lt;/p>
&lt;blockquote>
&lt;p>Vi 와 Vim 에 대한 조금 더 자세한 얘기는 다른 포스트에서 다뤄보기로 하자.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://jovicailic.org/2014/06/the-history-of-vim/">The History of Vim&lt;/a> 문서에 따르면 이런 히스토리를 가지고 있다.&lt;/p>
&lt;ul>
&lt;li>1988 Vim 1.0 Vi IMitation on the Amiga&lt;/li>
&lt;li>1991 Vim 1.14 First public release (on Fred Fish disk #591)&lt;/li>
&lt;li>1992 Vim 1.22 Port to Unix, renamed to Vi IMproved&lt;/li>
&lt;li>1994 Vim 3.0 Multiple windows&lt;/li>
&lt;li>1996 Vim 4.0 GUI&lt;/li>
&lt;li>1998 Vim 5.0 Syntax highlighting&lt;/li>
&lt;li>2001 Vim 6.0 Folding, multi-language&lt;/li>
&lt;li>2006 Vim 7.0 On the fly spell checker, support for tabs&lt;/li>
&lt;li>2017 — Mastering Vim Quickly book published.&lt;/li>
&lt;/ul>
&lt;p>현재는 8.x 버전이 사용되고 있고 Vim 의 모던 버전인 &lt;a href="https://neovim.io">Neovim&lt;/a> 과 포스트 모던 버전인 &lt;a href="https://helix-editor.com">Helix&lt;/a> 에디터가 떠오르고 있다.&lt;/p>
&lt;h3 id="emacs">Emacs&lt;/h3>
&lt;p>이맥스는 GNU 의 역사와 괘를 같이 한다. GNU 최초의 프로젝트로 알려져 있기도 하다.&lt;/p>
&lt;blockquote>
&lt;p>에디터와 컴파일러, 디버거 개발로 시작된 상용 UNIX 시스템을 대체하는 GNU 프로젝트는 커널 개발이 늦어져 그 자리를 Linux 로 채우게 되었다. 오리지널 GNU 명맥을 유지하는 커널은 &lt;a href="https://www.gnu.org/software/hurd/">GNU/Hurd&lt;/a> 로 계속되고 있다.&lt;/p>
&lt;/blockquote>
&lt;p>GNU 프로젝트의 구루인 RMS - &lt;a href="https://en.wikipedia.org/wiki/Richard_Stallman" title="GNU 의 창시자">리처드 스톨만&lt;/a>이 lisp 프로그래밍 언어로 개발했다. Java 를 개발한 &lt;a href="https://en.wikipedia.org/wiki/Gosling_Emacs" title="자바의 아버지">제임스 고슬링&lt;/a>도 이 에디터의 상용 버전을 개발했던 기록이 있다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=wA7aB-oxjVc">Writing an Emacs implementation in C (Gosling Emacs)&lt;/a> 이 영상 재밌다. Latax 보다 worse 한 이맥스의 전신에 대한 얘기도 나온다.&lt;/p>
&lt;/blockquote>
&lt;p>X-윈도우 시스템을 위한 이맥스가 개발되었고 Vi/Vim 와 다르게 자체 GUI 애플리케이션으로 배포되기도 한다. 스크립트를 통한 확장이 용이하여 다양한 기능이 추가되었고 수많은 해커들의 사랑을 받아 이맥스 안에서 모든 것을 해결할 수 있을 수준의 환경을 구성할 수 있다. 반면, 속도의 향상을 위해 C 네이티브로 구성된 부분이 있지만 elisp (Emacs Lisp) 인터프리터 위에서 수행되는 관계로 상대적으로 무겁다.&lt;/p>
&lt;p>긴 역사를 넘어 그 보다 더 많은 개발자들의 공헌으로 다양한 응용프로그램을 구동할 수 있는 환경을 갖추게 되었고 현대의 IDE 에 버금가는 기능과 그 이상의 시스템으로 발전해왔다.&lt;/p>
&lt;p>이맥스의 단축키는 다양한 시스템에 영향을 주게 되었고 대부분의 쉘에서 이 단축키 일부를 지원하고 있다.&lt;/p>
&lt;p>본격적인 문서는 &lt;a href="https://www.emacswiki.org/emacs?interface=ko" title="이맥스 위키">EmacsWiki 한글&lt;/a> 사이트를 참고하자.&lt;/p>
&lt;h4 id="evil-모드">Evil 모드&lt;/h4>
&lt;p>이맥스의 단축키는 CTRL 키와 META 키 - 윈도우즈의 ALT 나 맥OS 의 Option 키 - 그리고 SUPER 키를 지원하고 이를 응용할 수 있다. 두 단계 이상으로 키 조합을 구성할 수 있어 왠만한 기능은 키보드로 처리가 가능하다.&lt;/p>
&lt;p>하지만 모달 에디팅 환경을 제공하는 Vim 과 다르게 기본적으로 일반적인 에디터가 제공하는 인라인 편집 모드를 제공하고 있다.&lt;/p>
&lt;blockquote>
&lt;p>모달 에디팅에 대해서는 다음에 심각하게 다뤄보도록 하겠습니다.&lt;/p>
&lt;/blockquote>
&lt;p>모달 에디팅의 장점은 다음에 알아보도록 하고 현재, Vim 에 익숙한 사용자들은 이맥의 기본 편집 모드를 바로 사용하는게 불편했다.&lt;/p>
&lt;p>이런 문제는 이맥스의 다양한 확장 기능 중 Evil 모드 시스템을 통해 Vim 과 동일한 모달 에디팅 환경을 제공 받는다.&lt;/p>
&lt;p>Vim 과 같은 모달 에디팅 환경이 제공되는 Emacs 는 Vim 을 넘어서는 텍스트 편집 환경을 제공하는 장점이 있어 Vim 사용자들을 Emacs 사용자로 만드는 중요한 역할을 했다.&lt;/p>
&lt;h2 id="이맥스에-대한-개인-취향">이맥스에 대한 개인 취향&lt;/h2>
&lt;p>나의 이맥스 사용은 주로 적당한 분량의 문서 작성에 사용하고 있다.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>밥벌이 코딩은 &lt;code>Jetbrains IDE&lt;/code> 에서 하고 짧은 메모나 임시 코드 작성 보관은 아무 에디터에서 진행하고 있는데 대표적으로 &lt;code>Sublime Text&lt;/code> 에서 수행한다. 특히 포매팅 작업이 필요한 코드를 잠시 보관할 때는 이만한 도구가 없다.&lt;/p>
&lt;ol>
&lt;li>매우 빠르고&lt;/li>
&lt;li>스크래치 파일을 잘 관리해주고&lt;/li>
&lt;li>하지만, 빈티지 모드가 영 시원찮고&lt;/li>
&lt;li>구름입력기의 &lt;code>Esc&lt;/code> 키로 로마자 전환 기능을 사용하는데 자동 영문 전환이 매끄럽지 않다.&lt;/li>
&lt;/ol>
&lt;p>어쨋든 긴 글은 이맥스에서 작성하려고 시도하고 있고 - 물론 쌩짜 이맥스를 사용하진 않는다 - 스페이스맥스에서 둠 이맥스까지 오게 되었는데 이 오래된 툴은 확실히 묘한 매력이 있다.&lt;/p>
&lt;p>결국 중요한 것은 적당히 굼뜨지 않고 글쓰기를 위한 물리적 감성적 공간을 충분히 제공해주며&lt;/p>
&lt;ol>
&lt;li>한글 입력에 문제가 없어야 하고&lt;/li>
&lt;li>입력 모드에서 일반 모드로 전환시 로마자 입력 상태로 전환이 잘 되어야 하며&lt;/li>
&lt;li>마크다운 편집이나 스니핏 코드 하이라이트 정도는 되면 좋고&lt;/li>
&lt;li>화살표 키가 없는 키보드를 사용하는 나에겐 적당한 모달 모드를 지원해야 한다.&lt;/li>
&lt;/ol>
&lt;p>여기에 org 모드는 이맥스를 사랑하게 될 것 같은 예상이 든다. (아직 깊이 빠지진 못했다.)&lt;/p>
&lt;h3 id="사용-중인-커스텀">사용 중인 커스텀&lt;/h3>
&lt;p>한동안의 삽질로 몇 가지를 완성했다.&lt;/p>
&lt;ol>
&lt;li>이전 창 위치와 크기를 기억해 복원하고&lt;/li>
&lt;li>적당히 커스텀 단축키를 정의하고&lt;/li>
&lt;li>입력 모드에서 한글을 사용하다 노멀 모드로 전환되면 영문 모드로 변경되는 기능까지 구성했다.&lt;/li>
&lt;/ol>
&lt;p>이 정도까지 완성하였고 이후 서술할 설치 과정까지 삽질을 마치고 보니 2022년부터는 좀 더 본격적으로 사용할 수 있을 듯 하다.&lt;/p>
&lt;h2 id="이맥스-설치-과정">이맥스 설치 과정&lt;/h2>
&lt;p>여러 클라이언트를 설치하고 나름 정리해 본 결과 맥용 커스텀이 가장 잘 되어 있는 아래 패키지를 사용하는 걸로 정했다.&lt;/p>
&lt;p>빌드된 패키지 파일은 여기에서도 직접 구할 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/railwaycat/homebrew-emacsmacport/releases">https://github.com/railwaycat/homebrew-emacsmacport/releases&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>brew &lt;code>cask&lt;/code> 로 설치하지 않으면 추가 디팬던시를 &lt;code>brew&lt;/code> 가 설치하는데 이게 알아서 관리해준다 해도 소스 수정해서 컴파일하는 작업을 하지 않는 이상 필요가 없다고 본다.&lt;/p>
&lt;p>doom emacs 가이드의 첫 번째 추천 클라이언트 자리를 차지할 만 하다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://emacsformacosx.com">https://emacsformacosx.com&lt;/a> 의 바이너리 보다 훨씬 빠름&lt;/li>
&lt;li>빌드된 패키지를 제공함(emacs-plus 는 컴파일해야 해서&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;p>아무튼 빌드 하지 말자. 여기 &lt;a href="https://github.com/railwaycat/homebrew-emacsmacport">https://github.com/railwaycat/homebrew-emacsmacport&lt;/a> 를 통해 &amp;ndash;cask 로 설치하자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ brew tap railwaycat/emacsmacport
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ brew install --cask emacs-mac-spacemacs-icon
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>스페이스맥스의 아이콘은 정말 멋지다.&lt;/p>
&lt;/blockquote>
&lt;p>설치가 완료되면 &lt;code>/usr/local/bin&lt;/code> 에 &lt;code>emacs&lt;/code> 실행 스크립트도 추가해 준다. &lt;a href="https://emacsformacosx.com/tips">https://emacsformacosx.com/tips&lt;/a> 에 있는 내용과 같다.&lt;/p>
&lt;p>필요에 따라 &lt;code>alias em='emacs &amp;amp;'&lt;/code> 으로 사용하자.&lt;/p>
&lt;h3 id="doom-커스텀">Doom 커스텀&lt;/h3>
&lt;p>이런 이맥스 편집 환경은 &lt;code>Spacemacs&lt;/code> 같은 통합 세팅 배포 시스템을 선보이게 되었고 조금 더 마이너한 &lt;code>Doom Emacs&lt;/code> 구성이 등장하게 되었다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.spacemacs.org/">Spacemacs: Emacs advanced Kit focused on Evil&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/hlissner/doom-emacs">An Emacs framework for the stubborn martian hacker&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>처음에는 스페이스맥스를 사용했었다. 그러다 한동안 흥미를 잃었다. 글쓰기를 다시 시작하고 있는데 입맛에 맞는 타이핑 환경을 찾아 헤매다 둠 이맥스를 다시 보면서 재미를 느껴고 있다.&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/hlissner/doom-emacs/screenshots/main.png" alt="Doom Emacs">&lt;/p>
&lt;p>주 사용처는 취미 코딩 용 &lt;code>Go&lt;/code> 개발 환경 구성과 블로그 글 쓸 때와 메인 에디터로 선택했다. 어설프지만 ORG 모드 연습도 하고 있는데 업무일지 작성할 때 사용 중이다.&lt;/p>
&lt;p>어느 정도 구성을 마치고 본격 사용을 시작했다.&lt;/p>
&lt;p>여유 있을 때 여길 보는게 제일 좋다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj">DoomCasts: Emacs Doom Screencasts - Zaiste Programming Youtube channel&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>28개의 클립이 있다. 둠 이맥스의 매력을 느껴 볼 수 있다.&lt;/p>
&lt;/blockquote>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/rCMh7srOqvw" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h3 id="설치-과정">설치 과정&lt;/h3>
&lt;p>둠 이맥스의 설치 과정은 공식 문서를 따라하는게 가장 좋다. 위에서 추천한 이맥스 패키지 고르는 과정만 주의하자.&lt;/p>
&lt;p>&lt;code>fd&lt;/code>,&lt;code>ripgrep&lt;/code> 을 필요로 한다. 미리 설치해 두자.&lt;/p>
&lt;h3 id="재설치">재설치&lt;/h3>
&lt;p>뭔가 세팅이 꼬였을 경우 쉽게 다시 설치할 수 있다.&lt;/p>
&lt;p>둠 이맥스의 구성은 &lt;code>~/.doom.d/&lt;/code> 에 저장되어 있다. 이 코드만 잘 백업해 두도록 하자.&lt;/p>
&lt;blockquote>
&lt;p>나는 dot file 관리를 위해 &lt;code>chezmoi&lt;/code> 를 사용 중이다.&lt;/p>
&lt;/blockquote>
&lt;p>이맥스 애플리케이션을 다시 설치할 필요는 없다. 이맥스의 로컬 세팅을 제거하고 둠 환경을 다시 설치하면 초기 세팅을 복원할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ rm -rf ~/.emacs.d/.local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ~/.emacs.d/bin/doom install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>새해 첫 글에 이맥스를 소개하기 위해 부랴 부랴 작성 중이다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content></item><item><title>About</title><link>https://faultnote.github.io/about/</link><pubDate>Sat, 01 Jan 2022 12:20:22 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/about/</guid><description>내 소개 &amp;#x1f601; 소프트웨어 엔지니어 데이원컴퍼니 개발실 플랫폼 개발팀장 발표 자료 예전 블로그 https://faultnote.tistory.com/ https://velog.io/@soomtong/</description><content>&lt;h3 id="내-소개-grin">내 소개 &amp;#x1f601;&lt;/h3>
&lt;ul>
&lt;li>소프트웨어 엔지니어&lt;/li>
&lt;/ul>
&lt;h4 id="데이원컴퍼니-개발실">데이원컴퍼니 개발실&lt;/h4>
&lt;ul>
&lt;li>플랫폼 개발팀장&lt;/li>
&lt;/ul>
&lt;h3 id="발표-자료presentation">&lt;a href="../presentation/">발표 자료&lt;/a>&lt;/h3>
&lt;h4 id="예전-블로그">예전 블로그&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://faultnote.tistory.com/">https://faultnote.tistory.com/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://velog.io/@soomtong/">https://velog.io/@soomtong/&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Hello World</title><link>https://faultnote.github.io/blog/hello-world/</link><pubDate>Tue, 07 Mar 2017 20:56:23 +0000</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/blog/hello-world/</guid><description>새 술은 새 부대에 블로그 정리 및 새로이 배우는 내용을 담기 위해 깃헙에 다시 페이지를 열었습니다. 다룰 내용은 아래와 같습니다. 웹 개발 중심의 Node.js 와 JavaScript 관련 기술 Linux 데스</description><content>&lt;h2 id="새-술은-새-부대에">새 술은 새 부대에&lt;/h2>
&lt;p>블로그 정리 및 새로이 배우는 내용을 담기 위해 깃헙에 다시 페이지를 열었습니다.&lt;/p>
&lt;p>다룰 내용은 아래와 같습니다.&lt;/p>
&lt;ul>
&lt;li>웹 개발 중심의 Node.js 와 JavaScript 관련 기술&lt;/li>
&lt;li>Linux 데스크탑 환경과 개발 툴&lt;/li>
&lt;li>그 외 최근 트랜드나 오늘 배운 내용들 정리&lt;/li>
&lt;/ul>
&lt;p>깃헙 페이지에 사용할 스태틱 제너레이터는 &lt;a href="https://hexo.io/">Hexo&lt;/a> 와 &lt;a href="http://notes.iissnan.com">Next&lt;/a> 테마가 여전히 가장 무난한 조합이네요.
우선은 여기에 마크다운 렌더러만 &lt;code>kramed&lt;/code> 으로 교체했습니다.
추후 필요한 만큼 플러그인을 세팅해 보려 합니다.&lt;/p>
&lt;p>포스트는 프라이빗 레포지토리에 보관하고 헥소 세팅은 드랍박스에 담아두고 심볼릭 링크로 헥소 프로젝트 폴더에 연결해 두었습니다.&lt;/p>
&lt;h2 id="지난-블로그-내용-정리">지난 블로그 내용 정리&lt;/h2>
&lt;p>아무래도 오래된 블로그를 그냥 닫기는 아쉬운 마음이 들어 그간 작성했던 내용이 무엇이었는지 기록을 남겨 두기로 했습니다.&lt;/p>
&lt;p>이글루와 티스토리를 사용했는데 개발 관련 내용은 티스토리에 주로 작성해 두었네요. (루비 공부를 하면서 시작했나 보네요.)&lt;/p>
&lt;h3 id="티스토리-블로그-목차">티스토리 블로그 목차&lt;/h3>
&lt;ul>
&lt;li>20071216-루비ruby-설치&lt;/li>
&lt;li>20071229-JavaScript-세상에서-가장-오해가-많은-프로그래밍-언어&lt;/li>
&lt;li>20071229-자바스크립트-객체지향-프로그래밍&lt;/li>
&lt;li>20071229-구글-챠트-API&lt;/li>
&lt;li>20080107-에너자이저-리튬-배터리&lt;/li>
&lt;li>20080118-IRB-인터프리터-내에서-사용된-변수-함수-클래스-보기&lt;/li>
&lt;li>20080123-파일-확장자-필터링&lt;/li>
&lt;li>20080123-자바-웹-애플리케이션-프레임웍의-구분&lt;/li>
&lt;li>20080123-자바-입문&lt;/li>
&lt;li>20080124-기본적인-스크립트-보안&lt;/li>
&lt;li>20080125-익스플로러-캐쉬-없이-페이지-보여주기&lt;/li>
&lt;li>20080125-인풋-박스에-글이-타-찼을때-다음-필드로-이동하기&lt;/li>
&lt;li>20080125-전달되는-값을-통해-체크하는-페이지&lt;/li>
&lt;li>20080125-스타일-시트로-한영-전환-통제하기&lt;/li>
&lt;li>20080205-오라클-초보-사용자를-위한-팁&lt;/li>
&lt;li>20080205-윈도우-서버-2008-새로운-기능&lt;/li>
&lt;li>20080207-숫자-한글-등-체크하는-스크립트&lt;/li>
&lt;li>20080207-생각의-폭을-넓혀주는-프로그래밍-언어-루비&lt;/li>
&lt;li>20080207-1-일반-질문-1&lt;/li>
&lt;li>20080207-2-다른-언어와의-비교&lt;/li>
&lt;li>20080207-3-루비-설치하기&lt;/li>
&lt;li>20080207-루비가-쿨한-이유-1-irb&lt;/li>
&lt;li>20080207-루비가-쿨한-이유-2-블록&lt;/li>
&lt;li>20080207-루비가-쿨한-이유-3-해시&lt;/li>
&lt;li>20080207-함수형-프로그래밍-1-함수-합성&lt;/li>
&lt;li>20080207-함수형-프로그래밍-2-커링&lt;/li>
&lt;li>20080207-Ruby-for-Impatient-Nuby&lt;/li>
&lt;li>20080208-참말-멋진-사이트라고&lt;/li>
&lt;li>20080209-서버-튜닝-Connection과-Memory&lt;/li>
&lt;li>20080209-가지못할-길-프로그래머&lt;/li>
&lt;li>20080209-C-그리고-indent&lt;/li>
&lt;li>20080209-FireFox-20012-업데이트&lt;/li>
&lt;li>20080209-ECMAScript-Basics-–-Syntax&lt;/li>
&lt;li>20080209-몇-가지-팁&lt;/li>
&lt;li>20080213-프리-오에스-로고-모음&lt;/li>
&lt;li>20080214-대세는-Eclipse-나는-NetBeans&lt;/li>
&lt;li>20080215-애자일-개발-Agile-위키사전이-설명한-애자일&lt;/li>
&lt;li>20080216-강박관념&lt;/li>
&lt;li>20080216-Rubyweaver-드림위버-익스텐션&lt;/li>
&lt;li>20080216-현장에서-마주칠-수-있는-10가지-타입의-프로그래머&lt;/li>
&lt;li>20080218-휴대폰-벨이-울리고-딱-끊어질-때&lt;/li>
&lt;li>20080218-마우스-오른쪽-드래그로-스크롤하기&lt;/li>
&lt;li>20080218-세벌식-390과-최종판&lt;/li>
&lt;li>20080220-Task-Switch-XP&lt;/li>
&lt;li>20080220-멀티-클립보드&lt;/li>
&lt;li>20080220-윈도우-탐색기-보조-프로그램&lt;/li>
&lt;li>20080220-솔라리스-네트웍-스크랩&lt;/li>
&lt;li>20080301-6시-알람을-해제했다&lt;/li>
&lt;li>20080301-초기-mysql-root-패스워드-설정-root-비번-잃어버렸을-경우-변경-하는방법&lt;/li>
&lt;li>20080302-솔라리스의-부팅과정&lt;/li>
&lt;li>20080302-hostname변경하기&lt;/li>
&lt;li>20080302-Swap-File을-추가-하는-방법&lt;/li>
&lt;li>20080302-솔라리스-설치-개요&lt;/li>
&lt;li>20080302-특정-network-service를-사용-중지-하기&lt;/li>
&lt;li>20080302-Network-setup&lt;/li>
&lt;li>20080302-Service-Port-목록&lt;/li>
&lt;li>20080302-UNIX-DAEMON&lt;/li>
&lt;li>20080302-Solaris-사용자-계정-만들기&lt;/li>
&lt;li>20080302-lsof-사용하여-시스템-체크하기&lt;/li>
&lt;li>20080302-Solaris-부팅시-오라클도-함께-startup하는-법&lt;/li>
&lt;li>20080302-SOLARIS-8-에서-ORACLE-817-기본-셋업-script&lt;/li>
&lt;li>20080303-리눅스-디스크-확장-LVM&lt;/li>
&lt;li>20080305-한글-입력기-변환-자바-스크립트&lt;/li>
&lt;li>20080319-Aptana-RadRails-10-발표&lt;/li>
&lt;li>20080323-Glassfish-V3-with-Ruby-Gem&lt;/li>
&lt;li>20080323-IT-노동자들&lt;/li>
&lt;li>20080323-Effective-C-강력한-C-코드를-구현하는-개발지침-50가지&lt;/li>
&lt;li>20080327-Zend-Studio&lt;/li>
&lt;li>20080401-루비-유저-가이드&lt;/li>
&lt;li>20080410-선sun-의-반가운-루비-소식&lt;/li>
&lt;li>20080410-EJB-관련-서적-메모&lt;/li>
&lt;li>20080413-리눅스-얼터네이티브&lt;/li>
&lt;li>20080415-절대-가지말아야할-회사&lt;/li>
&lt;li>20080422-TaskInfo-태스크-인포&lt;/li>
&lt;li>20080422-이-녀석-뭐지-그루비groovy&lt;/li>
&lt;li>20080422-MyEclipse-의-아쉬운-점-RMS&lt;/li>
&lt;li>20080424-ubuntu-804-show-on&lt;/li>
&lt;li>20080426-고정폭-한글문제-관련-스크랩&lt;/li>
&lt;li>20080428-Code-Conventions-for-JavaTM-Programing-Language&lt;/li>
&lt;li>20080429-익스플로러에서-한글이-안써질-때&lt;/li>
&lt;li>20080429-JavaServer-Pages-3rd-Edition&lt;/li>
&lt;li>20080429-Tomcat에-JSF-설치&lt;/li>
&lt;li>20080501-XP-테마-그놈-스킨&lt;/li>
&lt;li>20080501-넷빈즈-성능-향상-퍼포먼스-튜닝-팁-NetBeans-performance-Tuning-Tip&lt;/li>
&lt;li>20080501-Java-Decompile-하위-디렉토리까지-디컴파일&lt;/li>
&lt;li>20080502-JSP-자바빈-컴포넌트-그리고-데이터베이스-최범균님-자료&lt;/li>
&lt;li>20080503-JSF-Manual&lt;/li>
&lt;li>20080507-오라클-함수-모음&lt;/li>
&lt;li>20080507-TDD-Why&lt;/li>
&lt;li>20080508-문자열-비교에-과-Equals-속도-비교&lt;/li>
&lt;li>20080511-솔라리스-Solaris-오픈-솔라리스-관련&lt;/li>
&lt;li>20080511-60-버전-에디터의-참신한-기능들&lt;/li>
&lt;li>20080511-우와우와-루비-모드가-있었군요-Phusion-Passenger-aka-modrails&lt;/li>
&lt;li>20080513-프리커맨더-freecommander-그리고-넥서스파일-NexusFile&lt;/li>
&lt;li>20080514-작업할-때-이지-리슨-흥얼흥얼-생각없이-듣자는거죠&lt;/li>
&lt;li>20080515-개발자가-놓치기-쉬운-자바의-기본-원리-DNA-발췌&lt;/li>
&lt;li>20080519-쿼리속도-향상과-효율적인-게시판-쿼리&lt;/li>
&lt;li>20080520-JSP-requestgetParameter-이슈-하나&lt;/li>
&lt;li>20080523-DOJO-툴-킷&lt;/li>
&lt;li>20080525-Rails-Powered-by-the-GlassFish-Application-Server&lt;/li>
&lt;li>20080528-비스타-공용-폴더-숨기기&lt;/li>
&lt;li>20080529-인텔-내장-그래픽-칩셋-비교&lt;/li>
&lt;li>20080605-오라클-익스프레스-oracle-express-웹서버-포트-변경하기&lt;/li>
&lt;li>20080610-무료-웹에디터-비교표&lt;/li>
&lt;li>20080613-즐겨쓰는-프리웨어-및-쉐어웨어-그리고-상용-소프트웨어&lt;/li>
&lt;li>20080613-Start-Struts-2-PDF-문서&lt;/li>
&lt;li>20080615-웹사이트-카피-프로그램&lt;/li>
&lt;li>20080617-루비ruby-on-rails-with-Oracle와-오라클-관련-문서들&lt;/li>
&lt;li>20080618-가상화-소프트웨어&lt;/li>
&lt;li>20080619-친절한-재헌씨&lt;/li>
&lt;li>20080619-pageEncoding-디렉티브-EUC-KR-세팅&lt;/li>
&lt;li>20080619-무료-프로그램-모음&lt;/li>
&lt;li>20080620-기대되는-NetBeans-65-Development-Plan&lt;/li>
&lt;li>20080620-넷빈즈-65-개발-버전-사용&lt;/li>
&lt;li>20080713-넷빈즈에서-텍스트-인코딩-세팅-하는-법&lt;/li>
&lt;li>20080716-나우콤-대표-구속-중-서신-공개&lt;/li>
&lt;li>20080814-넷빈netbeans-베타-떳네요&lt;/li>
&lt;li>20080815-Asus-M51VR&lt;/li>
&lt;li>20080821-ASP-뭐-이리-구려&lt;/li>
&lt;li>20080821-기다리는-JDK-6-u10&lt;/li>
&lt;li>20080821-오토캐드-도면-보는-프로그램&lt;/li>
&lt;li>20080822-ASP-함수-또는-프로시저-콜-규칙&lt;/li>
&lt;li>20080825-갑을병정-도-안되는-무수리&lt;/li>
&lt;li>20080826-웹-프레임워크-Struts-2-Hibernate-3-iBATIS-2-웹-서비스-개발-실습&lt;/li>
&lt;li>20080827-VS2008-TS&lt;/li>
&lt;li>20080828-이응ieung&lt;/li>
&lt;li>20080828-내가-쓰는-KMP-스킨&lt;/li>
&lt;li>20080829-ASP-Form-변수-일괄처리-하기&lt;/li>
&lt;li>20080829-Grails-사용자-가이드&lt;/li>
&lt;li>20080830-마이크로소프트-윈도우-유틸리티-Sysinternals&lt;/li>
&lt;li>20080830-참-비슷해요-My-song-and-My-song&lt;/li>
&lt;li>20080831-인간-눈의-잔상&lt;/li>
&lt;li>20080904-이런-개새&lt;/li>
&lt;li>20080904-유닉스-팁-열가지&lt;/li>
&lt;li>20080906-Django-Book&lt;/li>
&lt;li>20080907-루비보다-파이썬이-끌리네-이런&lt;/li>
&lt;li>20080908-파이썬Python-튜토리얼Tutorial-Abstract&lt;/li>
&lt;li>20080909-HTML5-관련-정보-보다가-알게된-대체-스타일시트&lt;/li>
&lt;li>20080909-울트라에디트에서-파이썬-사용하기&lt;/li>
&lt;li>20080910-파이썬-문자열-나누기-팁&lt;/li>
&lt;li>20080911-JDK-6-u10-정식-업데이트-언제쯤-나오는지-아시는분-계신가요&lt;/li>
&lt;li>20080911-서버-2008-OEM-키&lt;/li>
&lt;li>20080911-와우-썬테크데이-2008-서울&lt;/li>
&lt;li>20080911-파폭이-빠르다-그래도-루프-코드는-생각-좀-하고&lt;/li>
&lt;li>20080911-기대되는-실험-거대-강입자-가속기LHC에서는-어떤-일이-벌어지나&lt;/li>
&lt;li>20080914-오라일리-Thinking-in-Java-3rd&lt;/li>
&lt;li>20080917-Activestate-사의-고마운-제품-그리고-PyScript&lt;/li>
&lt;li>20080919-파이썬Python-작업-환경-구축&lt;/li>
&lt;li>20110114-다음체-서울체-아리따체-그리고-나눔체&lt;/li>
&lt;li>20080922-Suns-Virtual-Box-20&lt;/li>
&lt;li>20080923-조건에-따른-인서트-업데이트-분기-로직&lt;/li>
&lt;li>20080923-펜탁스-렌즈-리스트&lt;/li>
&lt;li>20080925-압타나-스튜디오-파이썬-플러그인-지원&lt;/li>
&lt;li>20080928-MS-스크립트-Repository&lt;/li>
&lt;li>20080929-Ubuntu-설치-그리고-추가-작업들&lt;/li>
&lt;li>20080928-작업할때-들으면-킹왕짱&lt;/li>
&lt;li>20080929-인풋박스-엔터-체크&lt;/li>
&lt;li>20081001-칼리가리의-트루스페이스-무료화&lt;/li>
&lt;li>20081004-아이디어-챌린지-2008&lt;/li>
&lt;li>20081009-PDF-관련-툴&lt;/li>
&lt;li>20081013-썬-테크데이-할인가-판매-도서-목록&lt;/li>
&lt;li>20081013-PHP-코드를-최적화하는-40가지-팁&lt;/li>
&lt;li>20081014-자신만의-개발-노하우를-갖자고&lt;/li>
&lt;li>20081016-원격-서버로-SSH-연결을-통한-네이트온-이용-방법&lt;/li>
&lt;li>20081016-썬-테크데이-첫날-책-구입&lt;/li>
&lt;li>20081017-넷빈즈-65-최근-개발-버전-설치&lt;/li>
&lt;li>20081017-NetBeans-Wiki-JavaFXApplet&lt;/li>
&lt;li>20081021-파이썬-튜토리얼&lt;/li>
&lt;li>20081022-Adobe-TV-볼게-많죠&lt;/li>
&lt;li>20081022-JSP-20-JSTL-태그-Database-액션&lt;/li>
&lt;li>20081023-와우-JDK6update10-릴리즈&lt;/li>
&lt;li>20081024-Netbeans-와-함께-JSP-웹프로젝트-기본-JSTL-을-통해-데이터베이스-접근과-기본-쿼리-전송&lt;/li>
&lt;li>20081027-IMF에-살아남기-대책-옥히에서-펌&lt;/li>
&lt;li>20081121-넷빈즈-65-릴리즈&lt;/li>
&lt;li>20081031-그레일즈-한글-레퍼런스&lt;/li>
&lt;li>20081112-한줄짜리-생활의-지혜&lt;/li>
&lt;li>20081113-신입이-알아야할-것-옥히에서&lt;/li>
&lt;li>20081120-Ajax-기능을-흉내내는-구식-2중-셀렉트-처리&lt;/li>
&lt;li>20081125-W-Whale-RPG-Shine-이게-제목인가&lt;/li>
&lt;li>20081126-지금-20대를-트라우마-세대라고-하네&lt;/li>
&lt;li>20081128-데이터베이스-정규화-Normalization&lt;/li>
&lt;li>20081210-각-언어별-널-체크-빈값-체크-방법-모음&lt;/li>
&lt;li>20081210-팝업창-차단-검사-방법&lt;/li>
&lt;li>20081221-트집-만드신-개발자의-센스부족&lt;/li>
&lt;li>20090102-웹프로젝트-워크북-INDEX&lt;/li>
&lt;li>20090108-Ajax-Experience-컨퍼런스-동영상-강의-자료&lt;/li>
&lt;li>20090115-우리말-바로-쓰기&lt;/li>
&lt;li>20090204-JDBC-Driver-리스트&lt;/li>
&lt;li>20090218-2009-위시-리스트&lt;/li>
&lt;li>20090403-와콤-인튜오스-4&lt;/li>
&lt;li>20090415-LG파워콤-속도&lt;/li>
&lt;li>20090913-프레임워크-가상-머신&lt;/li>
&lt;li>20090913-구글이-제공하는-자바스크립트-프레임워크-서비스&lt;/li>
&lt;li>20090914-개발-개요-및-데이터베이스-구현&lt;/li>
&lt;li>20090914-환경점검&lt;/li>
&lt;li>20090917-포스트백-스크롤-문제&lt;/li>
&lt;li>20090921-PHP-코딩-스타일-가이드-CI&lt;/li>
&lt;li>20090921-테이블-유무-확인-후-생성하기&lt;/li>
&lt;li>20090923-MS-서버-및-개발-도구-사용법&lt;/li>
&lt;li>20090923-PCA-드림링크-II-펀드-투입비율&lt;/li>
&lt;li>20091005-넷빈즈netbeans-와-iBATIS&lt;/li>
&lt;li>20091027-윈도우7-MW-올인원-포레버&lt;/li>
&lt;li>20100107-비디오를-윈도우실행파일로-만들어주는-유용한-툴&lt;/li>
&lt;li>20100122-네이버-지도-API-사용&lt;/li>
&lt;li>20100131-객체-지향-게임&lt;/li>
&lt;li>20100205-HTML과-Javascript-의-진화&lt;/li>
&lt;li>20100203-유용한-유틸리티-모음-기사&lt;/li>
&lt;li>20100329-맥용-텍스트-에디터-오-놀라운-소식&lt;/li>
&lt;li>20100615-How-JQuery-Works&lt;/li>
&lt;li>20100607-와우-HTML5-로-만들어진-아이폰-웹-앱-게임&lt;/li>
&lt;li>20100610-객체지향-개발론과-반복의-과정&lt;/li>
&lt;li>20100610-아키텍트가-하는-일&lt;/li>
&lt;li>20100614-비스타-노트북-설치-프로그램&lt;/li>
&lt;li>20100706-아이폰iPhone-정보-모음&lt;/li>
&lt;li>20100706-안드로이드폰Android-Phone-정보-모음&lt;/li>
&lt;li>20100706-윈도우폰Windows-Phone-정보-모음&lt;/li>
&lt;li>20100708-다시-우분투&lt;/li>
&lt;li>20100709-색상-디자인-가이드-Kuler-디지털-색상환&lt;/li>
&lt;li>20100723-개인-개발자에게-윈도우모바일-폰이-더-기대되는-이유&lt;/li>
&lt;li>20100718-개인적으로-사용되는-언어별-클래스-생성-및-Hello-world-출력-정리&lt;/li>
&lt;li>20100718-BMW-인테그럴-액티브-스티어-기술&lt;/li>
&lt;li>20100719-Effective-C&lt;/li>
&lt;li>20100720-프리젠테이션을-위한-최상의-컨디션을-유지하는-방법&lt;/li>
&lt;li>20100803-자바스크립트-배열-관련&lt;/li>
&lt;li>20100804-각-프로그램-메뉴별-단축키-언더바-표시&lt;/li>
&lt;li>20100805-자바스크립트-객체&lt;/li>
&lt;li>20100814-JQTouch-치트쉬트&lt;/li>
&lt;li>20100825-당신을-웹브라우저-전문가로-만들어-드립니다&lt;/li>
&lt;li>20100826-스프링-제우스-조합에서-리다이렉트-문제점&lt;/li>
&lt;li>20100826-자바스크립트로-숫자만-판단할-경우&lt;/li>
&lt;li>20100901-웹브라우저-엔진&lt;/li>
&lt;li>20100905-Selectors-API-Level-2&lt;/li>
&lt;li>20100912-EUC-KR-과-UTF-8&lt;/li>
&lt;li>20100912-스크롤-이벤트-활용&lt;/li>
&lt;li>20100929-자주-쓰이는-jQuery-AJAX-예제&lt;/li>
&lt;li>20101009-Struts-1x-Spring-1x-iBatis-23-연동시-체크해야할-xml-들&lt;/li>
&lt;li>20101207-PHP-Variable-Tests&lt;/li>
&lt;li>20101208-코드이그나이터codeigniter-indexphp-관련&lt;/li>
&lt;li>20101217-CSS-3-rotate-45deg-테스트&lt;/li>
&lt;li>20101224-jQuery-특정-요소만-ajax-로딩&lt;/li>
&lt;li>20110105-프로젝트-진행시-사용하는-유틸리티-노트&lt;/li>
&lt;li>20110107-텍스트-에디터-단축키-통일&lt;/li>
&lt;li>20110217-MySQL-타입별-최대-최소-값&lt;/li>
&lt;li>20110314-placeholder-처리&lt;/li>
&lt;li>20110323-IE8-FF4-CR10-OP11-헤더-스크린샷&lt;/li>
&lt;li>20110407-네이버-블로그-검색-API-연동-PHP&lt;/li>
&lt;li>20110527-MySQL-문자열-치환-데이터-덤프-및-복원-문자열-나누기&lt;/li>
&lt;li>20110617-자바스크립트-코딩할-때-실수-하기-쉬운-몇가지&lt;/li>
&lt;li>20110630-유능한-C-개발자가-착각하는-나쁜-자바스크립트-습관-Part-1&lt;/li>
&lt;li>20110630-유능한-C-개발자가-착각하는-나쁜-자바스크립트-습관-Part-2&lt;/li>
&lt;li>20110630-유능한-C-개발자가-착각하는-나쁜-자바스크립트-습관-Part-3&lt;/li>
&lt;li>20110622-Struts-2-Performance-Tuning&lt;/li>
&lt;li>20110704-CentOS-5-에-NodeJS-MongoDB-설치하기&lt;/li>
&lt;li>20110708-NodeJS-기반의-Coffee-Script-개발-환경&lt;/li>
&lt;li>20110714-Playframework&lt;/li>
&lt;li>20110716-이클립스에-Play-프레임워크-플러그인-설치&lt;/li>
&lt;li>20110929-결국-rvm-implode-루비-재설치&lt;/li>
&lt;li>20111031-네이트온-트레이-아이콘-버그&lt;/li>
&lt;li>20111120-NIX-용-쉘-세팅을-위한&lt;/li>
&lt;li>20111130-CSS-애니메이션-작업-후기&lt;/li>
&lt;li>20111206-micro-PHP-framework-삽질기&lt;/li>
&lt;li>20111208-IntelliJ-IDEA-에서-coffee-script-코딩&lt;/li>
&lt;li>20111212-커피스크립트에-대한-아쉬움&lt;/li>
&lt;li>20111227-PHP-에서-include-와-require-의-차이&lt;/li>
&lt;li>20120105-매킨토시-한글-입력기&lt;/li>
&lt;li>20120107-자바스크립트-스니핏&lt;/li>
&lt;li>20120221-PHPFog-with-SlimPHP-테스팅&lt;/li>
&lt;li>20120309-DIV-안의-엘리먼트-세로-정렬&lt;/li>
&lt;li>20120331-플로피-드라이브가-달린-우분투-데스크탑-소소한-삽질&lt;/li>
&lt;li>20120502-최근의-아이폰-모바일-라이프&lt;/li>
&lt;li>20120522-cafe24-클라우드-호스팅-셋업&lt;/li>
&lt;li>20120817-한영한자키가-없는-키보드를-위한-레지스트리&lt;/li>
&lt;li>20120918-nodejs-파일-작업-팁&lt;/li>
&lt;li>20120919-VSFTP-와-PHP-의-localtime-문제&lt;/li>
&lt;li>20120919-tmux&lt;/li>
&lt;li>20120919-Ubuntu-1204-LTS-Server-셋업&lt;/li>
&lt;li>20120919-nodejs-로-구현한-국내-도메인-리스트-구하기&lt;/li>
&lt;li>20120919-jetbrains-IDE-플러그인-사용-영상&lt;/li>
&lt;li>20120919-Jade-템플릿-사용시-IE-예외-처리&lt;/li>
&lt;li>20120920-윈도우에서-nodemon-사용시-팁&lt;/li>
&lt;li>20120922-웹스톰의-특별한-에디팅-기능&lt;/li>
&lt;li>20121112-OSX-한글입력기-구름&lt;/li>
&lt;li>20121011-KCP-결제-모듈-적용기&lt;/li>
&lt;li>20121105-윈도우7-작업표시줄에-시계날짜요일-표시하기&lt;/li>
&lt;li>20121105-Kotlin&lt;/li>
&lt;li>20121108-PHP-변수-초기화-및-조건부-할당&lt;/li>
&lt;li>20121110-HP-ProBook-4530s-A9D61PA&lt;/li>
&lt;li>20121130-zsh-사용해-봄&lt;/li>
&lt;li>20121222-ImageMagick-설치-관련&lt;/li>
&lt;li>20130502-로컬-개발환경-세팅&lt;/li>
&lt;li>20130119-FC200RT-청소&lt;/li>
&lt;li>20130115-CentOS-58-에서-최신의-NodeJS-설치&lt;/li>
&lt;li>20130123-Express-와-별도의-파일업로더-사용시-주의점&lt;/li>
&lt;li>20130130-PHP-로컬-웹서버-테스트&lt;/li>
&lt;li>20130205-Ubuntu-에-Oracle-Java-를-설치하기&lt;/li>
&lt;li>20130213-mongoDB-사용자-계정-관련&lt;/li>
&lt;li>20130509-아파치-웹서버를-엔진엑스로-교체하기&lt;/li>
&lt;li>20130319-엔진엑스nginx-에-SSL-세팅하기&lt;/li>
&lt;li>20130416-몽고DB-의-좋은-점-몇가지&lt;/li>
&lt;li>20130501-우분투-1204-셋업-소회&lt;/li>
&lt;li>20130515-Nginx-프록시-모드-세팅-점검&lt;/li>
&lt;li>20130709-파티션을-날려버렸어&lt;/li>
&lt;li>20130804-프로세스-관리&lt;/li>
&lt;li>20130904-find-명령-예제&lt;/li>
&lt;li>20131030-윈도우즈-피시에-우분투-더부살이&lt;/li>
&lt;li>20131115-Dart-lang&lt;/li>
&lt;li>20140203-나눔고딕-적용시-문제점&lt;/li>
&lt;li>20140204-HTC-센세이션-언락-커스텀-롬&lt;/li>
&lt;li>20140211-Git-을-사용하면서-발생하는-실수를-복구-하기-위한-명령-몇-가지-케이스&lt;/li>
&lt;li>20140319-Find-Grep-명령-예제&lt;/li>
&lt;li>20140630-Nginx-에-코모도-Positive-SSL-적용기&lt;/li>
&lt;li>20150417-클라이언트-에디터에서-서버-파일-편집하기&lt;/li>
&lt;li>20150724-C-코딩-시-로컬-메모리-변수-구분&lt;/li>
&lt;li>20150916-페블-타임-사용기&lt;/li>
&lt;li>20150904-애플-파워맥-G5&lt;/li>
&lt;li>20150915-네이버의-새로운-코딩용-폰트-공개&lt;/li>
&lt;li>20150917-페블-타임-34-펌웨어-변경점&lt;/li>
&lt;li>20151009-C83-언어팩-이벤트&lt;/li>
&lt;li>20151112-자바스크립트용-Key-bind-라이브러리&lt;/li>
&lt;li>20160803-노드Nodejs의-시대&lt;/li>
&lt;li>20161111-KOSSCON-2016-참가-후기&lt;/li>
&lt;li>20161111-최신-Mysql-캐릭터-셋과-컬레이션&lt;/li>
&lt;/ul>
&lt;h2 id="quick-start">Quick Start&lt;/h2>
&lt;h3 id="create-a-new-post">Create a new post&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ hexo new &lt;span style="color:#e6db74">&amp;#34;My New Post&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/writing.html">Writing&lt;/a>&lt;/p>
&lt;h3 id="run-server">Run server&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ hexo server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/server.html">Server&lt;/a>&lt;/p>
&lt;h3 id="generate-static-files">Generate static files&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ hexo generate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/generating.html">Generating&lt;/a>&lt;/p>
&lt;h3 id="deploy-to-remote-sites">Deploy to remote sites&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ hexo deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/deployment.html">Deployment&lt;/a>&lt;/p></content></item><item><title>Presentation</title><link>https://faultnote.github.io/presentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/presentation/</guid><description>함께 자라기 다시보기 2022년 6월 16일</description><content>&lt;h3 id="함께-자라기-다시보기">함께 자라기 다시보기&lt;/h3>
&lt;p>2022년 6월 16일&lt;/p>
&lt;p>&lt;a href="../presentation/1/agile-coach-book.html">&lt;img src="./1/agile-coach-book.jpeg" alt="함께 자라기 다시 보기">&lt;/a>
&lt;figure >
&lt;audio controls preload="metadata">
&lt;source src="https://faultnote.github.io/1/agile-coach-book.m4a" type="audio/mpeg">
&lt;/audio>
&lt;/figure>
&lt;/p>
&lt;hr></content></item></channel></rss>