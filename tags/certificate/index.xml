<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>certificate on FaultNote</title><link>https://faultnote.github.io/tags/certificate/</link><description>Recent content in certificate on FaultNote</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><managingEditor>soomtong@gmail.com (soomtong)</managingEditor><webMaster>soomtong@gmail.com (soomtong)</webMaster><lastBuildDate>Sat, 12 Feb 2022 14:05:53 +0900</lastBuildDate><atom:link href="https://faultnote.github.io/tags/certificate/index.xml" rel="self" type="application/rss+xml"/><item><title>로컬 웹 서비스에 Easy-RSA 인증서 적용하기</title><link>https://faultnote.github.io/posts/easyrsa-nginx-guide/</link><pubDate>Sat, 12 Feb 2022 14:05:53 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/easyrsa-nginx-guide/</guid><description>nginx 서버에 로컬 호스트의 도메인을 위한 인증서를 적용하는 가장 쉽고 빠른 방법 개인 키/공개 키 기반 인증 시스템 PKI - Public Key Infrastructure 이해하기 우리말로 공개 키 기반 인증 시스템 으</description><content>&lt;blockquote>
&lt;p>nginx 서버에 로컬 호스트의 도메인을 위한 인증서를 적용하는 가장 쉽고 빠른 방법&lt;/p>
&lt;/blockquote>
&lt;h2 id="개인-키공개-키-기반-인증-시스템">개인 키/공개 키 기반 인증 시스템&lt;/h2>
&lt;h3 id="pki---public-key-infrastructure-이해하기">PKI - Public Key Infrastructure 이해하기&lt;/h3>
&lt;p>우리말로 &lt;code>공개 키 기반 인증 시스템&lt;/code> 으로 이해할 수 있는데, 사실 한 쌍의 키가 중심이 되지만 &amp;lsquo;공개 키&amp;rsquo; 라고 불리는 이유는 이 공개 키를 기반으로 암호화 하는 과정이 핵심이라 그런 듯 하다.&lt;/p>
&lt;p>공개 키 기반 인증은 한 쌍의 키를 전제로 한다. 만들어 진 한 쌍의 키는 하나는 공개용, 다른 하나는 비공개용 개인 키이다.&lt;/p>
&lt;h4 id="공개키-기반-암호화복호화">공개키 기반 암호화/복호화&lt;/h4>
&lt;p>PKI 를 통한 통신 과정에 암호화/복호화 작업은 기존에 보내는 사람이 주체가 되어 암호화 하는 과정에 일부 변형이 추가되었다. 암호화된 파일을 받을 대상의 공개 키로 암호화 하는 것이 핵심이다.&lt;/p>
&lt;p>인터넷에 있는 많은 참고 이미지 중 이 도식이 가장 좋은 것 같다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/pki-brief.jpeg" alt="https://bobbyarvian.blogspot.com/2010/05/pki-public-key-infrastructure-dan-ca.html" title="PKI-public key infrastructure dan CA-certificate authority">&lt;/p>
&lt;p>나를 Sender 라 하고 받을 대상을 Recipient 라 보면, 받을 대상의 공개 키로 암호화 하여 파일을 보내면 된다.&lt;/p>
&lt;p>내가 누군가에게 암호화된 파일을 받기 위해서 내 공개 키를 제공하면 된다. 인증 관련된 서비스에서 요구하는 공개키가 이런 개념이다.&lt;/p>
&lt;blockquote>
&lt;p>예를 들면, 깃헙의 애플리케이션 연동이나 ssh 서버 연결에 사용되는 public key 가 이런 종류다.&lt;/p>
&lt;/blockquote>
&lt;p>ssh 접속의 경우 내 공개키는 각 클라이언트와 서버가 암호화된 통신을 할 때 사용된다.&lt;/p>
&lt;p>이 방식을 응용하여 메일을 교환하거나 송신, 수신되는 네트워크의 데이터들을 암호화 한다.&lt;/p>
&lt;h4 id="x509">X.509&lt;/h4>
&lt;p>X.509 는 이 공개 키 기반의 인증 시스템으로 1988년 시작되어 현재는 버전3 를 사용하고 있다. 공개 키 기반의 다른 인증 시스템과 다르게 인증 기관이라는 개념을 도입하여 상위 기관을 통해 인증을 허용하는 시스템을 구성하고 있다.&lt;/p>
&lt;p>인증서 작업에 사용되는 파일의 종류를 좀 알아두면 좋다. 대부분 모두 일반 텍스트 파일이다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>.key&lt;/code>: 개인 키 파일이다. 이 파일은 공개용이 아니다.&lt;/li>
&lt;li>&lt;code>.csr&lt;/code>: 인증 기관에 인증서를 받기 위해 요청하는 스펙을 담은 문서&lt;/li>
&lt;li>&lt;code>.crt&lt;/code>: 인증서 자체, 암호화된 인증서 파일&lt;/li>
&lt;li>&lt;code>.pem&lt;/code>: Base64 로 인코딩된 인증서로 웹 서버에 사용된다.&lt;/li>
&lt;/ul>
&lt;h4 id="브라우저-통신과-ssltls">브라우저 통신과 SSL/TLS&lt;/h4>
&lt;p>웹 서버 데이터에 대한 암호화를 위해 무한에 가까운 수의 서비스가 공개 키를 제공하고 이를 관리하기에는 효율이 좋지 않기에 제3자가 개입하여 인증을 대행하는 방식이다.&lt;/p>
&lt;p>CA (Certificate authority) 또는 Root Certificate (루트 인증 기관) 라고 불리는 기관들이 이 역할을 한다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/ca-tls-brief.jpeg" alt="https://bobbyarvian.blogspot.com/2010/05/pki-public-key-infrastructure-dan-ca.html" title="PKI-public key infrastructure dan CA-certificate authority">&lt;/p>
&lt;p>https 통신에 사용되는 보안 프로토콜로 1999년 SSL(Secure Sockets Layer) 3.0 이 TLS(Transport Sockets Layer) 1.0 으로 공개 되었다.&lt;/p>
&lt;p>현재 SSL 버전 사용은 권고 되지 않는다.&lt;/p>
&lt;h2 id="openssl-과-easy-rsa">OpenSSL 과 Easy-RSA&lt;/h2>
&lt;p>OpenSSL 은 이런 암호화/복호화에 관여하는 프로토콜인 TLS 의 오픈소스 구현으로 다양한 시스템에 사용되고 있으며 무료 인증서로 자주 거론되는 Let&amp;rsquo;s encrypt 에서도 사용하고 있다.&lt;/p>
&lt;p>얼마 전 (2021년) 3.0 을 공개하였다.&lt;/p>
&lt;blockquote>
&lt;p>openssl 툴을 활용해 다양한 인증서 생성 및 인증 요청서를 만들수 있는데, 조금 복잡하다. 그래서 이 과정을 단순화하고 체계적으로 유지하기 위한 &amp;rsquo;easy-rsa&amp;rsquo; 가 개발되어 있고, 이를 사용하여 로컬 서비스에 인증서를 적용하는 방법을 알아보려 한다.&lt;/p>
&lt;/blockquote>
&lt;p>아마 대부분의 개발자 시스템에 openssl 은 설치되어 있을 것이다. 추가로 easy-rsa 를 설치해 보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ brew info easy-rsa
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실행 파일은 &lt;code>easyrsa&lt;/code> 이니 헷갈리지 말자.&lt;/p>
&lt;p>Public Key Infrastructure(PKI) 환경을 구성하기 위해 초기화 작업이 필요하다.
개인키가 없지 않겠지만 easyrsa 를 통해 서비스용을 하나 만들자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa init-pki
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="macos-키체인-유틸리티">macOS 키체인 유틸리티&lt;/h3>
&lt;p>인증서를 생성하기 전에 인증서를 운영체제에서 사용하고 유지/관리하는 방법을 이해해야 한다.&lt;/p>
&lt;p>맥OS 에서 인증서는 &lt;code>Keychain Access&lt;/code> 유틸리티를 통해 관리할 수 있다. 이 안에 각종 루트 인증서들이 있고 우리가 만들 사설 루트 인증서를 추가하여 관리할 것이다.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/macos-keychain-access.png" alt="macOS Keychain Access">&lt;/p>
&lt;h3 id="시나리오">시나리오&lt;/h3>
&lt;p>주요 작업 시나리오는 다음과 같다.&lt;/p>
&lt;ol>
&lt;li>가상의 최상위 인증 기관 인증서 생성&lt;/li>
&lt;li>최상위 인증 기관의 인증서를 운영체제에 추가, 사용 허용&lt;/li>
&lt;li>인증 기관에서 상속된 서비스용 인증서 생성&lt;/li>
&lt;li>nginx 에 인증서 적용&lt;/li>
&lt;/ol>
&lt;h3 id="루트-인증서-발급">루트 인증서 발급&lt;/h3>
&lt;p>웹 브라우저는 루트 인증기관(CA)을 신뢰하고 대부분의 브라우저는 이 루트 인증서와 암호화된 통신 프로토콜을 내장하고 있다.&lt;/p>
&lt;p>실제 서비스에는 이 루트 인증기관에서 비용을 제공하고 운영할 서비스 사이트의 인증서를 발급 받아 적용해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>우리가 사용할 로컬 개발 환경의 웹 서버를 위해 인증서를 구입하거나 실제 도메인이 부여되지 않은 사이트의 인증서를 발급 받기는 애매하다. 그래서 가상의 루트 인증기관을 만들어 루트 인증서를 생성하고 이 기관을 통해 로컬 서비스의 인증서를 생성해 웹 서버에 적용할 것이다.&lt;/p>
&lt;/blockquote>
&lt;h4 id="ca-만들기">CA 만들기&lt;/h4>
&lt;p>easyrsa 를 통해 루트 인증기관의 인증서를 쉽게 생성할 수 있다. 이 과정은 CA 에 대한 조직 정보를 포함한다. easyrsa 는 &lt;code>Easy-RSA CA&lt;/code> 을 사용한다. 그대로 쓰자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa build-ca
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>생성된 인증서는 &lt;code>/usr/local/etc/pki/ca.crt&lt;/code> 에서 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cat /usr/local/etc/pki/ca.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 과정은 다음 내용을 포함하고 있다.&lt;/p>
&lt;ol>
&lt;li>루트 인증기관을 위한 개인 키를 만들고 → &lt;code>.key&lt;/code> 파일&lt;/li>
&lt;li>인증 서명 요청서를 만들고 → &lt;code>.csr&lt;/code> 파일&lt;/li>
&lt;li>x509 서명까지 완성한다 → &lt;code>.crt&lt;/code> 파일&lt;/li>
&lt;/ol>
&lt;p>만들어진 루트 인증서 내용은 easyrsa 를 통해 확인할 수 있다. 기본적으로 10년 짜리 서명을 제공해 준다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa show-ca
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Using SSL: /usr/local/opt/openssl@1.1/bin/openssl OpenSSL 1.1.1m &lt;span style="color:#ae81ff">14&lt;/span> Dec &lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Showing details &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ca&amp;#39;&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This file is stored at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/local/etc/pki/ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="keychain-access-에-추가-및-허용">KeyChain Access 에 추가 및 허용&lt;/h4>
&lt;p>&lt;code>File &amp;gt; Import Item&lt;/code> 메뉴를 통해 위에서 생성한 루트 인증서를 추가하고 안전한 사용을 허용하자.&lt;/p>
&lt;p>&lt;img src="https://faultnote.github.io/posts/images/macos-keychain-access-permit-root-cert.png" alt="macOS Keychain Access">&lt;/p>
&lt;p>이 작업 후에는 로그아웃 하고 다시 로그인 하여 시스템에 인증서가 적재되도록 한다.&lt;/p>
&lt;h3 id="로컬-서비스용-인증서-발급">로컬 서비스용 인증서 발급&lt;/h3>
&lt;p>이제 우리가 사용할 로컬 서비스의 서버 인증서 만들자.&lt;/p>
&lt;p>마찬가지로 서버 용 비공개 키를 만들고 루트 인증 기관의 인증을 받아 서버 인증서를 만든다. 복잡한 절차가 있지만 easyrsa 로 단순하게 처리할 수 있다.&lt;/p>
&lt;p>이 과정에서 &lt;code>localhost&lt;/code> 라는 파일 이름 기반의 식별자를 사용하였다. 이 부분을 xxx-server 등으로 자유롭게 변경하여 사용할 수 있다.&lt;/p>
&lt;h4 id="멀티-호스트-인증">멀티 호스트 인증&lt;/h4>
&lt;p>내 경우 관리하는 호스트가 여러 개이다 보니 멀티 호스트 인증을 하면 하나의 인증서로 다중 도메인을 처리할 수 있다. &lt;code>EASYRSA_EXTRA_EXTS&lt;/code> 환경 변수에 추가할 도메인 정보를 담아 생성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ export EASYRSA_EXTRA_EXTS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;subjectAltName=DNS.1:local.site-a,DNS.2:local.site-b&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="서버-인증서-생성">서버 인증서 생성&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ easyrsa build-server-full localhost nopass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>nopass&lt;/code> 옵션은 인증서의 사용 과정에 패스워드를 적용하지 않는 옵션이다.&lt;/p>
&lt;blockquote>
&lt;p>서버 인증서는 nginx 등의 서버를 구동할 때마다 패스워드를 요구해서 보통 패스워드 없이 생성한다.&lt;/p>
&lt;/blockquote>
&lt;p>이렇게 생성된 인증서는 &lt;code>/usr/local/etc/pki/issued&lt;/code> 에 저장되어 있다.&lt;/p>
&lt;p>앞 부분에는 인증 대상의 정보가 있고 아래에 인증서 정보가 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cat /usr/local/etc/pki/issued/localhost.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ easyrsa show-cert localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Extended Key Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TLS Web Server Authentication
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Key Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Digital Signature, Key Encipherment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X509v3 Subject Alternative Name:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DNS:local.site-a, DNS:local.site-b, DNS:local.site-c, DNS:local.site-d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Subject Alternative Name:&lt;/code> 항목에 다중 도메인이 기록된 것을 확인할 수 있다.&lt;/p>
&lt;h4 id="nginx-용-인증서-조립">nginx 용 인증서 조립&lt;/h4>
&lt;p>이렇게 생성된 인증서를 웹 서버에 사용하기 위해 조립 과정을 거쳐야 한다.&lt;/p>
&lt;p>핵심은 서버 인증서와 루트 인증서를 결합하여 웹 서버에 맞는 인증서 파일을 생성하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cat -p /usr/local/etc/pki/issued/localhost.crt &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> /usr/local/etc/pki/ca.crt &amp;gt; ./server.pem
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>오리지널 cat 대신 bat 을 사용하고 있어 &lt;code>-p&lt;/code> 옵션이 추가되었다.&lt;/p>
&lt;/blockquote>
&lt;p>이렇게 생성된 파일과 서버의 키 정보를 nginx conf 에 추가하자.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">ssl_certificate [server.pem 이 있는 경로]/server.pem;
ssl_certificate_key /usr/local/etc/pki/private/localhost.key;
&lt;/code>&lt;/pre>&lt;p>easyrsa 가 없었으면 아래와 여러 단계의 과정을 거쳐야 했을 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ openssl ecparam -out server.key -name prime256v1 -genkey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ openssl req -new -sha256 -key server.key -out server.csr -config ./openssl-host.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ openssl x509 -req -sha256 -days &lt;span style="color:#ae81ff">365&lt;/span> -in server.csr -CA /usr/local/etc/pki/ca.crt -CAkey /usr/local/etc/pki/private/ca.key -CAcreateserial -out server.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ openssl x509 -in server.crt -text -noout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>물론 openssl 을 통해 생성된 인증서를 점검할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ openssl x509 -in /usr/local/etc/pki/issued/localhost.crt -text -noout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://faultnote.github.io/posts/images/ngixn-certi-localhost.png" alt="certified localhost in nginx">&lt;/p>
&lt;h4 id="인증서-관리">인증서 관리&lt;/h4>
&lt;p>&lt;code>easyrsa&lt;/code> 는 &lt;code>renew&lt;/code> 나 &lt;code>revoke&lt;/code> 등의 명령이 제공된다.&lt;/p>
&lt;p>revoke 하더라도 기존 .key 파일이나 .csr 등의 파일을 지워주는 것이 아니니 따로 삭제해줘야 한다.&lt;/p>
&lt;p>도메인 추가 정도라면 EASYRSA_EXTRA_EXTS export 를 수정하고 renew 하면 된다.&lt;/p></content></item></channel></rss>