<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>typescript on FaultNote</title><link>https://faultnote.github.io/tags/typescript/</link><description>Recent content in typescript on FaultNote</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><managingEditor>soomtong@gmail.com (soomtong)</managingEditor><webMaster>soomtong@gmail.com (soomtong)</webMaster><lastBuildDate>Sat, 19 Feb 2022 14:46:31 +0900</lastBuildDate><atom:link href="https://faultnote.github.io/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript 50 Lessons Part 3</title><link>https://faultnote.github.io/posts/typescript-50-lessons-3/</link><pubDate>Sat, 19 Feb 2022 14:46:31 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-3/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 15 타입스크립트는 값을 생성하</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 15
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
타입스크립트는 값을 생성하는 영역과 타입을 생성하는 영역으로 구분, 함수는 값을 생성
&lt;/pre>
&lt;p>
함수는 선언부와 본문으로 구성된다. `declare` 키워드는 함수의 본문을 구현하지 않고 코드를 구성할 수 있게 해준다. 인자부와 반환부에 타입을 선언할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Result&lt;/span>[]&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>실제 구현을 하게 되면 이 함수는 비동기로 작동하는데 데이터 fetch 를 위해 `fetch` 함수를 사용하기로 가정하면, 자바스크립트의 fetch 는 `Promise&amp;lt;any&amp;gt;` 를 반환하기 때문에 이 값을 Result 타입으로 캐스팅하여 타입 세이프한 환경을 구성할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[]) {
&lt;span style="color:#75715e">//...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`/search&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">queryString&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>() &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;)
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>`as` 키워드는 좌측의 값을 우측의 타입으로 처리한다. 함수 선언부에 반환 정보를 정의하는 것과 같은 역할을 한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt; {
&lt;span style="color:#75715e">//...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`/search&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">queryString&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>())
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>저자는 함수 선언부에 사용하는 것을 선호한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 16
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
함수 인자의 콜백 함수에 타입을 정의하여 타입 시스템을 강화
&lt;/pre>
&lt;p>
`typeof` 연산을 함수에 적용하면 함수의 타입을 알 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
함수 인자를 `Query` 라는 타입으로 정의해 보자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Query&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[],
&lt;span style="color:#a6e22e">assemble&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">includeTags&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>&amp;#39;assemble&amp;#39; 인자는 함수 타입을 가지고 이 함수는 includeTags 를 받아서 string 을 반환하는 콜백 함수인 것을 알 수 있다. 물론 이렇게 개선할수도 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">AssembleFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">includeTags&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Query&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[], &lt;span style="color:#a6e22e">assemble&lt;/span>: &lt;span style="color:#66d9ef">AssembleFn&lt;/span> }&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
콜백 함수를 사용하는 코드는 특정 기능을 끼워넣을 수 있는 함수로 패턴화 된다.
브라우저의 특정 엘리먼트에서 값을 받아 다른 엘리먼트로 노출하는 함수를 정의한다면 아래와 같이 확장이 가능하다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">displaySearch&lt;/span>(
&lt;span style="color:#a6e22e">inputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">outputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">search&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span>
)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 함수는 반환하는 값이 없다. (그냥 바깥 세상에 사이드이펙트만 발생시킨다.) `void` 는 lesson 17 에서 조금 더 알아본다.&lt;/p>
&lt;p>
`구조적 타입 시스템` 에서 함수 인자의 타입 정보는 이름에 제약되지 않고 인자의 전달 순서에 따라 제약된다. 아래 두 함수는 같은 타입 정보를 가진다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">testSearch&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>, &lt;span style="color:#a6e22e">tags&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>([{
&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`The &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">query&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> test book`&lt;/span>,
&lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">query&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-design-patterns`&lt;/span>,
&lt;span style="color:#66d9ef">abstract&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`A practical book on &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">query&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
}])
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">testSearch&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>, &lt;span style="color:#a6e22e">options&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>([{
&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`The &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">term&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> test book`&lt;/span>,
&lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">term&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-design-patterns`&lt;/span>,
&lt;span style="color:#66d9ef">abstract&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`A practical book on &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">term&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
}])
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>위 코드의 경우 &amp;#39;tags&amp;#39; 나 &amp;#39;options&amp;#39; 는 사용되지 않고 있다. 구조적 타입 시스템에서 이 두 번째 인자를 생략해도 타입 점검을 정상적으로 완료한다. 이어지는 레슨에서 이 타입들을 좀 더 다듬어 볼 예정이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 17
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
대체가능성
&lt;/pre>
&lt;p>
이전 코드의 함수 본문에서 첫 번째 인자도 사용하지 않는다면 선언하지 않아도 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">dummyContentSearchFn&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>() {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>([{
&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Form Design Patterns&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/form-design-patterns&amp;#39;&lt;/span>,
&lt;span style="color:#66d9ef">abstract&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;A practical book on accessible forms&amp;#39;&lt;/span>
}])
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
자바스크립트에서 함수는 인자의 개수에 따라 주의해야할 케이스가 있다. 필요한 인자가 없는 경우와 인자가 너무 많은 경우인데 함수를 실행할 때 필요한 인자가 없는 경우 런타임에 실행 실패한다. 인자가 너무 많은 경우 초과된 인자 그냥 무시된다.
이런 오류들은 타입스크립트를 적용하면 사전 점검된다.&lt;/p>
&lt;p>
&amp;#39;SearchFn&amp;#39; 을 사용하는 displaySearch 함수의 인자로 콜백 함수를 전달하는데 SearchFn 의 모양을 가지면 사용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#a6e22e">displaySearch&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;input&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;output&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">dummyContentSearchFn&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이를 대체 가능성이라 한다.&lt;/p>
&lt;p>
대체 가능성은 반환하는 값의 타입이 일치하면 이루어진다. 위 코드의 경우 두 콜백 함수 모두 배열 결과를 담은 promise 함수를 반환하고 있다.&lt;/p>
&lt;p>
타입스크립트의 `void` 는 다른 프로그래밍 언어에서 사용하는 void 와 조금 다르다.
자바스크립트의 모든 함수는 기본적으로 undefined 를 반환한다. 타입스크립트에서도 모든 함수는 반환 타입이 있다. 타입 추론이 어려울 경우 기본적으로 `void` 타입을 반환한다. void 타입의 하나의 값이 있는데 그 값은 &amp;#39;undefined&amp;#39; 이다.&lt;/p>
&lt;p>
void 타입은 모든 반환 타입에 대해 대체 가능하다. 콜백 함수가 void 반환인 경우 number 를 반환해도 타입 점검은 성공한다. 하지만 실제 반환되는 타입은 undefined 이기 때문에 다른 연산은 할 수 없다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>,
&lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[]) {
&lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`/search&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">queryString&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>() &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;)
.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">didItWork&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span>)
&lt;span style="color:#a6e22e">didItWork&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
})
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우 didItWork 는 undefined 를 가지기 때문에 컴파일에 실패한다.
바닐라 자바스크립트에서도 void 를 사용하여 함수의 실행 결과를 undefined 시킬 수 있다.&lt;/p>
&lt;p>
함수의 반환 타입을 `void` 에서 `undefined` 로 변경하면 대체 가능성을 제거할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>그리고 옵셔널 파라미터는 가장 마지막에 전달하는게 관행이다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 18
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
콜백 함수의 첫 인자에 명시적으로 this 를 추가하고 타입을 부여할 수 있다.
&lt;/pre>
&lt;p>
displaySearch 함수를 작성하는 과정에 this 를 사용하게 되는데 this.value 같은 경우 타입 추론이 실패하여 컴파일이 되지 않는다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">displaySearch&lt;/span>(&lt;span style="color:#a6e22e">inputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">outputId&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">search&lt;/span>: &lt;span style="color:#66d9ef">SearchFn&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> {
document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#a6e22e">inputId&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;change&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">searchTerm&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>
})
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>DOM 엘리먼트도 타입스크립트를 위해 타입을 제공하고 있다. 타입을 좁혀 타입스크립트 컴파일러가 추론이 가능하도록 개선해 본다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript"> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">HTMLInputElement&lt;/span>) {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">searchTerm&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이어서 이 addEventListner 의 콜백을 별도의 함수로 분리하면 this 는 콜백 함수의 첫 번째 인자로 this 의 타입을 정의해 줄 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">inputChangeHandler&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>)
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 인자는 타입스크립트만을 위한 정보로 컴파일된 자바스크립트에는 사라지게된다.&lt;/p>
&lt;div class="src src-javascript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">inputChangeHandler&lt;/span>() {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parentElement&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>);
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>그리고 this 를 포함한 함수는 호출되는 컨텍스트에 따라 달라지기 때문에 this 를 HTMLElement 타입으로 추론할 수 없는 위치에서 호출하게 되면 컴파일 되지 않는다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 19
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
함수 타입의 추가 기능들
&lt;/pre>
&lt;p>
tagged template 함수는 함수 호출에 &amp;#39;(인자)&amp;#39; 대신 &amp;#39;`인자`&amp;#39; 를 사용한다. 태그드 템플릿은 템플릿 문자 배열과 대상이 되는 문자열 표현식으로 구분된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#a6e22e">taggedTemplate&lt;/span>&lt;span style="color:#e6db74">`템플릿A&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿B`&lt;/span>
&lt;span style="color:#a6e22e">taggedTemplate&lt;/span>&lt;span style="color:#e6db74">`템플릿A&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿B&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿C`&lt;/span>
&lt;span style="color:#a6e22e">taggedTemplate&lt;/span>&lt;span style="color:#e6db74">`템플릿A&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿B&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿C&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">표현식&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">템플릿D`&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>템플릿과 표현식은 배열로 처리되는데 표현식은 rest 연산자를 통해 표현된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">taggedTemplate&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, ...&lt;span style="color:#a6e22e">tags&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Promise 를 반환하는 경우 async 로 함수를 선언하고 await 를 통해 Promise 의 resolved 값을 받을 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 20
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
함수 오버로딩
&lt;/pre>
&lt;p>
타입스크립트는 함수 인자의 개수와 인자/반환 타입이 달라지는 경우를 위해 함수 오버로딩을 지원한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우 실제 구현 형태는 이렇게 풀이된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">p2?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> ((&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>), &lt;span style="color:#a6e22e">p3?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[])&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>처음으로 `|` 를 통한 유니언 타입이 소개되고 있다.
이 함수를 타입으로 등록하면 좀 더 나은 코드를 볼 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">SearchOverload&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[]&lt;/span>&amp;gt;
(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>, &lt;span style="color:#a6e22e">tags?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>: &lt;span style="color:#66d9ef">SearchOverload&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">p2?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[] &lt;span style="color:#f92672">|&lt;/span> ((&lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>), &lt;span style="color:#a6e22e">p3?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>[]) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;span style="color:#75715e">// body
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 21
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
제너레이터
&lt;/pre>
&lt;p>
제너레이터는 이터레이션을 구현하기 위해 시간의 흐름에 따라 값을 생성해 제공해 준다. 타입스크립트는 다양한 타입 정보를 제공하여 제너레이터 함수를 손쉽게 사용할 수 있도록 해준다.
제너레이터 함수의 반환 타입은 아래와 유사하다. async 함수가 반환하는 Promise 와 비교해 보면 도움이 될 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#a6e22e">Generator&lt;/span>&amp;lt;&lt;span style="color:#f92672">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">3&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">|&lt;/span> &lt;span style="color:#a6e22e">4&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">unknown&lt;/span>&amp;gt;&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>제너레이터는 풀링이 필요한 시스템에서 유용하다. fetch 를 통해 데이터를 받도록 하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">PollingResults&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">results&lt;/span>: &lt;span style="color:#66d9ef">Result&lt;/span>[]; &lt;span style="color:#a6e22e">done&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span> }
&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">polling&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Promise&lt;/span>&amp;lt;&lt;span style="color:#f92672">PollingResults&lt;/span>&amp;gt; {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/...&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">res&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>())
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>입력이 있을 때마다 백엔드에서 쿼리를 조회하는 제너레이터 함수는 이렇게 구성된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">getResults&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">AsyncGenerator&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[],&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">unknown&lt;/span>&amp;gt; {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span> {
&lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">polling&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>)
&lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">results&lt;/span>
} &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">done&lt;/span>)
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>AsyncGenerator 타입은 타입스크립트의 시스템 인터페이스로 등록되어 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getResults&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span>) {
&lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#a6e22e">someFn&lt;/span>)
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>제너레이터는 이터레이터이기 때문에 `for … of` 대상이 된다.
yield 의 반환 값을 처리하기 위해 .next() 을 사용할 수 있다. `.next(value)` 를 통해 yield 의 반환 값을 받을 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript"> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>, &lt;span style="color:#a6e22e">stop&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span> {
&lt;span style="color:#a6e22e">state&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">polling&lt;/span>(&lt;span style="color:#a6e22e">term&lt;/span>)
&lt;span style="color:#a6e22e">stop&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">results&lt;/span>
} &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">stop&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>브라우저에서 입력된 값을 사용하는 제너레이터 호출 구문은 아래처럼 구성될 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;searchField&amp;#39;&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;change&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">handleChange&lt;/span>)
&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">handleChange&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">HTMLElement&lt;/span>, &lt;span style="color:#a6e22e">ev&lt;/span>: &lt;span style="color:#66d9ef">Event&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">HTMLInputElement&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getResults&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>, &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span> {
&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">resultsGen&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span>(&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;undefined&amp;#39;&lt;/span>) {
&lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#a6e22e">appendResultToAnswerArea&lt;/span>)
&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>
}
} &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">done&lt;/span>)
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>await 와 .next(isStop) 을 통해 비동기로 데이터를 요청하고 반환된 결과의 상태에 따라 응답읍 제공한다.
이 경우 AsynGenerator 의 타입은 이렇게 정의된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#a6e22e">AsyncGenerator&lt;/span>&amp;lt;&lt;span style="color:#f92672">Result&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">[],&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">boolean&lt;/span>&amp;gt;&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 2</title><link>https://faultnote.github.io/posts/typescript-50-lessons-2/</link><pubDate>Sat, 22 Jan 2022 12:40:51 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-2/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. Lesson 9 any 괜찮은가? 아니, 안괜찮</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 9
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
any 괜찮은가? 아니, 안괜찮음
&lt;/pre>
&lt;p>
타입스크립트에서 `:` 을 통해 정의되는 타이핑 기법을 레프트핸드 타이핑이라고 한다.&lt;/p>
&lt;ul>
&lt;li>Left-Hand Typing: 식별자에 선언되는 타입 정보를 통해 타입을 정의한다.&lt;/li>
&lt;li>Right-Hand Typing: 식별자에 대입되는 값 정보를 통해 타입이 추론된다.&lt;/li>
&lt;/ul>
&lt;p>라이트핸드 타이핑은 조금 더 자바스크립티 하다.&lt;/p>
&lt;p>
`any` 타입은 가능하면 사용하지 말자.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 10
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
조건문을 추가하여 타입을 제한을 우회하기
&lt;/pre>
&lt;p>
타입 좁히기 기법은 비교/조건문을 통해 any 나 unknown 이 주는 위험을 보완할 수 있다.&lt;/p>
&lt;ol>
&lt;li>타입 가드: typeof 같은 연산을 통해 타입 정보를 추론할 수 있다.&lt;/li>
&lt;li>타입 비교 구문: 타입 가드를 통해 추론된 타입 정보로 이어지는 코드의 식별자에 대해 타입을 추론한다.&lt;/li>
&lt;li>타입 좁히기: any 타입이 적용된 식별자라 하더라도 타입을 제한할 수 있게 된다.&lt;/li>
&lt;/ol>
&lt;p>`any` 는 모든 타입의 수퍼 타입이다. 예를 들면, DOM 에서 `HTMLElement` 는 모든 HTML 엘리먼트의 수퍼 타입이다. 그래도 `any` 가 필요한 경우에는 `unknown` 으로 타협하자.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">selectDeliveryAddress&lt;/span>(&lt;span style="color:#a6e22e">addressOrIndex&lt;/span>: &lt;span style="color:#66d9ef">unknown&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;number&amp;#39;&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">deliveryAddresses&lt;/span>[&lt;span style="color:#a6e22e">addressOrIndex&lt;/span>]
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 경우 unknown 타입은 number 타입으로 추론되어 string 을 반환하는 함수에 적합하지 않은 타입을 반환하게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;number&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">deliveryAddresses&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">deliveryAddresses&lt;/span>[&lt;span style="color:#a6e22e">addressOrIndex&lt;/span>]
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;string&amp;#39;&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">addressOrIndex&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이렇게 조건문을 추가하여 타입 가드를 완성한다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 11
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
객체에 타입 정보를 추가하면서 구조적 타입 시스템과 과잉 속성 점검 기능을 이해하기
&lt;/pre>
&lt;p>
두 개의 최상위 타입 any 와 unknown 도 타입스크립트 전용의 원시 타입이다.
객체는 컴포지트 타입에 속한다. Shape 이 다른 경우 타입 오류를 유발한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;span style="color:#a6e22e">stock&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;span style="color:#a6e22e">description&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">movie&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Helvetica&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">6.66&lt;/span>,
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.19&lt;/span>,
&lt;span style="color:#a6e22e">stock&lt;/span>: &lt;span style="color:#66d9ef">1000&lt;/span>,
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>description 이 누락되어 타입 에러이다. 만약 타입에 정의된 프로퍼티 이외의 프로퍼티를 추가해도 타입 에러를 낸다. 그런데 이런 경우는 에러를 찾아내지 못한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">movieRated&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Helvetica&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">6.66&lt;/span>,
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.19&lt;/span>,
&lt;span style="color:#a6e22e">stock&lt;/span>: &lt;span style="color:#66d9ef">1000&lt;/span>,
&lt;span style="color:#a6e22e">description&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;90 minutes of gushing about Helvetica&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">rating&lt;/span>: &lt;span style="color:#66d9ef">5&lt;/span>,
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">movie&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">movieRated&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>타입스크립트의 구조적 타입 시스템에 따라 구조적 계약을 이행하는 조건이라면 타입 체크를 통과한다.&lt;/p>
&lt;p>
조금 깊게 본다면 대입문을 통해 새로운 식별자에 객체를 지정하는 과정(객체 할당)에 객체 주소의 복사가 일어나기 때문이다. 즉, 대입문을 통한 객체 할당 과정에서 계약 조건을 만족하면 타입 체크를 통과하는 것으로 이해할 수 있다.&lt;/p>
&lt;p>
그리고, 타입이 정의된 식별자 이름과 무관하게 모양이 같으면 같은 타입으로 혼용할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>타입스크립트의 타입 시스템은 친절하다고 소개하고 있지만 노미널 타입을 선호하는 사용자에게는 조금 부실하다.&lt;/p>
&lt;/blockquote>
&lt;p>
레프트핸드 타이핑이 동작 가능한 경우 과잉 속성 점검 기능을 통해 식별자에 대입시 초과되는 속성을 검사하여 오류를 제공한다. 물론 부족한 속성이 있어도 오류다.&lt;/p>
&lt;p>
함수의 인자로 객체를 전달할 때 타입 정의를 포함할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createArticleElement&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">createArticleElement&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>, &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span> })&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>명시적으로 풀어 사용해도 모양만 맞으면 된다. 당연히 과잉 속성 점검 기능도 동작한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#a6e22e">createArticleElement&lt;/span>({
&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Design Systems by Alla Kholmatova&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">20&lt;/span>,
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.19&lt;/span>,
&lt;span style="color:#a6e22e">rating&lt;/span>: &lt;span style="color:#66d9ef">5&lt;/span>,
})&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 12
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
객체 타입을 구분하기
&lt;/pre>
&lt;p>
복잡한 객체 구조가 있을 경우 객체 타입을 나눠서 새 객체 타입을 구성하는 방법을 소개하고 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">OrderComplex&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">articles&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
}[]
&lt;span style="color:#a6e22e">customer&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">address&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#a6e22e">city&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">zip&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">street&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#66d9ef">number&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#a6e22e">dateOfBirth&lt;/span>: &lt;span style="color:#66d9ef">Date&lt;/span>
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이런 구성의 객체 타입은 풀어 쓰면 이렇게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ArticleStub&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Address&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">city&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">zip&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">street&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#66d9ef">number&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">address&lt;/span>: &lt;span style="color:#66d9ef">Address&lt;/span>
&lt;span style="color:#a6e22e">dateOfBirth&lt;/span>: &lt;span style="color:#66d9ef">Date&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">articles&lt;/span>: &lt;span style="color:#66d9ef">ArticleStub&lt;/span>[]
&lt;span style="color:#a6e22e">customer&lt;/span>: &lt;span style="color:#66d9ef">Customer&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
다양한 기능으로 무장한 타입스크립트의 `typeof` 연산자를 통해 실제 객체 변수에 저장된 값을 추론해 새로운 타입으로 등록할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Order&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">someOrder1&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
옵셔널 프로퍼티 선언을 통해 유연한 타입 시스템을 구성할 수 있다. 강타입을 구현하면서 Null safety 를 실현하는 모던 프로그래밍 언어의 특징 중 하나이다.&lt;/p>
&lt;p>
이렇게 정의된 타입만 공유하기 위해 `import type` `export type` 구문을 사용할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#75715e">// some-example.ts file
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">stock?&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">description?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> { &lt;span style="color:#a6e22e">Article&lt;/span> } &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#39;./some-example&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">book&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">29&lt;/span>,
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">0.2&lt;/span>,
&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Another book by Smashing Books&amp;#39;&lt;/span>,
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 13
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
객체 타이핑
&lt;/pre>
&lt;p>
타입스크립트가 자바스크립트로 컴파일 되는 동안 값 정보만 남고 우리가 추가한 타입 정보는 사라지게 된다. 하지만 클래스는 그 자체로 타입 정보와 값 정보를 가지고 있는 특징이 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span> {
&lt;span style="color:#a6e22e">isPercentage&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>
&lt;span style="color:#a6e22e">amount&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#a6e22e">isPercentage&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>, &lt;span style="color:#a6e22e">amount&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isPercentage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">isPercentage&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">amount&lt;/span>
}
&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isPercentage&lt;/span>) {
&lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span>
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span>
}
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>클래스는 두 파트로 구성되는데 생성자와 프로토타입으로 나뉜다. 프로토타입은 객체의 모양을 정의하고 생성자에 의해 실체화 된다. 타입스크립트의 구조적 타이핑 기법에 따라 아래는 `Discount` 객체를 생성해 낼 수 있게 된다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">DiscountType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">isPercentage&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>
&lt;span style="color:#a6e22e">amount&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">disco&lt;/span>: &lt;span style="color:#66d9ef">DiscountType&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#ae81ff">0.2&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>구조적 타입 시스템에서 중요한 것은 오직 모양이다. 그 이름은 무의미하다.&lt;/p>
&lt;p>
클래스는 상속을 통해 확장할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TwentyPercentDiscount&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span> {
&lt;span style="color:#66d9ef">constructor&lt;/span>() {
&lt;span style="color:#66d9ef">super&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#ae81ff">0.2&lt;/span>)
}
&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">40&lt;/span>) {
&lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>)
}
}
&lt;span style="color:#a6e22e">isValidForDiscount&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">article&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">40&lt;/span>
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-4">
&lt;h4 id="headline-7">
구조적 타입 시스템과 명명형 타입 시스템
&lt;/h4>
&lt;div id="outline-text-headline-7" class="outline-text-4">
&lt;p>최근 프로그래밍 언어의 타입 시스템은 두 종류로 구분할 수 있다.&lt;/p>
&lt;ul>
&lt;li>Nominal Typing 을 가지는 언어: C++, Java 등; 클래스의 이름이 다르면 다른 타입이다.&lt;/li>
&lt;li>Structural Typing 을 가지는 언어: Ocaml, Haskell, TypeScript, Go 등; 클래스의 모양이 같으면 같은 타입이다. 덕 타이핑 등의 용어가 이 사상에서 나온다.&lt;/li>
&lt;/ul>
&lt;p>각각의 장단점이 있고 혼용되기도 한다. 타입스크립트를 명명형 타입 시스템처럼 사용하기 위한 기법도 많이 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://michalzalecki.com/nominal-typing-in-typescript/">Nominal typing techniques in TypeScript&lt;/a> 를 참고하자.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 14
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
인터페이스는 객체를 특정하는 제약
&lt;/pre>
&lt;p>
타입 시스템에는 인터페이스가 항상 따라오는데 타입스크립트에서도 마찬가지다. 객체지향 프로그래밍에서 인터페이스는 클래스를 기술하는 명세라고 볼 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">stock?&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">description?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ShopItem&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">stock?&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">description?&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>구조적 타입 시스템에서 위 둘은 같은 모양을 가지고 있고 혼용이 가능하다.
클래스에 인터페이스를 구현하기 위해 아래와 같이 사용한다. 명세를 구현하는 것이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DVD&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> &lt;span style="color:#a6e22e">ShopItem&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">title&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">9.99&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">vat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.2&lt;/span>
}
}
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Book&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> &lt;span style="color:#a6e22e">Article&lt;/span> {
&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
&lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#a6e22e">title&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">title&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">39&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">vat&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.2&lt;/span>
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
인터페이스와 타입은 같은 목적으로 사용되는 듯 해 보인다. 타입스크립트 코딩을 오래할수록 타입을 사용하기 위해 인터페이스를 사용하게 될 것이라고 조언하고 있다. 그 첫 이유는 선언을 병합하여 사용할 수 있는 점 때문이다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">global&lt;/span> {
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span> {
&lt;span style="color:#a6e22e">isDevelopment&lt;/span>: &lt;span style="color:#66d9ef">boolean&lt;/span>
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>Window 타입에 인터페이스를 추가하여 안전한 코드를 작성하는 예를 보여준다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Discount&lt;/span> {
&lt;span style="color:#75715e">//...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#a6e22e">article&lt;/span>: &lt;span style="color:#66d9ef">Article&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (window.&lt;span style="color:#a6e22e">isDevelopment&lt;/span>) {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Another discount applied&amp;#39;&lt;/span>)
}
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>점진적으로 자바스크립트를 확장해가며 빨간 줄을 만나지 않기 위한 노력을 하고 있다.&lt;/p>
&lt;ol>
&lt;li>타입스크립트 컴파일러는 자바스크립트로 변환하면서 타입 어노테이션을 잃어버린다.&lt;/li>
&lt;li>타입스크립트의 `any` 는 어느 타입에도 대응 가능한 고유한 원시 타입이다.&lt;/li>
&lt;li>이 `any` 는 타입스크립트의 점진적 타입 개선 과정에 도움이 된다.&lt;/li>
&lt;li>타입 가드 기법을 통해 타입을 추론이 동작하는 과정을 알아보았고 `typeof` 연산자는 타입 정보를 반환하는 기능도 가지고 있다.&lt;/li>
&lt;li>구조적 타입 시스템에 대해 살펴보았다.&lt;/li>
&lt;li>타입을 구성하는 다양한 방법을 알았다.&lt;/li>
&lt;li>객체지향 프로그래밍의 클래스는 값으로도 동작하고 타입으로도 동작하는 것을 알았다.&lt;/li>
&lt;li>인터페이스를 통해 타입 선언을 병합하는 방법이 있음을 알았다.&lt;/li>
&lt;/ol>
&lt;p>타입스크립트는 자바스크립트에 영향을 주고 있다.&lt;/p>
&lt;ol>
&lt;li>접근 제어자가 있다. (최근 자바스크립트에 도입되었다.)&lt;/li>
&lt;li>추상 클래스 개념이 있다.&lt;/li>
&lt;li>열거형을 선언할 수 있다.&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item><item><title>TypeScript 50 Lessons Part 1</title><link>https://faultnote.github.io/posts/typescript-50-lessons-1/</link><pubDate>Fri, 21 Jan 2022 20:47:53 +0900</pubDate><author>soomtong@gmail.com (soomtong)</author><guid>https://faultnote.github.io/posts/typescript-50-lessons-1/</guid><description>타입스크립트 in 50 레슨 스테판 바움가트너가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다. https://typescript-book.com/ 다루고 있는 주제는 아래와 같다</description><content>
&lt;div id="outline-container-headline-1" class="outline-2">
&lt;h2 id="headline-1">
타입스크립트 in 50 레슨
&lt;/h2>
&lt;div id="outline-text-headline-1" class="outline-text-2">
&lt;p>
&lt;a href="https://fettblog.eu/">스테판 바움가트너&lt;/a>가 스매싱 매거진에서 출판한 서적으로 타입스크립트 주요 주제들에 대해 잘 짚어주고 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://typescript-book.com/">https://typescript-book.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>다루고 있는 주제는 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>타입스크립트의 컨셉과 이해하기&lt;/li>
&lt;li>타입스크립트 툴 사용법과 효과적인 사용법&lt;/li>
&lt;li>뭔가 새로 배우지 않고 타입스크립트를 사용하는 법&lt;/li>
&lt;li>구조적 타입 시스템과 시멘틱 그리고 이게 왜 중요한지 이해하기&lt;/li>
&lt;li>유지 관리가 적은 타입을 만들고 재사용하는 법과 점진적으로 개선시키는 법&lt;/li>
&lt;li>프로젝트에 적합한 타입 시스템을 적용하는 법&lt;/li>
&lt;li>타입스크립트 커뮤니티와 언어가 개선되는 과정&lt;/li>
&lt;/ul>
&lt;p>기술적으로 다루는 내용은 아래와 같다.&lt;/p>
&lt;ul>
&lt;li>빨간 줄을 지워가는 과정&lt;/li>
&lt;li>타입을 다루는 방법&lt;/li>
&lt;li>함수와 함수 타입&lt;/li>
&lt;li>유니언 타입과 인터섹트 타입&lt;/li>
&lt;li>제너릭 (타입ed 클래스, 타입 파라미터)&lt;/li>
&lt;li>컨디셔널 타입&lt;/li>
&lt;li>프로그래밍과 타입에 대한 고민&lt;/li>
&lt;/ul>
&lt;p>홈페이지에서 예제 코드를 함께 제공하고 있다.&lt;/p>
&lt;div id="outline-container-headline-2" class="outline-3">
&lt;h3 id="headline-2">
Lesson 1
&lt;/h3>
&lt;div id="outline-text-headline-2" class="outline-text-3">
&lt;pre class="example">
빨간 줄을 활성화 하기
&lt;/pre>
&lt;p>
VSCode 기준으로 강의를 진행하고 있고 빨간 줄을 줄이자! 를 목표로 안전한 코딩을 하기 위해 타입스크립트가 어떤 도움을 주고 있는지 안내하고 있다.&lt;/p>
&lt;p>
코딩 과정에서 타입이 제공되면서 함수를 호출하고 인자를 처리하는데 단순한 오탈자 뿐 아니라 코드를 이해하고 적용하는 방법도 소개하고 있다.&lt;/p>
&lt;p>
&amp;#39;//@ts-check&amp;#39; 를 통해서 기존 자바스크립트에서 개선하는 노하우도 알려주고 있다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">//@ts-check
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,
&lt;span style="color:#a6e22e">items&lt;/span>&lt;span style="color:#f92672">:&lt;/span> []
}
Object.&lt;span style="color:#a6e22e">defineProperty&lt;/span>(&lt;span style="color:#a6e22e">storage&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;max&amp;#39;&lt;/span>, { &lt;span style="color:#a6e22e">readonly&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#a6e22e">val&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">5000&lt;/span> })&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-3" class="outline-3">
&lt;h3 id="headline-3">
Lesson 2
&lt;/h3>
&lt;div id="outline-text-headline-3" class="outline-text-3">
&lt;pre class="example">
타입 추론 기능으로 버그를 찾자
&lt;/pre>
&lt;p>
찾을 수 없는 프로퍼티를 사용해 발생하는 버그를 소개로 챕터를 시작한다.
이건 매뉴얼 보면서 코드를 작성하면 나오지 않을 문제긴 하지만 보통 실행 과정에서 예외가 발생하는 경우로 버그를 발견하고 해결하기 시작한다.&lt;/p>
&lt;p>
왜 빨간 줄이 그어지는지에 대한 내용으로 타입 추론에 대해 소개하고 있다. 약(Weak) 타입 언어 환경에서 식별자에 대한 타입을 추론하고 코딩 과정에서 해당 식별자의 타입을 제안하여 안전한 코드를 만들어가는 과정을 제안한다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">storageUsed&lt;/span>() {
&lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">currentStorage&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
문법을 통해 식별자의 타입을 추론하는 기술도 가지고 있으니 VSCode 같은 자동 완성 기능을 포함한 환경을 제공하는 편집기를 사용하자.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">items&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">weigth&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-4" class="outline-3">
&lt;h3 id="headline-4">
Lesson 3
&lt;/h3>
&lt;div id="outline-text-headline-4" class="outline-text-3">
&lt;pre class="example">
구조적 타입 시스템을 제공하는 타입스크립트
&lt;/pre>
&lt;p>
타입은 무엇인가?&lt;/p>
&lt;blockquote>
&lt;p>A type is a classification of data that defines the operations that can be done on that data, the meaning of the data, and the set of allowed values Typing is checked by the compiler and/or run time to ensure the integrity of the data, enforce access restrictions, and interpret the data as meant by the developer&lt;/p>
&lt;ul>
&lt;li>Programming with Types, Vlad Riscutia&lt;/li>
&lt;/ul>
&lt;p>타입은;
해당 데이터에 대해 수행할 수 있는 작업을 구분하고,
데이터 스스로 의미를 규정하고,
컴파일러나 인터프리터가 오류없이 다룰 수 있는 값들에 대한 범위를 제한하며,
접근 제어를 강제하고,
개발자에게 데이터가 뭘 의미하는지 알려 준다.&lt;/p>
&lt;/blockquote>
&lt;p>
내 경우, 로우레벨로 보면 타입은 이 자료가 메모리를 얼마나 차지하고 있느냐, 라고 소개하고 뭉개 버린다.&lt;/p>
&lt;p>
타입은 프로그래밍에 필수 요소다. 아닌 것 같지만 자바스크립트도 타입이 있다.
number, string, boolean 이 대표적인 프리미티브 타입이다. object, array, function 등이 컴포지트 타입에 속한다.&lt;/p>
&lt;p>
자바스트립트는 타입이 있지만 동적 타입 언어에 속한다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1234&lt;/span>
&lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Onetwothreefour&amp;#39;&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>정의된 식별자에 다른 타입의 값을 지정해도 잘 동작하고 심지어 다른 타입끼리 연산도 허용되기도 한다. 😬&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> } &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
강타입이 주는 이점은 여러가지가 있다. 타입스크립트는 자바스크립트를 강타입 언어로 한 번 더 포장해 준다.&lt;/p>
&lt;p>
그리고 Shape 이란 용어가 소개되는데 타입스크립트의 구조적structural 타입 시스템을 설명하기 위해 사용된 것으로 보면 된다.&lt;/p>
&lt;div class="src src-js">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">person&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">firstName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Stefan&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">lastName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Baumgartner&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">age&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">38&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 코드는&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">firstName&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;span style="color:#a6e22e">lastName&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;span style="color:#a6e22e">age&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이런 모양shape으로 표현된다.&lt;/p>
&lt;p>
이 모양에 대한 설명은 구조적 타입 시스템으로 계속 반복된다. (이에 상대되는 개념으로 nominal type system 이 있습니다.)&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-5" class="outline-3">
&lt;h3 id="headline-5">
Lesson 4
&lt;/h3>
&lt;div id="outline-text-headline-5" class="outline-text-3">
&lt;pre class="example">
바닐라 자바스크립트에 JSDoc 을 적용하여 타입 추론을 맛보기
&lt;/pre>
&lt;p>
점진적으로 자바스크립트 코드를 개선하는 방법으로 JSDoc 을 추가하여 사용하는 것을 권하고 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jsdoc.app/">https://jsdoc.app/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>타입 정보가 없는 자바스크립트 코드에 JSDoc 을 추가하여 타입 정보를 참조할 수 있게 해주고 이는 더 안전한 코드를 만들기 위한 기초로 사용된다.&lt;/p>
&lt;pre class="example">
/**
* @typedef {Object} ShipStorage
* @property {number} max
* @property {StorageItem[]} items
*/
&lt;/pre>
&lt;div class="src src-javascript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/** @type ShipStorage */&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>,
&lt;span style="color:#a6e22e">items&lt;/span>&lt;span style="color:#f92672">:&lt;/span> []
}
&lt;span style="color:#75715e">//...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">currentStorage&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">storage&lt;/span>.&lt;span style="color:#a6e22e">items&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">weigth&lt;/span>
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
커스텀 타입을 사용하여 타입 추론 기능을 사용할 수 있다면 더 안전한 코드를 작성할 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-6" class="outline-3">
&lt;h3 id="headline-6">
Lesson 5
&lt;/h3>
&lt;div id="outline-text-headline-6" class="outline-text-3">
&lt;pre class="example">
타입 선언 파일으로 타입을 재사용하기
&lt;/pre>
&lt;p>
타입스크립트는 자바스크립트의 수퍼셋으로 불리는데 이는 타입스크립트가 자바스크립트의 모든 것을 포함하고 있고 자바스크립트 보다 더 많은 부분을 가지고 있다는 뜻이다.
자바스크립트 코드는 타입스크립트 코드로 동작할 수 있지만 반대는 성립하지 못한다.
그래서 타입스크립트 코드를 브라우저나 노드JS 환경에서 직접 동작시킬 수 없다.&lt;/p>
&lt;p>
자바스크립트와 다른 첫번째 특징은 &amp;#39;.d.ts&amp;#39; 파일로 불리는 타입 선언 시스템이다.
선언된 타입들은 export 키워드로 선언하면 다른 파일에서 참조할 수 있다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">StorageItem&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">weight&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>
}
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ShipStorage&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">max&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>,
&lt;span style="color:#a6e22e">items&lt;/span>: &lt;span style="color:#66d9ef">StorageItem&lt;/span>[]
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>이 선언된 파일을 자바스크립트에서 사용하기 위해 &amp;#39;@ts-check&amp;#39; 아래에 이어&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#75715e">/** @typedef { import(&amp;#39;./types.d&amp;#39;).ShipStorage } ShipStorage */&lt;/span>
&lt;span style="color:#75715e">/** @typedef { import(&amp;#39;./types.d&amp;#39;).StorageItem } StorageItem */&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>선언하여 타입 시스템을 활성화 시킬 수 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-7" class="outline-3">
&lt;h3 id="headline-7">
Lesson 6
&lt;/h3>
&lt;div id="outline-text-headline-7" class="outline-text-3">
&lt;pre class="example">
엠비언트 타입 정의 파일
&lt;/pre>
&lt;p>
타입 선언을 별도의 파일로 관리하고 재사용 할 수 있다면 더 나은 코딩 환경을 구성할 수 있다. 소스 코드를 수정하지 않고 전역으로 사용할 수 있는 타입을 선언하여 디버깅 환경을 활성화 시키는 기법도 있다.&lt;/p>
&lt;p>
jQuery 같은 라이브러리는 타입스크립트로 개발된 코드가 아니기에 별도의 타입 선언이 담긴 파일을 제공하지 않는다. 대신 앰비언트 타입 정의 파일을 추가하여 타입스크립트 개발 환경에 적용하자.&lt;/p>
&lt;div class="src src-shell">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">npm i @types/jquery&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-8" class="outline-3">
&lt;h3 id="headline-8">
Lesson 7
&lt;/h3>
&lt;div id="outline-text-headline-8" class="outline-text-3">
&lt;pre class="example">
타입스크립트의 도구들
&lt;/pre>
&lt;p>
NodeJS 패키지 매니저를 통해 타입스크립트 컴파일러를 설치하여 사용할 수 있다.&lt;/p>
&lt;div class="src src-shell">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">npm i -g typescript&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
&amp;#39;tsconfig.json&amp;#39; 파일은 타입스크립트 컴파일러의 컴파일 환경을 정의하고 있다.&lt;/p>
&lt;ol>
&lt;li>target: 컴파일러의 빌드 타겟.&lt;/li>
&lt;li>module: 빌드 파일의 모듈 시스템. commonjs 와 es2020 이 지원된다.&lt;/li>
&lt;li>esModuleInterop: 모듈 시스템과 결부되어 더 깊은 호환성을 제공한다.&lt;/li>
&lt;li>allowJs: .ts 파일이 아닌 .js 파일을 참조할 수 있게 허용한다.&lt;/li>
&lt;li>checkJs: 일반 자바스크립트 파일에도 타입 체크를 적용한다.&lt;/li>
&lt;li>typeRoots: 타입 정의 파일의 위치를 지정한다.&lt;/li>
&lt;/ol>
&lt;p>tsc 의 `–noEmit` 옵션과 `–watch` 옵션도 소개하고 있다.&lt;/p>
&lt;/div>
&lt;/div>
&lt;div id="outline-container-headline-9" class="outline-3">
&lt;h3 id="headline-9">
Lesson 8
&lt;/h3>
&lt;div id="outline-text-headline-9" class="outline-text-3">
&lt;pre class="example">
타입스크립트로 컴파일하기
&lt;/pre>
&lt;p>
타입스크립트는 브라우저에서 바로 실행되지 않기 때문에 컴파일을 하여 자바스크립트로 변환해야 한다. 자바스크립트 파일의 확장자를 `.ts` 로 바꿏는 것만으로도 타입스크립트 파일로 변경된다.
`tsconfig.json` 파일을 생성하고 컴파일러 옵션을 정의하자.&lt;/p>
&lt;div class="src src-json">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;compilerOptions&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;target&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;ES2020&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;module&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;es2020&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;typeRoots&amp;#34;&lt;/span>: [
&lt;span style="color:#e6db74">&amp;#34;@types&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;node_modules/@types&amp;#34;&lt;/span>
],
&lt;span style="color:#f92672">&amp;#34;esModuleInterop&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
}
}&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
타입스크립트는 코드에 어노테이션을 추가하여 타입을 정의한다.&lt;/p>
&lt;div class="src src-typescript">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">addVAT&lt;/span>(&lt;span style="color:#a6e22e">price&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>, &lt;span style="color:#a6e22e">vat&lt;/span>: &lt;span style="color:#66d9ef">numer&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.2&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">vat&lt;/span>)
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">boom&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">addVAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;this is not a number!&amp;#39;&lt;/span>)&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></content></item></channel></rss>